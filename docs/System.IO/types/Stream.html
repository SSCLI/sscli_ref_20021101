<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../refdoc.css">
<title>Type: System.IO.Stream</title>
</head>
<body><a name="TopOfPage"></a><h2>System.IO.Stream Class</h2><b>Assembly: </b>Mscorlib.dll<br><b>Namespace: </b>System.IO<br><dl>
<dt><b>Summary</b></dt>
<dd> Provides a generic view of a sequence of bytes.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code>[Serializable]<br><b>public abstract class Stream : MarshalByRefObject, IDisposable</b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Streams involve three fundamental operations: <OL>
<li> You can read from streams. Reading is the transfer of data from a stream into a data structure, such as an array of bytes.</li>
<li> You can write to streams. Writing is the transfer of data from a data structure into a stream.</li>
<li> Streams can support seeking. Seeking is the querying and modifying of the current position within a stream. Seek capability depends on the kind of backing store a stream has. For example, network streams have no unified concept of a current position, and therefore typically do not support seeking.</li>
</OL>
<p><b>Stream</b> is the abstract base class of all streams. A stream is an abstraction of a sequence of bytes, such as a file, an input/output device, an inter-process communication pipe, or a TCP/IP socket. The <b>Stream</b> class and its derived classes provide a generic view of these different types of input and output, isolating the programmer from the specific details of the operating system and the underlying devices.</p>
<p> Depending on the underlying data source or repository, streams might support only some of these capabilities. An application can query a stream for its capabilities by using the  <a href="#CanRead">Stream.CanRead</a>,  <a href="#CanWrite">Stream.CanWrite</a>, and  <a href="#CanSeek">Stream.CanSeek</a> properties.</p>
<p> The  <a href="#Read(System.Byte[],System.Int32,System.Int32)">Stream.Read</a> and  <a href="#Write(System.Byte[],System.Int32,System.Int32)">Stream.Write</a> methods read and write data in a variety of formats. For streams that support seeking, use the  <a href="#Seek(System.Int64,System.IO.SeekOrigin)">Stream.Seek</a> and  <a href="#SetLength(System.Int64)">Stream.SetLength</a> methods and the  <a href="#Position">Stream.Position</a> and  <a href="#Length">Stream.Length</a> properties to query and modify the current position and length of a stream.</p>
<p> Some stream implementations perform local buffering of the underlying data to improve performance. For such streams, the  <a href="#Flush">Stream.Flush</a> method can be used to clear any internal buffers and ensure that all data has been written to the underlying data source or repository.</p>
<p> Calling  <a href="#Close">Stream.Close</a> on a <b>Stream</b> flushes any buffered data, essentially calling <b>Flush</b> for you.<b>Close</b> also releases operating system resources such as file handles, network connections, or memory used for any internal buffering. The  <a href="../../System.IO/types/BufferedStream.html">BufferedStream</a> class provides the capability of wrapping a buffered stream around another stream in order to improve read and write performance.</p>
<p> If you need a stream with no backing store (also known as a bit bucket), use  <a href="#Null">Stream.Null</a>.</p><br><br><b>Notes to implementors: </b> When implementing a derived class of <b>Stream</b>, you must provide implementations for the  <a href="#Read(System.Byte[],System.Int32,System.Int32)">Stream.Read</a> and  <a href="#Write(System.Byte[],System.Int32,System.Int32)">Stream.Write</a> methods. The asynchronous methods  <a href="#BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">Stream.BeginRead</a>,  <a href="#EndRead(System.IAsyncResult)">Stream.EndRead</a>,  <a href="#BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">Stream.BeginWrite</a>, and  <a href="#EndWrite(System.IAsyncResult)">Stream.EndWrite</a> are implemented through the synchronous methods <b>Read</b> and <b>Write</b>. Similarly, your implementations of <b>Read</b> and <b>Write</b> will work correctly with the asynchronous methods. The default implementations of  <a href="#ReadByte">Stream.ReadByte</a> and  <a href="#WriteByte(System.Byte)">Stream.WriteByte</a> create a new single-element byte array, and then call your implementations of <b>Read</b> and <b>Write</b>. When deriving from <b>Stream</b>, if you have an internal byte buffer, it is strongly recommended that you override these methods to access your internal buffer for substantially better performance. You must also provide implementations of  <a href="#CanRead">Stream.CanRead</a>,  <a href="#CanSeek">Stream.CanSeek</a>,  <a href="#CanWrite">Stream.CanWrite</a>,  <a href="#Flush">Stream.Flush</a>,  <a href="#Length">Stream.Length</a>,  <a href="#Position">Stream.Position</a>,  <a href="#Seek(System.Int64,System.IO.SeekOrigin)">Stream.Seek</a>, and  <a href="#SetLength(System.Int64)">Stream.SetLength</a>.</dd>
</dl><b>See also: </b><dl>
<dd> <a href="../../System.IO/System.IO.html">System.IO Namespace</a> |  <a href="../../System.IO/types/FileStream.html">FileStream</a> |  <a href="../../System.IO/types/MemoryStream.html">MemoryStream</a> |  <a href="../../System.IO/types/BufferedStream.html">BufferedStream</a></dd>
</dl>
<h3>System.IO.Stream Member List: </h3>
<dl>
<dt><b>Public Fields</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#Null">Null</a></td>
<td width="55%"></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Public Properties</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#CanRead">CanRead</a></td>
<td width="55%"><b>Read-only</b><br><br> When overridden in a derived class, gets a value indicating whether the current stream supports reading.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#CanSeek">CanSeek</a></td>
<td width="55%"><b>Read-only</b><br><br> When overridden in a derived class, gets a value indicating whether the current stream supports seeking.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#CanWrite">CanWrite</a></td>
<td width="55%"><b>Read-only</b><br><br> When overridden in a derived class, gets a value indicating whether the current stream supports writing.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Length">Length</a></td>
<td width="55%"><b>Read-only</b><br><br> When overridden in a derived class, gets the length in bytes of the stream.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Position">Position</a></td>
<td width="55%"><b>Read-write</b><br><br> When overridden in a derived class, gets or sets the position within the current stream.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Public Methods</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">BeginRead</a></td>
<td width="55%"> Begins an asynchronous read operation.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">BeginWrite</a></td>
<td width="55%"> Begins an asynchronous write operation.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Close">Close</a></td>
<td width="55%"> Closes the current stream and releases any resources (such as sockets and file handles) associated with the current stream.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#CreateObjRef(System.Type)">CreateObjRef</a><br>(inherited from <b>System.MarshalByRefObject)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/MarshalByRefObject.html#CreateObjRef(System.Type)">System.MarshalByRefObject.CreateObjRef</a></font></b><br><br><br> Creates an object that contains all the relevant information required to generate a proxy used to communicate with a remote object.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#EndRead(System.IAsyncResult)">EndRead</a></td>
<td width="55%"> Waits for the pending asynchronous read to complete.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#EndWrite(System.IAsyncResult)">EndWrite</a></td>
<td width="55%"> Ends an asynchronous write operation.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Equals(System.Object)">Equals</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#Equals(System.Object)">System.Object.Equals</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Flush">Flush</a></td>
<td width="55%"> When overridden in a derived class, clears all buffers for this stream and causes any buffered data to be written to the underlying device.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetHashCode">GetHashCode</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#GetHashCode">System.Object.GetHashCode</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetLifetimeService">GetLifetimeService</a><br>(inherited from <b>System.MarshalByRefObject)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/MarshalByRefObject.html#GetLifetimeService">System.MarshalByRefObject.GetLifetimeService</a></font></b><br><br><br> Retrieves the current lifetime service object that controls the lifetime policy for this instance.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetType">GetType</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#GetType">System.Object.GetType</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#InitializeLifetimeService">InitializeLifetimeService</a><br>(inherited from <b>System.MarshalByRefObject)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/MarshalByRefObject.html#InitializeLifetimeService">System.MarshalByRefObject.InitializeLifetimeService</a></font></b><br><br><br> Obtains a lifetime service object to control the lifetime policy for this instance.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Read(System.Byte[],System.Int32,System.Int32)">Read</a></td>
<td width="55%"> When overridden in a derived class, reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ReadByte">ReadByte</a></td>
<td width="55%"> Reads a byte from the stream and advances the position within the stream by one byte, or returns -1 if at the end of the stream.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Seek(System.Int64,System.IO.SeekOrigin)">Seek</a></td>
<td width="55%"> When overridden in a derived class, sets the position within the current stream.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#SetLength(System.Int64)">SetLength</a></td>
<td width="55%"> When overridden in a derived class, sets the length of the current stream.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ToString">ToString</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#ToString">System.Object.ToString</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Write(System.Byte[],System.Int32,System.Int32)">Write</a></td>
<td width="55%"> When overridden in a derived class, writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#WriteByte(System.Byte)">WriteByte</a></td>
<td width="55%"> Writes a byte to the current position in the stream and advances the position within the stream by one byte.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Protected Constructors</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#ctor1">ctor #1</a></td>
<td width="55%">Default constructor. This constructor is called by derived class constructors to initialize state in this type.<br></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Protected Methods</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#CreateWaitHandle">CreateWaitHandle</a></td>
<td width="55%"> Allocates a  <a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a> object.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Finalize">Finalize</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#Finalize">System.Object.Finalize</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#MemberwiseClone">MemberwiseClone</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#MemberwiseClone">System.Object.MemberwiseClone</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
</table>
</dd>
</dl>
<p><b>Hierarchy:</b><ul class="none">
<li><a href="../../System/types/Object.html">System.Object</a></li>
<ul class="none">
<li><a href="../../System/types/MarshalByRefObject.html">System.MarshalByRefObject</a></li>
<ul class="none">
<li><b>System.IO.Stream</b><ul class="none">
<li><a href="../../System.IO/types/BufferedStream.html">System.IO.BufferedStream</a></li>
<li><a href="../../System.IO/types/FileStream.html">System.IO.FileStream</a></li>
<li><a href="../../System.IO/types/MemoryStream.html">System.IO.MemoryStream</a></li>
<li><a href="../../System.Net.Sockets/types/NetworkStream.html">System.Net.Sockets.NetworkStream</a></li>
</ul>
</li>
</ul>
</ul>
</ul>
</p>
<hr>
<h3>System.IO.Stream Member Details</h3><b><i><a name=".ctorTopic1"></a><a name="ctor1">ctor #1</a></i></b><b><i></i></b><br><dl>
<dt><b>Summary:
										</b></dt>
<dd>Default constructor. This constructor is called by derived class constructors to initialize state in this type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected Stream();</b></code></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Field: <i><a name="NullTopic1"></a><a name="Null">Null</a></i></b><b><i></i></b><dl>
<dt><b>Summary</b></dt>
<dd> A <b>Stream</b> with no backing store.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public static readonly <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfmemberstopic.asp">Stream</a> Null;
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Use <b>Null</b> to redirect output to a stream that will not consume any operating system resources. When the methods of <b>Stream</b> that provide writing are invoked on <b>Null</b>, the call simply returns, and no data is written.<b>Null</b> also implements a <b>Read</b> method that returns zero without reading data.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="CanReadTopic1"></a><a name="CanRead">CanRead</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, gets a value indicating whether the current stream supports reading.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/Boolean.html">bool</a> CanRead {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> If a class derived from  <a href="../../System.IO/types/Stream.html">Stream</a> does not support reading, calls to the  <a href="#Read(System.Byte[],System.Int32,System.Int32)">Stream.Read</a>,  <a href="#ReadByte">Stream.ReadByte</a>, and  <a href="#BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">Stream.BeginRead</a> methods throw a  <a href="../../System/types/NotSupportedException.html">NotSupportedException</a>.<p> If the stream is closed, this property returns <b>false</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following is an example of using the <b>CanRead</b> property.<pre>
 using System;
 using System.IO;
 
class TestRW 
{
   public static void Main(String[] args)
   {
 
      FileStream fs = new FileStream("MyFile.txt", FileMode.OpenOrCreate, FileAccess.Read);
         if (fs.CanRead &amp;&amp; fs.CanWrite)
         {
            Console.WriteLine("MyFile.txt can be both written to and read from.");
         }
         else if (fs.CanRead)
         {
            Console.WriteLine("MyFile.txt is not writable.");
      }
   }
}
 //This code outputs "MyFile.txt is not writable."
 //To get the output message "MyFile.txt can be both written to and read from.",
 //change the FileAccess parameter to ReadWrite in the FileStream constructor.

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="CanSeekTopic1"></a><a name="CanSeek">CanSeek</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, gets a value indicating whether the current stream supports seeking.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/Boolean.html">bool</a> CanSeek {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> If a class derived from  <a href="../../System.IO/types/Stream.html">Stream</a> does not support seeking, calls to  <a href="#Length">Stream.Length</a>,  <a href="#SetLength(System.Int64)">Stream.SetLength</a>,  <a href="#Position">Stream.Position</a>, and  <a href="#Seek(System.Int64,System.IO.SeekOrigin)">Stream.Seek</a> throw a  <a href="../../System/types/NotSupportedException.html">NotSupportedException</a>.<p> If the stream is closed, this property returns <b>false</b>.</p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="CanWriteTopic1"></a><a name="CanWrite">CanWrite</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, gets a value indicating whether the current stream supports writing.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/Boolean.html">bool</a> CanWrite {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> If a class derived from  <a href="../../System.IO/types/Stream.html">Stream</a> does not support writing, a call to  <a href="#Write(System.Byte[],System.Int32,System.Int32)">Stream.Write</a>,  <a href="#BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">Stream.BeginWrite</a>, or  <a href="#WriteByte(System.Byte)">Stream.WriteByte</a> throws a  <a href="../../System/types/NotSupportedException.html">NotSupportedException</a>.<p> If the stream is closed, this property returns <b>false</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following is an example of using the <b>CanWrite</b> property.<pre>
 using System;
 using System.IO;
 
 class TestRW 
 {
   public static void Main(String[] args)
   { 
     FileStream fs = new FileStream("MyFile.txt", FileMode.OpenOrCreate,
        FileAccess.Write);
     if (fs.CanRead &amp;&amp; fs.CanWrite) {
         Console.WriteLine("MyFile.txt can be both written to and read from.");
     }
     else if (fs.CanWrite) {
         Console.WriteLine("MyFile.txt is writable.");
     }
   }
 }
 //This code outputs "MyFile.txt is writable."
 //To get the output message "MyFile.txt can be both written to and read from.",
 //change the FileAccess parameter to ReadWrite in the FileStream constructor.

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="LengthTopic1"></a><a name="Length">Length</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, gets the length in bytes of the stream.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/Int64.html">long</a> Length {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> A class derived from <b>Stream</b> does not support seeking.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ObjectDisposedException.html">ObjectDisposedException</a></td>
<td> Methods were called after the stream was closed.</td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd> The following is an example of using the <b>Length</b> and <b>Position</b> properties.<pre>
 if( s.Length==s.Position )
 {
    Console.WriteLine("End of file has been reached.");
 }

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="PositionTopic1"></a><a name="Position">Position</a></i></b><b><i></i></b><b><font color="#008080"> (read-write)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, gets or sets the position within the current stream.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/Int64.html">long</a> Position {get; set;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.IO/types/IOException.html">IOException</a></td>
<td> An I/O error occurs, such as the stream being closed.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> The stream does not support seeking.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ObjectDisposedException.html">ObjectDisposedException</a></td>
<td> Methods were called after the stream was closed.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The stream must support seeking to get or set the position. Use the  <a href="#CanSeek">Stream.CanSeek</a> property to determine whether the stream supports seeking.<p> Seeking to any location beyond the length of the stream is supported.</p>
<p> The <b>Position</b> property does not keep track of the number of bytes from the stream that have been consumed, skipped, or both.</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following is an example of using the <b>Length</b> and <b>Position</b> properties.<pre>
 if( s.Length==s.Position )
 {
    Console.WriteLine("End of file has been reached.");
 }

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="BeginReadTopic1"></a><a name="BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">BeginRead</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Byte.html">byte[]</a> <i>buffer</i>,</font><br>   <font color="#008080"><a href="../../System/types/Int32.html">int</a> <i>offset</i>,</font><br>   <font color="#008080"><a href="../../System/types/Int32.html">int</a> <i>count</i>,</font><br>   <font color="#008080"><a href="../../System/types/AsyncCallback.html">AsyncCallback</a> <i>callback</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>state</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Begins an asynchronous read operation.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/IAsyncResult.html">IAsyncResult</a> BeginRead(<br>   <font color="#008080"><a href="../../System/types/Byte.html">byte[]</a> <i>buffer</i>,</font><br>   <font color="#008080"><a href="../../System/types/Int32.html">int</a> <i>offset</i>,</font><br>   <font color="#008080"><a href="../../System/types/Int32.html">int</a> <i>count</i>,</font><br>   <font color="#008080"><a href="../../System/types/AsyncCallback.html">AsyncCallback</a> <i>callback</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>state</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>buffer</i><br><dl>
<dd>
<param> The buffer to read the data into.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>offset</i><br><dl>
<dd>
<param> The byte offset in <i>buffer</i> at which to begin writing data read from the stream.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>count</i><br><dl>
<dd>
<param> The maximum number of bytes to read.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>callback</i><br><dl>
<dd>
<param> An optional asynchronous callback, to be called when the read is complete.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>state</i><br><dl>
<dd>
<param> A user-provided object that distinguishes this particular asynchronous read request from other requests.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An  <a href="../../System/types/IAsyncResult.html">IAsyncResult</a> that represents the asynchronous read, which could still be pending.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.IO/types/IOException.html">IOException</a></td>
<td> Attempted an asynchronous read past the end of the file, or a disk error occurs.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td> One or more or the arguments is invalid.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ObjectDisposedException.html">ObjectDisposedException</a></td>
<td> Methods were called after the stream was closed.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> The current <b>Stream</b> implementation does not support the read operation.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Pass the <b>IAsyncResult</b> return value to the  <a href="#EndRead(System.IAsyncResult)">Stream.EndRead</a> method of the stream to determine how many bytes were read and to release operating system resources used for reading. You can do this either by using the same code that called <b>BeginRead</b> or in a callback passed to <b>BeginRead</b>.<p> The current position in the stream is updated when the asynchronous read or write is issued, not when the I/O operation completes.</p>
<p> Multiple simultaneous asynchronous requests render the request completion order uncertain.</p>
<p> Use the  <a href="#CanRead">Stream.CanRead</a> property to determine whether the current instance supports reading.</p>
<p> If a stream is closed or you pass an invalid argument, exceptions are thrown immediately from <b>BeginRead</b>. Errors that occur during an asynchronous read request, such as a disk failure during the I/O request, occur on the threadpool thread and become visible upon a call to <b>EndRead</b>. Exceptions thrown by the threadpool thread will not be visible when calling  <a href="#EndWrite(System.IAsyncResult)">Stream.EndWrite</a>.</p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="BeginWriteTopic1"></a><a name="BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">BeginWrite</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Byte.html">byte[]</a> <i>buffer</i>,</font><br>   <font color="#008080"><a href="../../System/types/Int32.html">int</a> <i>offset</i>,</font><br>   <font color="#008080"><a href="../../System/types/Int32.html">int</a> <i>count</i>,</font><br>   <font color="#008080"><a href="../../System/types/AsyncCallback.html">AsyncCallback</a> <i>callback</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>state</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Begins an asynchronous write operation.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/IAsyncResult.html">IAsyncResult</a> BeginWrite(<br>   <font color="#008080"><a href="../../System/types/Byte.html">byte[]</a> <i>buffer</i>,</font><br>   <font color="#008080"><a href="../../System/types/Int32.html">int</a> <i>offset</i>,</font><br>   <font color="#008080"><a href="../../System/types/Int32.html">int</a> <i>count</i>,</font><br>   <font color="#008080"><a href="../../System/types/AsyncCallback.html">AsyncCallback</a> <i>callback</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>state</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>buffer</i><br><dl>
<dd>
<param> The buffer to write data to. This should generally be greater than 64 kilobytes.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>offset</i><br><dl>
<dd>
<param> The byte offset in <i>buffer</i> at which to begin writing.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>count</i><br><dl>
<dd>
<param> The maximum number of bytes to write.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>callback</i><br><dl>
<dd>
<param> An optional asynchronous callback, to be called when the write is complete.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>state</i><br><dl>
<dd>
<param> A user-provided object that distinguishes this particular asynchronous write request from other requests.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An <b>IAsyncResult</b> that represents the asynchronous write, which could still be pending.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.IO/types/IOException.html">IOException</a></td>
<td> Attempted an asynchronous write past the end of the file, or a disk error occurs.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td> One or more or the arguments is invalid.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ObjectDisposedException.html">ObjectDisposedException</a></td>
<td> Methods were called after the stream was closed.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> The current <b>Stream</b> implementation does not support the write operation.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Pass the <b>IAsyncResult</b> returned by the current method to  <a href="#EndWrite(System.IAsyncResult)">Stream.EndWrite</a> to ensure that the write completes and frees resources appropriately. You can do this either by using the same code that called <b>BeginWrite</b> or in a callback passed to <b>BeginWrite</b>. If an error occurs during an asynchronous write, an exception will not be thrown until <b>EndWrite</b> is called with the <b>IAsyncResult</b> returned by this method.<p> If a stream is writable, writing at the end of the stream expands the stream.</p>
<p> The current position in the stream is updated when you issue the asynchronous read or write, not when the I/O operation completes. Multiple simultaneous asynchronous requests render the request completion order uncertain.</p>
<p> Use the  <a href="#CanWrite">Stream.CanWrite</a> property to determine whether the current instance supports writing.</p>
<p> If a stream is closed or you pass an invalid argument, exceptions are thrown immediately from <b>BeginWrite</b>. Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, occur on the threadpool thread and become visible upon a call to <b>EndWrite</b>. Exceptions thrown by the threadpool thread will not be visible when calling <b>EndWrite</b>.</p>
</dd>
</dl><b>See also: 
			</b><br> <a href="#EndWrite(System.IAsyncResult)">Stream.EndWrite</a> |  <a href="#CanWrite">Stream.CanWrite</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="CloseTopic1"></a><a name="Close">Close</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Closes the current stream and releases any resources (such as sockets and file handles) associated with the current stream.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual void Close();</b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Flushing the stream will not flush its underlying encoder unless you explicitly call an implementation of  <a href="#Flush">Stream.Flush</a> or <b>Close</b>. Setting  <a href="../../System.IO/types/StreamWriter.html#AutoFlush">StreamWriter.AutoFlush</a> to <b>true</b> means that data will be flushed from the buffer to the stream, but the encoder state will not be flushed. This allows the encoder to keep its state (partial characters) so that it can encode the next block of characters correctly. This scenario affects UTF8 and UTF7 where certain characters can only be encoded after the encoder receives the adjacent character or characters.<p> A call to <b>Close</b> is required for proper operation of a stream. Following a call to <b>Close</b>, other operations on the stream could throw exceptions. If the stream is already closed, a call to <b>Close</b> throws no exceptions.</p>
<p> Attempts to manipulate the stream after the stream has been closed might throw an  <a href="../../System/types/ObjectDisposedException.html">ObjectDisposedException</a>.</p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="CreateObjRefTopic1"></a><a name="CreateObjRef(System.Type)">CreateObjRef</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>requestedType</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/MarshalByRefObject.html#CreateObjRef(System.Type)">System.MarshalByRefObject.CreateObjRef</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Creates an object that contains all the relevant information required to generate a proxy used to communicate with a remote object.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System.Runtime.Remoting/types/ObjRef.html">ObjRef</a> CreateObjRef(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>requestedType</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>requestedType</i><br><dl>
<dd>
<param> The  <a href="../../System/types/Type.html">Type</a> of the object that the new  <a href="../../System.Runtime.Remoting/types/ObjRef.html">ObjRef</a> will reference.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Information required to generate a proxy.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Runtime.Remoting/types/RemotingException.html">RemotingException</a></td>
<td> This instance is not a valid remoting object.</td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="CreateWaitHandleTopic1"></a><a name="CreateWaitHandle">CreateWaitHandle</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Allocates a  <a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a> object.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected virtual <a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a> CreateWaitHandle();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A reference to the allocated <b>WaitHandle</b>.</dd>
</dl><b>Remarks</b><dl>
<dd> When called for the first time, the current method creates a <b>WaitHandle</b> object and returns it. On subsequent calls, the <b>CreateWaitHandle</b> returns a reference to the same wait handle.<p> Use this method if you implement the asynchronous methods and require a way of blocking in  <a href="#EndRead(System.IAsyncResult)">Stream.EndRead</a> or  <a href="#EndWrite(System.IAsyncResult)">Stream.EndWrite</a> until the asynchronous operation is complete.</p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="EndReadTopic1"></a><a name="EndRead(System.IAsyncResult)">EndRead</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/IAsyncResult.html">IAsyncResult</a> <i>asyncResult</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Waits for the pending asynchronous read to complete.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/Int32.html">int</a> EndRead(<br>   <font color="#008080"><a href="../../System/types/IAsyncResult.html">IAsyncResult</a> <i>asyncResult</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>asyncResult</i><br><dl>
<dd>
<param> The reference to the pending asynchronous request to finish.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The number of bytes read from the stream, between zero (0) and the number of bytes you requested. Streams only return zero (0) at the end of the stream, otherwise, they should block until at least one byte is available.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>asyncResult</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>asyncResult</i> did not originate from a  <a href="#BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">Stream.BeginRead</a> method on the current stream.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Call <b>EndRead</b> to determine how many bytes were read from the stream.<p><b>EndRead</b> can be called once on every  <a href="../../System/types/IAsyncResult.html">IAsyncResult</a> from  <a href="#BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">Stream.BeginRead</a>.</p>
<p> This method blocks until the I/O operation has completed.</p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="EndWriteTopic1"></a><a name="EndWrite(System.IAsyncResult)">EndWrite</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/IAsyncResult.html">IAsyncResult</a> <i>asyncResult</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Ends an asynchronous write operation.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual void EndWrite(<br>   <font color="#008080"><a href="../../System/types/IAsyncResult.html">IAsyncResult</a> <i>asyncResult</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>asyncResult</i><br><dl>
<dd>
<param> A reference to the outstanding asynchronous I/O request.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>asyncResult</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>asyncResult</i> did not originate from a  <a href="#BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">Stream.BeginWrite</a> method on the current stream.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd><b>EndWrite</b> must be called exactly once on every  <a href="../../System/types/IAsyncResult.html">IAsyncResult</a> from  <a href="#BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">Stream.BeginWrite</a>.<p> This method blocks until the I/O operation has completed. Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, occur on the threadpool thread and become visible upon a call to <b>EndWrite</b>. Exceptions thrown by the threadpool thread will not be visible when calling <b>EndWrite</b>.</p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="EqualsTopic1"></a><a name="Equals(System.Object)">Equals</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>obj</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#Equals(System.Object)">System.Object.Equals</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/Boolean.html">bool</a> Equals(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>obj</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="FinalizeTopic1"></a><a name="Finalize">Finalize</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#Finalize">System.Object.Finalize</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            ~Stream();</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="FlushTopic1"></a><a name="Flush">Flush</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, clears all buffers for this stream and causes any buffered data to be written to the underlying device.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract void Flush();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.IO/types/IOException.html">IOException</a></td>
<td> An I/O error occurs, such as the file being already closed.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Override <b>Flush</b> on streams that implement a buffer. Use this method to move any information from an underlying buffer to its destination, clear the buffer, or both. Depending upon the state of the object, you might have to modify the current position within the stream (for example, if the underlying stream supports seeking). For additional information see  <a href="#CanSeek">Stream.CanSeek</a>.<p> Flushing the stream will not flush its underlying encoder unless you explicitly call an implementation of <b>Flush</b> or  <a href="#Close">Stream.Close</a>. Setting  <a href="../../System.IO/types/StreamWriter.html#AutoFlush">StreamWriter.AutoFlush</a> to <b>true</b> means that data will be flushed from the buffer to the stream, but the encoder state will not be flushed. This allows the encoder to keep its state (partial characters) so that it can encode the next block of characters correctly. This scenario affects UTF8 and UTF7 where certain characters can only be encoded after the encoder receives the adjacent character or characters.</p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetHashCodeTopic1"></a><a name="GetHashCode">GetHashCode</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#GetHashCode">System.Object.GetHashCode</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/Int32.html">int</a> GetHashCode();</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetLifetimeServiceTopic1"></a><a name="GetLifetimeService">GetLifetimeService</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/MarshalByRefObject.html#GetLifetimeService">System.MarshalByRefObject.GetLifetimeService</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Retrieves the current lifetime service object that controls the lifetime policy for this instance.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Object.html">object</a> GetLifetimeService();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An object of type  <a href="../../System.Runtime.Remoting.Lifetime/types/ILease.html">ILease</a> used to control the lifetime policy for this instance.</dd>
</dl><b>Remarks</b><dl>
<dd> For more information about lifetime services, see the  <a href="../../System.Runtime.Remoting.Lifetime/types/LifetimeServices.html">LifetimeServices</a> class.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetTypeTopic1"></a><a name="GetType">GetType</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#GetType">System.Object.GetType</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Type.html">Type</a> GetType();</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="InitializeLifetimeServiceTopic1"></a><a name="InitializeLifetimeService">InitializeLifetimeService</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/MarshalByRefObject.html#InitializeLifetimeService">System.MarshalByRefObject.InitializeLifetimeService</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Obtains a lifetime service object to control the lifetime policy for this instance.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/Object.html">object</a> InitializeLifetimeService();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An object of type  <a href="../../System.Runtime.Remoting.Lifetime/types/ILease.html">ILease</a> used to control the lifetime policy for this instance. This is the current lifetime service object for this instance if one exists; otherwise, a new lifetime service object initialized to the value of the  <a href="../../System.Runtime.Remoting.Lifetime/types/LifetimeServices.html#LeaseManagerPollTime">LifetimeServices.LeaseManagerPollTime</a> property.</dd>
</dl><b>Remarks</b><dl>
<dd> For more information about lifetime services, see the  <a href="../../System.Runtime.Remoting.Lifetime/types/LifetimeServices.html">LifetimeServices</a> class.</dd>
</dl><b>Example</b><dl>
<dd> The following code example demonstrates creating a lease.<pre>
 public class MyClass : MarshalByRefObject
 {
   public override Object InitializeLifetimeService()
   {
     ILease lease = (ILease)base.InitializeLifetimeService();
     if (lease.CurrentState == LeaseState.Initial)
     {
          lease.InitialLeaseTime = TimeSpan.FromMinutes(1);
          lease.SponsorshipTimeout = TimeSpan.FromMinutes(2);
           lease.RenewOnCallTime = TimeSpan.FromSeconds(2);
     }
       return lease;
   }
 }

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="MemberwiseCloneTopic1"></a><a name="MemberwiseClone">MemberwiseClone</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#MemberwiseClone">System.Object.MemberwiseClone</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected <a href="../../System/types/Object.html">object</a> MemberwiseClone();</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="ReadTopic1"></a><a name="Read(System.Byte[],System.Int32,System.Int32)">Read</a></i></b><b><i>(<br>   <font color="#008080"><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfmemberstopic.asp">in</a> <i>byte[] buffer</i>,</font><br>   <font color="#008080"><a href="../../System/types/Int32.html">int</a> <i>offset</i>,</font><br>   <font color="#008080"><a href="../../System/types/Int32.html">int</a> <i>count</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/Int32.html">int</a> Read(<br>   <font color="#008080"><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfmemberstopic.asp">in</a> <i>byte[] buffer</i>,</font><br>   <font color="#008080"><a href="../../System/types/Int32.html">int</a> <i>offset</i>,</font><br>   <font color="#008080"><a href="../../System/types/Int32.html">int</a> <i>count</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>buffer</i><br><dl>
<dd>
<param> An array of bytes. When this method returns, the buffer contains the specified byte array with the values between <i>offset</i> and (<i>offset</i> + <i>count</i>) replaced by the bytes read from the current source.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>offset</i><br><dl>
<dd>
<param> The zero-based byte offset in <i>buffer </i> at which to begin storing the data read from the current stream.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>count</i><br><dl>
<dd>
<param> The maximum number of bytes to be read from the current stream.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The total number of bytes read into the buffer. This may be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td> The sum of <i>offset</i> and <i>count</i> is larger than the buffer length.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>buffer</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentOutOfRangeException.html">ArgumentOutOfRangeException</a></td>
<td><i>offset</i> or <i>count</i> is negative.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.IO/types/IOException.html">IOException</a></td>
<td> An I/O error occurs.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> The stream does not support reading.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ObjectDisposedException.html">ObjectDisposedException</a></td>
<td> Methods were called after the stream was closed.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Use the  <a href="#CanRead">Stream.CanRead</a> property to determine whether the current instance supports reading.<p> The default implementation of <b>Read</b> calls the asynchronous  <a href="#BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">Stream.BeginRead</a> method.</p>
<p> Implementations of this method read a maximum of <i>count</i> bytes from the current stream and store them in <i>buffer</i> beginning at <i>offset</i>. The current position within the stream is advanced by the number of bytes read; however, if an exception occurs, the current position within the stream remains unchanged. Implementations return the number of bytes read. The return value is zero only if the position is currently at the end of the stream. The implementation will block until at least one byte of data can be read, in the event that no data is available.<b>Read</b> returns 0 only when there is no more data in the stream and no more is expected (such as a closed socket or end of file). An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</p>
<p> Use  <a href="../../System.IO/types/BinaryReader.html">BinaryReader</a> for reading primitive data types.</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following is an example of using the <b>Length</b> and <b>Position</b> properties.<pre>
if( s.Length==s.Position )
 {
 Console.WriteLine("End of file has been reached.");
 }

    </pre>
<p> The following example shows how to use <b>Read</b> in a blocking fashion.</p>
<pre>

 public class Block
 {
     public static void Main()
     {
         Stream s = new MemoryStream();
         for (int i=0; i&lt;100; i++)
           s.WriteByte((byte)i);
           s.Position = 0;
 
         // Now read in s into a byte buffer.
         byte[] bytes = new byte[1000];
         int numBytesToRead = (int) s.Length;
         int numBytesRead = 0;
         while (numBytesToRead &gt; 0) 
         {
             // Read may return anything from 0 to numBytesToRead.
             int n = s.Read(bytes, numBytesRead, numBytesToRead);
             if (n==0)  // We're at EOF
                 break;
             numBytesRead += n;
             numBytesToRead -= n;
         }
         s.Close();
         // numBytesToRead should be 0 now, and numBytesRead should
         // equal 100.
         Console.WriteLine("number of bytes read: "+numBytesRead);
     }
 }

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="ReadByteTopic1"></a><a name="ReadByte">ReadByte</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Reads a byte from the stream and advances the position within the stream by one byte, or returns -1 if at the end of the stream.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/Int32.html">int</a> ReadByte();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The unsigned byte cast to an <b>Int32</b>, or -1 if at the end of the stream.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.IO/types/IOException.html">IOException</a></td>
<td> The stream is closed.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> The stream does not support reading.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ObjectDisposedException.html">ObjectDisposedException</a></td>
<td> Methods were called after the stream was closed.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Use the  <a href="#CanRead">Stream.CanRead</a> property to determine whether the current instance supports reading.<p> Attempts to manipulate the stream after the stream has been closed could throw an  <a href="../../System/types/ObjectDisposedException.html">ObjectDisposedException</a>.</p><br><br><b>Notes to implementors: </b> The default implementation on <b>Stream</b> creates a new single-byte array and then calls  <a href="#Read(System.Byte[],System.Int32,System.Int32)">Stream.Read</a>. While this is formally correct, it is inefficient. Any stream with an internal buffer should override this method and provide a much more efficient version that reads the buffer directly, avoiding the extra array allocation on every call.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="SeekTopic1"></a><a name="Seek(System.Int64,System.IO.SeekOrigin)">Seek</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Int64.html">long</a> <i>offset</i>,</font><br>   <font color="#008080"><a href="../../System.IO/types/SeekOrigin.html">SeekOrigin</a> <i>origin</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, sets the position within the current stream.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract long Seek(long <a href="../../System/types/Int64.html">offset,</a> Seek(<br>   <font color="#008080"><a href="../../System/types/Int64.html">long</a> <i>offset</i>,</font><br>   <font color="#008080"><a href="../../System.IO/types/SeekOrigin.html">SeekOrigin</a> <i>origin</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>offset</i><br><dl>
<dd>
<param> A byte offset relative to origin. If <i>offset </i> is negative, the new position will precede the position specified by <i>origin </i> by the number of bytes specified by <i>offset</i>. If <i>offset </i> is zero, the new position will be the position specified by <i>origin</i>. If <i>offset </i> is positive, the new position will follow the position specified by <i>origin </i> by the number of bytes specified by <i>offset</i>.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>origin</i><br><dl>
<dd>
<param> A value of type  <a href="../../System.IO/types/SeekOrigin.html">SeekOrigin</a> indicating the reference point used to obtain the new position.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The new position within the current stream.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.IO/types/IOException.html">IOException</a></td>
<td> An I/O error occurs, such as the stream being closed.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> The stream does not support seeking, such as if the stream is constructed from a pipe or console output.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ObjectDisposedException.html">ObjectDisposedException</a></td>
<td> Methods were called after the stream was closed.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Use the  <a href="#CanSeek">Stream.CanSeek</a> property to determine whether the current instance supports seeking.<p> If <i>offset</i> is negative, the new position is required to precede the position specified by <i>origin</i> by the number of bytes specified by <i>offset</i>. If <i>offset</i> is zero (0), the new position is required to be the position specified by <i>origin</i>. If <i>offset</i> is positive, the new position is required to follow the position specified by <i>origin</i> by the number of bytes specified by <i>offset</i>.</p>
<p> If you intend to use a file as a backing store for a stream implementation, you must override <b>Seek</b> to set the  <a href="#Position">Stream.Position</a> property one byte beyond the end of the stream. Opening a new file and then writing to it requires that the position be set to one byte beyond the end of the stream. The position cannot be set to more than one byte beyond the end of the stream.</p>
<p> Classes derived from <b>Stream</b> that support seeking must override this method to provide the functionality described above.</p>
<p> Seeking to any location beyond the length of the stream is supported.</p>
</dd>
</dl><b>Example</b><dl>
<dd> This example shows a use of  <a href="../../System.IO/types/SeekOrigin.html">SeekOrigin</a> with  <a href="../../System.IO/types/StreamReader.html#BaseStream">StreamReader.BaseStream</a> and <b>Seek</b> to set the file pointer of the underlying stream to the beginning.<pre>
 FileStream fs = new FileStream("log.txt", FileMode.OpenOrCreate,
    FileAccess.Read);
 // Create a Char reader.
 StreamReader w = new StreamReader(fs);
 // Set the StreamReader file pointer to the end.
 w.BaseStream.Seek(0, SeekOrigin.End);

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="SetLengthTopic1"></a><a name="SetLength(System.Int64)">SetLength</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Int64.html">long</a> <i>value</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, sets the length of the current stream.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract void SetLength(<br>   <font color="#008080"><a href="../../System/types/Int64.html">long</a> <i>value</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>value</i><br><dl>
<dd>
<param> The desired length of the current stream in bytes.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.IO/types/IOException.html">IOException</a></td>
<td> An I/O error occurs, such as the file being closed.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> The stream does not support both writing and seeking, such as if the stream is constructed from a pipe or console output.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ObjectDisposedException.html">ObjectDisposedException</a></td>
<td> Methods were called after the stream was closed.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> If the specified value is less than the current length of the stream, the stream is truncated. If the specified value is larger than the current length of the stream, the stream is expanded. If the stream is expanded, the contents of the stream between the old and the new length are not defined.<p> A stream must support both writing and seeking for <b>SetLength</b> to work.</p>
<p> Use the  <a href="#CanWrite">Stream.CanWrite</a> property to determine whether the current instance supports writing, and the  <a href="#CanSeek">Stream.CanSeek</a> property to determine whether seeking is supported.</p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="ToStringTopic1"></a><a name="ToString">ToString</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#ToString">System.Object.ToString</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual string ToString();</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="WriteTopic1"></a><a name="Write(System.Byte[],System.Int32,System.Int32)">Write</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Byte.html">byte[]</a> <i>buffer</i>,</font><br>   <font color="#008080"><a href="../../System/types/Int32.html">int</a> <i>offset</i>,</font><br>   <font color="#008080"><a href="../../System/types/Int32.html">int</a> <i>count</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract void Write(<br>   <font color="#008080"><a href="../../System/types/Byte.html">byte[]</a> <i>buffer</i>,</font><br>   <font color="#008080"><a href="../../System/types/Int32.html">int</a> <i>offset</i>,</font><br>   <font color="#008080"><a href="../../System/types/Int32.html">int</a> <i>count</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>buffer</i><br><dl>
<dd>
<param> An array of bytes. This method copies <i>count </i> bytes from <i>buffer </i> to the current stream.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>offset</i><br><dl>
<dd>
<param> The zero-based byte offset in <i>buffer </i> at which to begin copying bytes to the current stream.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>count</i><br><dl>
<dd>
<param> The number of bytes to be written to the current stream.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td> The sum of <i>offset</i> and <i>count</i> is greater than the buffer length.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>buffer</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentOutOfRangeException.html">ArgumentOutOfRangeException</a></td>
<td><i>offset</i> or <i>count</i> is negative.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.IO/types/IOException.html">IOException</a></td>
<td> An I/O error occurs, such as the file being closed.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> The stream does not support writing, or the stream is already closed.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ObjectDisposedException.html">ObjectDisposedException</a></td>
<td> Methods were called after the stream was closed.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Use the  <a href="#CanWrite">Stream.CanWrite</a> property to determine whether the current instance supports writing.<p> If the write operation is successful, the position within the stream advances by the number of bytes written. If an exception occurs, the position within the stream remains unchanged.</p>
<p> The default implementation calls the asynchronous  <a href="#BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">Stream.BeginWrite</a> method.</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following example demonstrates how to use the <b>Write</b> method to copy an input stream to an output stream.<pre>
const int size = 4096;
byte[] bytes = new byte[4096];
int numBytes;
while((numBytes = input.Read(bytes, 0, size)) &gt; 0)
    output.Write(bytes, 0, numBytes);

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="WriteByteTopic1"></a><a name="WriteByte(System.Byte)">WriteByte</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Byte.html">byte</a> <i>value</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Writes a byte to the current position in the stream and advances the position within the stream by one byte.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual void WriteByte(<br>   <font color="#008080"><a href="../../System/types/Byte.html">byte</a> <i>value</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>value</i><br><dl>
<dd>
<param> The byte to write to the stream.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.IO/types/IOException.html">IOException</a></td>
<td> The stream is closed.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> The stream does not support writing, or the stream is already closed.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ObjectDisposedException.html">ObjectDisposedException</a></td>
<td> Methods were called after the stream was closed.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Use the  <a href="#CanWrite">Stream.CanWrite</a> property to determine whether the current instance supports writing.<br><br><b>Notes to implementors: </b> The default implementation on <b>Stream</b> creates a new single-byte array and then calls  <a href="#Write(System.Byte[],System.Int32,System.Int32)">Stream.Write</a>. While this is formally correct, it is inefficient. Any stream with an internal buffer should override this method and provide a much more efficient version that reads the buffer directly, avoiding the extra array allocation on every call.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite">
<h3 align="center"><a href="#TopOfPage">
					Top of page
				</a></h3><i><a href="../../documentation_license.txt">
				  Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
				</a></i></body>
</html>
