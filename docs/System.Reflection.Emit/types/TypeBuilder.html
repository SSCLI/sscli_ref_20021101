<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../refdoc.css">
<title>Type: System.Reflection.Emit.TypeBuilder</title>
</head>
<body><a name="TopOfPage"></a><h2>System.Reflection.Emit.TypeBuilder Class</h2><b>Assembly: </b>Mscorlib.dll<br><b>Namespace: </b>System.Reflection.Emit<br><dl>
<dt><b>Summary</b></dt>
<dd> Defines and creates new instances of classes during runtime.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
        public sealed class TypeBuilder : Type
      </b></code></td>
</tr>
</table>
</dd>
</dl><b>Thread Safety</b><br><dl>
<dd> Reflection Emit is thread-safe when using assemblies that were created with the  <a href="../../System/types/AppDomain.html#DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">AppDomain.DefineDynamicAssembly</a> method with the Boolean parameter <i>isSynchronized</i> set to <b>true</b>.</dd>
</dl><b>Remarks</b><dl>
<dd><b>TypeBuilder</b> is the root class used to control the creation of dynamic classes in the runtime.<b>TypeBuilder</b> provides a set of routines that are used to define classes, add methods and fields, and create the class inside the runtime. A new <b>TypeBuilder</b> can be created from a dynamic module.<p> To retrieve a parametrized unfinished type, use  <a href="../../System.Reflection.Emit/types/ModuleBuilder.html#GetType(System.String)">ModuleBuilder.GetType</a>. For example, given an unfinished type "mytype", use  <a href="../../System.Reflection.Emit/types/ModuleBuilder.html#GetType(System.String)">ModuleBuilder.GetType</a> to retrieve the type for "mytype[]". <a href="../../System.Reflection.Emit/types/ModuleBuilder.html#GetType(System.String)">ModuleBuilder.GetType</a> cannot be used to retrieve parametrized unfinished types.</p>
</dd>
</dl><b>See also: </b><dl>
<dd> <a href="../../System.Reflection.Emit/System.Reflection.Emit.html">System.Reflection.Emit Namespace</a></dd>
</dl>
<h3>System.Reflection.Emit.TypeBuilder Member List: </h3>
<dl>
<dt><b>Public Fields</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#UnspecifiedTypeSize">UnspecifiedTypeSize</a></td>
<td width="55%"> Represents that total size for the type is not specified.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Public Properties</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#Assembly">Assembly</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Retrieves the dynamic assembly that contains this type definition.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#AssemblyQualifiedName">AssemblyQualifiedName</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Returns the full name of this type qualified by the display name of the assembly.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Attributes">Attributes</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#Attributes">System.Type.Attributes</a></font></b><br><br><br> Gets the attributes associated with the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#BaseType">BaseType</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Retrieves the base type of this type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#DeclaringType">DeclaringType</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Returns the type that declared this type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#FullName">FullName</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Retrieves the full path of this type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GUID">GUID</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Retrieves the GUID of this type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#HasElementType">HasElementType</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#HasElementType">System.Type.HasElementType</a></font></b><br><br><br> Gets a value indicating whether the current  <a href="../../System/types/Type.html">Type</a> encompasses or refers to another type; that is, whether the current  <a href="../../System/types/Type.html">Type</a> is an array, a pointer, or is passed by reference.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsAbstract">IsAbstract</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsAbstract">System.Type.IsAbstract</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is abstract and must be overridden.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsAnsiClass">IsAnsiClass</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsAnsiClass">System.Type.IsAnsiClass</a></font></b><br><br><br> Gets a value indicating whether the string format attribute <b>AnsiClass</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsArray">IsArray</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsArray">System.Type.IsArray</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is an array.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsAutoClass">IsAutoClass</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsAutoClass">System.Type.IsAutoClass</a></font></b><br><br><br> Gets a value indicating whether the string format attribute <b>AutoClass</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsAutoLayout">IsAutoLayout</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsAutoLayout">System.Type.IsAutoLayout</a></font></b><br><br><br> Gets a value indicating whether the class layout attribute <b>AutoLayout</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsByRef">IsByRef</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsByRef">System.Type.IsByRef</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is passed by reference.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsClass">IsClass</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsClass">System.Type.IsClass</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is a class; that is, not a value type or interface.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsCOMObject">IsCOMObject</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsCOMObject">System.Type.IsCOMObject</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is a COM object.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsContextful">IsContextful</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsContextful">System.Type.IsContextful</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> can be hosted in a context.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsEnum">IsEnum</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsEnum">System.Type.IsEnum</a></font></b><br><br><br> Gets a value indicating whether the current  <a href="../../System/types/Type.html">Type</a> represents an enumeration.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsExplicitLayout">IsExplicitLayout</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsExplicitLayout">System.Type.IsExplicitLayout</a></font></b><br><br><br> Gets a value indicating whether the class layout attribute <b>ExplicitLayout</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsImport">IsImport</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsImport">System.Type.IsImport</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> was imported from another class.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsInterface">IsInterface</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsInterface">System.Type.IsInterface</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is an interface; that is, not a class or a value type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsLayoutSequential">IsLayoutSequential</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsLayoutSequential">System.Type.IsLayoutSequential</a></font></b><br><br><br> Gets a value indicating whether the class layout attribute <b>SequentialLayout</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsMarshalByRef">IsMarshalByRef</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsMarshalByRef">System.Type.IsMarshalByRef</a></font></b><br><br><br> Gets a value indicating whether the Type is marshaled by reference.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsNestedAssembly">IsNestedAssembly</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsNestedAssembly">System.Type.IsNestedAssembly</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is nested and visible only within its own assembly.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsNestedFamANDAssem">IsNestedFamANDAssem</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsNestedFamANDAssem">System.Type.IsNestedFamANDAssem</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is nested and visible only to classes that belong to both its own family and its own assembly.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsNestedFamily">IsNestedFamily</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsNestedFamily">System.Type.IsNestedFamily</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is nested and visible only within its own family.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsNestedFamORAssem">IsNestedFamORAssem</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsNestedFamORAssem">System.Type.IsNestedFamORAssem</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is nested and visible only to classes that belong to either its own family or to its own assembly.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsNestedPrivate">IsNestedPrivate</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsNestedPrivate">System.Type.IsNestedPrivate</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is nested and declared private.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsNestedPublic">IsNestedPublic</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsNestedPublic">System.Type.IsNestedPublic</a></font></b><br><br><br> Gets a value indicating whether a class is nested and declared public.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsNotPublic">IsNotPublic</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsNotPublic">System.Type.IsNotPublic</a></font></b><br><br><br> Gets a value indicating whether the top-level  <a href="../../System/types/Type.html">Type</a> is not declared public.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsPointer">IsPointer</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsPointer">System.Type.IsPointer</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is a pointer.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsPrimitive">IsPrimitive</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsPrimitive">System.Type.IsPrimitive</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is one of the primitive types.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsPublic">IsPublic</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsPublic">System.Type.IsPublic</a></font></b><br><br><br> Gets a value indicating whether the top-level  <a href="../../System/types/Type.html">Type</a> is declared public.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsSealed">IsSealed</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsSealed">System.Type.IsSealed</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is declared sealed.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsSerializable">IsSerializable</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsSerializable">System.Type.IsSerializable</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is serializable.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsSpecialName">IsSpecialName</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsSpecialName">System.Type.IsSpecialName</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> has a name that requires special handling.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsUnicodeClass">IsUnicodeClass</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsUnicodeClass">System.Type.IsUnicodeClass</a></font></b><br><br><br> Gets a value indicating whether the string format attribute <b>UnicodeClass</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsValueType">IsValueType</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsValueType">System.Type.IsValueType</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is a value type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#MemberType">MemberType</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#MemberType">System.Type.MemberType</a></font></b><br><br><br> Gets a bitmask indicating the member type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Module">Module</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Retrieves the dynamic module that contains this type definition.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Name">Name</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Retrieves the name of this type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Namespace">Namespace</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Retrieves the namespace where this <b>TypeBuilder</b> is defined.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#PackingSize">PackingSize</a></td>
<td width="55%"><b>Read-only</b><br><br> Retrieves the packing size of this type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ReflectedType">ReflectedType</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br></td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Size">Size</a></td>
<td width="55%"><b>Read-only</b><br><br> Retrieves the total size of a type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#TypeHandle">TypeHandle</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Not supported in dynamic modules.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#TypeInitializer">TypeInitializer</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#TypeInitializer">System.Type.TypeInitializer</a></font></b><br><br><br> Gets the initializer for the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#TypeToken">TypeToken</a></td>
<td width="55%"><b>Read-only</b><br><br> Returns the type token of this type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#UnderlyingSystemType">UnderlyingSystemType</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Returns the underlying system type for this <b>TypeBuilder</b>.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Public Methods</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">AddDeclarativeSecurity</a></td>
<td width="55%"> Adds declarative security to this type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#AddInterfaceImplementation(System.Type)">AddInterfaceImplementation</a></td>
<td width="55%"> Adds an interface that this type implements.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#CreateType">CreateType</a></td>
<td width="55%"> Creates a  <a href="../../System/types/Type.html">Type</a> object for the class. After defining fields and methods on the class, <b>CreateType</b> is called in order to load its <b>Type</b> object.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">DefineConstructor</a></td>
<td width="55%"> Adds a new constructor to the class, with the given attributes and signature.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#DefineDefaultConstructor(System.Reflection.MethodAttributes)">DefineDefaultConstructor</a></td>
<td width="55%"> Defines the default constructor. The constructor defined here will simply call the default constructor of the parent.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">DefineEvent</a></td>
<td width="55%"> Adds a new event to the class, with the given name, attributes and event type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">DefineField</a></td>
<td width="55%"> Adds a new field to the class, with the given name, attributes and field type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">DefineInitializedData</a></td>
<td width="55%"> Defines initialized data field in the .sdata section of the portable executable (PE) file.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">DefineMethod</a></td>
<td width="55%"><b>Overloaded:</b><br><code>DefineMethod(string name, MethodAttributes attributes, Type returnType, Type[] parameterTypes)<br><br></code> Adds a new method to the class, with the given name and method signature.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">DefineMethod</a></td>
<td width="55%"><b>Overloaded:</b><br><code>DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes)<br><br></code> Adds a new method to the class, with the given name and method signature.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">DefineMethodOverride</a></td>
<td width="55%"> Specifies a given method body that implements a given method declaration.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#DefineNestedType(System.String)">DefineNestedType</a></td>
<td width="55%"><b>Overloaded:</b><br><code>DefineNestedType(string name)<br><br></code> Defines a nested type given its name.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#DefineNestedType(System.String,System.Reflection.TypeAttributes)">DefineNestedType</a></td>
<td width="55%"><b>Overloaded:</b><br><code>DefineNestedType(string name, TypeAttributes attr)<br><br></code> Defines a nested type given its name and attributes.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">DefineNestedType</a></td>
<td width="55%"><b>Overloaded:</b><br><code>DefineNestedType(string name, TypeAttributes attr, Type parent)<br><br></code> Defines a nested type given its name, attributes, and the type that it extends.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">DefineNestedType</a></td>
<td width="55%"><b>Overloaded:</b><br><code>DefineNestedType(string name, TypeAttributes attr, Type parent, int typeSize)<br><br></code> Defines a nested type given its name, attributes, the total size of the type, and the type that it extends.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">DefineNestedType</a></td>
<td width="55%"><b>Overloaded:</b><br><code>DefineNestedType(string name, TypeAttributes attr, Type parent, PackingSize packSize)<br><br></code> Defines a nested type given its name, attributes, the total size of the type, and the type that it extends.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">DefineNestedType</a></td>
<td width="55%"><b>Overloaded:</b><br><code>DefineNestedType(string name, TypeAttributes attr, Type parent, Type[] interfaces)<br><br></code> Defines a nested type given its name, attributes, the type that it extends, and the interfaces that it implements.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">DefinePInvokeMethod</a></td>
<td width="55%"><b>Overloaded:</b><br><code>DefinePInvokeMethod(string name, string dllName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet)<br><br></code> Defines a <b>PInvoke</b> method given its name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <b>PInvoke</b> flags.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">DefinePInvokeMethod</a></td>
<td width="55%"><b>Overloaded:</b><br><code>DefinePInvokeMethod(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet)<br><br></code> Defines a <b>PInvoke</b> method given its name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <b>PInvoke</b> flags.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">DefineProperty</a></td>
<td width="55%"> Adds a new property to the class, with the given name and property signature.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#DefineTypeInitializer">DefineTypeInitializer</a></td>
<td width="55%"> Defines the initializer for this type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">DefineUninitializedData</a></td>
<td width="55%"> Defines uninitialized data field in the .sdata section of the portable executable (PE) file.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Equals(System.Object)">Equals</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>Equals(object o)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#Equals(System.Object)">System.Type.Equals</a></font></b><br><br><br> Determines if the underlying system type of the current  <a href="../../System/types/Type.html">Type</a> is the same as the underlying system type of the specified  <a href="../../System/types/Object.html">Object</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Equals(System.Type)">Equals</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>Equals(Type o)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#Equals(System.Type)">System.Type.Equals</a></font></b><br><br><br> Determines if the underlying system type of the current  <a href="../../System/types/Type.html">Type</a> is the same as the underlying system type of the specified  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#FindInterfaces(System.Reflection.TypeFilter,System.Object)">FindInterfaces</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#FindInterfaces(System.Reflection.TypeFilter,System.Object)">System.Type.FindInterfaces</a></font></b><br><br><br> Returns an array of  <a href="../../System/types/Type.html">Type</a> objects representing a filtered list of interfaces implemented or inherited by the current  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">FindMembers</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">System.Type.FindMembers</a></font></b><br><br><br> Returns a filtered array of  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> objects of the specified member type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetArrayRank">GetArrayRank</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetArrayRank">System.Type.GetArrayRank</a></font></b><br><br><br> Gets the number of dimensions in an  <a href="../../System/types/Array.html">Array</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetConstructor(System.Type[])">GetConstructor</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetConstructor(Type[] types)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetConstructor(System.Type[])">System.Type.GetConstructor</a></font></b><br><br><br> Searches for a public instance constructor whose parameters match the types in the specified array.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">GetConstructor</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">System.Type.GetConstructor</a></font></b><br><br><br> Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">GetConstructor</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetConstructor(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">System.Type.GetConstructor</a></font></b><br><br><br> Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetConstructors">GetConstructors</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetConstructors()<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetConstructors">System.Type.GetConstructors</a></font></b><br><br><br> Returns all the public constructors defined for the current  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetConstructors(System.Reflection.BindingFlags)">GetConstructors</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetConstructors(BindingFlags bindingAttr)<br><br></code><b>Overridden: </b><br> Returns an array of  <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> objects representing the public and non-public constructors defined for this class, as specified.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetCustomAttributes(System.Boolean)">GetCustomAttributes</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetCustomAttributes(bool inherit)<br><br></code><b>Overridden: </b><br> Returns all the custom attributes defined for this type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetCustomAttributes(System.Type,System.Boolean)">GetCustomAttributes</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetCustomAttributes(Type attributeType, bool inherit)<br><br></code><b>Overridden: </b><br> Checks if the specified custom attribute type is defined.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetDefaultMembers">GetDefaultMembers</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetDefaultMembers">System.Type.GetDefaultMembers</a></font></b><br><br><br> Searches for the members defined for the current  <a href="../../System/types/Type.html">Type</a> whose  <a href="../../System.Reflection/types/DefaultMemberAttribute.html">DefaultMemberAttribute</a> is set.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetElementType">GetElementType</a></td>
<td width="55%"><b>Overridden: </b><br> Calling this method always throws  <a href="../../System/types/NotSupportedException.html">NotSupportedException</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetEvent(System.String)">GetEvent</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetEvent(string name)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetEvent(System.String)">System.Type.GetEvent</a></font></b><br><br><br> Returns the  <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> object representing the specified event.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetEvent(System.String,System.Reflection.BindingFlags)">GetEvent</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetEvent(string name, BindingFlags bindingAttr)<br><br></code><b>Overridden: </b><br> Returns the event with the specified name.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetEvents">GetEvents</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetEvents()<br><br></code><b>Overridden: </b><br> Returns the events for the public events declared or inherited by this type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetEvents(System.Reflection.BindingFlags)">GetEvents</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetEvents(BindingFlags bindingAttr)<br><br></code><b>Overridden: </b><br> Returns the public and non-public events that are declared by this type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetField(System.String)">GetField</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetField(string name)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetField(System.String)">System.Type.GetField</a></font></b><br><br><br> Searches for the field with the specified name.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetField(System.String,System.Reflection.BindingFlags)">GetField</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetField(string name, BindingFlags bindingAttr)<br><br></code><b>Overridden: </b><br> Returns the field specified by the given name.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetFields">GetFields</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetFields()<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetFields">System.Type.GetFields</a></font></b><br><br><br> Returns all the public fields of the current  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetFields(System.Reflection.BindingFlags)">GetFields</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetFields(BindingFlags bindingAttr)<br><br></code><b>Overridden: </b><br> Returns the public and non-public fields that are declared by this type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetHashCode">GetHashCode</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetHashCode">System.Type.GetHashCode</a></font></b><br><br><br> Returns the hash code for this instance.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetInterface(System.String)">GetInterface</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetInterface(string name)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetInterface(System.String)">System.Type.GetInterface</a></font></b><br><br><br> Searches for the interface with the specified name.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetInterface(System.String,System.Boolean)">GetInterface</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetInterface(string name, bool ignoreCase)<br><br></code><b>Overridden: </b><br> Returns the interface implemented (directly or indirectly) by this class with the fully-qualified name matching the given interface name.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetInterfaceMap(System.Type)">GetInterfaceMap</a></td>
<td width="55%"><b>Overridden: </b><br> Returns an interface mapping for the requested interface.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetInterfaces">GetInterfaces</a></td>
<td width="55%"><b>Overridden: </b><br> Returns an array of all the interfaces implemented on this a class and its base classes.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMember(System.String)">GetMember</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMember(string name)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetMember(System.String)">System.Type.GetMember</a></font></b><br><br><br> Searches for the members with the specified name.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMember(System.String,System.Reflection.BindingFlags)">GetMember</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMember(string name, BindingFlags bindingAttr)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetMember(System.String,System.Reflection.BindingFlags)">System.Type.GetMember</a></font></b><br><br><br> Searches for the specified members, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">GetMember</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMember(string name, MemberTypes type, BindingFlags bindingAttr)<br><br></code><b>Overridden: </b><br> Returns all the public and non-public members declared or inherited by this type, as specified.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMembers">GetMembers</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMembers()<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetMembers">System.Type.GetMembers</a></font></b><br><br><br> Returns all the public members of the current  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMembers(System.Reflection.BindingFlags)">GetMembers</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMembers(BindingFlags bindingAttr)<br><br></code><b>Overridden: </b><br> Returns the members for the public and non-public members declared or inherited by this type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMethod(System.String)">GetMethod</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMethod(string name)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetMethod(System.String)">System.Type.GetMethod</a></font></b><br><br><br> Searches for the public method with the specified name.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMethod(System.String,System.Reflection.BindingFlags)">GetMethod</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMethod(string name, BindingFlags bindingAttr)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetMethod(System.String,System.Reflection.BindingFlags)">System.Type.GetMethod</a></font></b><br><br><br> Searches for the specified method, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMethod(System.String,System.Type[])">GetMethod</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMethod(string name, Type[] types)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetMethod(System.String,System.Type[])">System.Type.GetMethod</a></font></b><br><br><br> Searches for the specified public method whose parameters match the specified argument types.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">GetMethod</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMethod(string name, Type[] types, ParameterModifier[] modifiers)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">System.Type.GetMethod</a></font></b><br><br><br> Searches for the specified public method whose parameters match the specified argument types and modifiers.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">GetMethod</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">System.Type.GetMethod</a></font></b><br><br><br> Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">GetMethod</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">System.Type.GetMethod</a></font></b><br><br><br> Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMethods">GetMethods</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMethods()<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetMethods">System.Type.GetMethods</a></font></b><br><br><br> Returns all the public methods of the current  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMethods(System.Reflection.BindingFlags)">GetMethods</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMethods(BindingFlags bindingAttr)<br><br></code><b>Overridden: </b><br> Returns all the public and non-public methods declared or inherited by this type, as specified.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetNestedType(System.String)">GetNestedType</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetNestedType(string name)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetNestedType(System.String)">System.Type.GetNestedType</a></font></b><br><br><br> Searches for the nested type with the specified name.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetNestedType(System.String,System.Reflection.BindingFlags)">GetNestedType</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetNestedType(string name, BindingFlags bindingAttr)<br><br></code><b>Overridden: </b><br> Returns the public and non-public nested types that are declared by this type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetNestedTypes">GetNestedTypes</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetNestedTypes()<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetNestedTypes">System.Type.GetNestedTypes</a></font></b><br><br><br> Returns all the types nested within the current  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetNestedTypes(System.Reflection.BindingFlags)">GetNestedTypes</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetNestedTypes(BindingFlags bindingAttr)<br><br></code><b>Overridden: </b><br> Returns the public and non-public nested types that are declared or inherited by this type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetProperties">GetProperties</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetProperties()<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetProperties">System.Type.GetProperties</a></font></b><br><br><br> Returns all the public properties of the current  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetProperties(System.Reflection.BindingFlags)">GetProperties</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetProperties(BindingFlags bindingAttr)<br><br></code><b>Overridden: </b><br> Returns all the public and non-public properties declared or inherited by this type, as specified.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetProperty(System.String)">GetProperty</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetProperty(string name)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetProperty(System.String)">System.Type.GetProperty</a></font></b><br><br><br> Searches for the public property with the specified name.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetProperty(System.String,System.Reflection.BindingFlags)">GetProperty</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetProperty(string name, BindingFlags bindingAttr)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetProperty(System.String,System.Reflection.BindingFlags)">System.Type.GetProperty</a></font></b><br><br><br> Searches for the specified property, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetProperty(System.String,System.Type)">GetProperty</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetProperty(string name, Type returnType)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetProperty(System.String,System.Type)">System.Type.GetProperty</a></font></b><br><br><br> Searches for the public property with the specified name and return type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetProperty(System.String,System.Type[])">GetProperty</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetProperty(string name, Type[] types)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetProperty(System.String,System.Type[])">System.Type.GetProperty</a></font></b><br><br><br> Searches for the specified public property whose parameters match the specified argument types.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetProperty(System.String,System.Type,System.Type[])">GetProperty</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetProperty(string name, Type returnType, Type[] types)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetProperty(System.String,System.Type,System.Type[])">System.Type.GetProperty</a></font></b><br><br><br> Searches for the specified public property whose parameters match the specified argument types.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">GetProperty</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetProperty(string name, Type returnType, Type[] types, ParameterModifier[] modifiers)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">System.Type.GetProperty</a></font></b><br><br><br> Searches for the specified public property whose parameters match the specified argument types and modifiers.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">GetProperty</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">System.Type.GetProperty</a></font></b><br><br><br> Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetType">GetType</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#GetType">System.Object.GetType</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">InvokeMember</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">System.Type.InvokeMember</a></font></b><br><br><br> Invokes the specified member, using the specified binding constraints and matching the specified argument list.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">InvokeMember</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, CultureInfo culture)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">System.Type.InvokeMember</a></font></b><br><br><br> Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">InvokeMember</a></td>
<td width="55%"><b>Overloaded:</b><br><code>InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters)<br><br></code><b>Overridden: </b><br> Invokes the specified member. The method that is to be invoked must be accessible and provide the most specific match with the specified argument list, under the contraints of the specified binder and invocation attributes.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsAssignableFrom(System.Type)">IsAssignableFrom</a></td>
<td width="55%"><b>Overridden: </b><br> Determines whether an instance of the current  <a href="../../System/types/Type.html">Type</a> can be assigned from an instance of the specified <b>Type</b>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsDefined(System.Type,System.Boolean)">IsDefined</a></td>
<td width="55%"><b>Overridden: </b><br> Set a custom attribute using a custom attribute builder.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsInstanceOfType(System.Object)">IsInstanceOfType</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsInstanceOfType(System.Object)">System.Type.IsInstanceOfType</a></font></b><br><br><br> Determines whether the specified object is an instance of the current  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsSubclassOf(System.Type)">IsSubclassOf</a></td>
<td width="55%"><b>Overridden: </b><br> Checks if this type is a derived class of the given type <i>c</i>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">SetCustomAttribute</a></td>
<td width="55%"><b>Overloaded:</b><br><code>SetCustomAttribute(CustomAttributeBuilder customBuilder)<br><br></code> Set a custom attribute using a custom attribute builder.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">SetCustomAttribute</a></td>
<td width="55%"><b>Overloaded:</b><br><code>SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute)<br><br></code> Sets a custom attribute using a specified custom attribute blob.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#SetParent(System.Type)">SetParent</a></td>
<td width="55%"> Sets the parent of this <b>Type</b>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ToString">ToString</a></td>
<td width="55%"><b>Overridden: </b><br> Returns the name of the type excluding the namespace.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Protected Methods</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#Finalize">Finalize</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#Finalize">System.Object.Finalize</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetAttributeFlagsImpl">GetAttributeFlagsImpl</a></td>
<td width="55%"><b>Overridden: </b><br> Returns the implementation attribute flags.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">GetConstructorImpl</a></td>
<td width="55%"><b>Overridden: </b><br> Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">GetMethodImpl</a></td>
<td width="55%"><b>Overridden: </b><br> Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">GetPropertyImpl</a></td>
<td width="55%"><b>Overridden: </b><br> Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#HasElementTypeImpl">HasElementTypeImpl</a></td>
<td width="55%"><b>Overridden: </b><br> Calling this method always throws  <a href="../../System/types/NotSupportedException.html">NotSupportedException</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsArrayImpl">IsArrayImpl</a></td>
<td width="55%"><b>Overridden: </b><br> Always returns <b>false</b>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsByRefImpl">IsByRefImpl</a></td>
<td width="55%"><b>Overridden: </b><br> Always returns <b>false</b>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsCOMObjectImpl">IsCOMObjectImpl</a></td>
<td width="55%"><b>Overridden: </b><br> Checks if this type imports a COM type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsContextfulImpl">IsContextfulImpl</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsContextfulImpl">System.Type.IsContextfulImpl</a></font></b><br><br><br> Implements the  <a href="#IsContextful">Type.IsContextful</a> property and determines whether the  <a href="../../System/types/Type.html">Type</a> can be hosted in a context.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsMarshalByRefImpl">IsMarshalByRefImpl</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsMarshalByRefImpl">System.Type.IsMarshalByRefImpl</a></font></b><br><br><br> Implements the  <a href="#IsMarshalByRef">Type.IsMarshalByRef</a> property and determines whether the  <a href="../../System/types/Type.html">Type</a> is marshalled by reference.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsPointerImpl">IsPointerImpl</a></td>
<td width="55%"><b>Overridden: </b><br> Always returns <b>false</b>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsPrimitiveImpl">IsPrimitiveImpl</a></td>
<td width="55%"><b>Overridden: </b><br> Always returns <b>false</b>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsValueTypeImpl">IsValueTypeImpl</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsValueTypeImpl">System.Type.IsValueTypeImpl</a></font></b><br><br><br> Implements the  <a href="#IsValueType">Type.IsValueType</a> property and determines whether the  <a href="../../System/types/Type.html">Type</a> is a value type; that is, not a class or an interface.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#MemberwiseClone">MemberwiseClone</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#MemberwiseClone">System.Object.MemberwiseClone</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
</table>
</dd>
</dl>
<p><b>Hierarchy:</b><ul class="none">
<li><a href="../../System/types/Object.html">System.Object</a></li>
<ul class="none">
<li><a href="../../System.Reflection/types/MemberInfo.html">System.Reflection.MemberInfo</a></li>
<ul class="none">
<li><a href="../../System/types/Type.html">System.Type</a></li>
<ul class="none">
<li><b>System.Reflection.Emit.TypeBuilder</b></li>
</ul>
</ul>
</ul>
</ul>
</p>
<hr>
<h3>System.Reflection.Emit.TypeBuilder Member Details</h3><b>Field: <i><a name="UnspecifiedTypeSizeTopic1"></a><a name="UnspecifiedTypeSize">UnspecifiedTypeSize</a></i></b><b><i></i></b><dl>
<dt><b>Summary</b></dt>
<dd> Represents that total size for the type is not specified.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public const <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfmemberstopic.asp">int</a> UnspecifiedTypeSize;
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="AssemblyTopic1"></a><a name="Assembly">Assembly</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Retrieves the dynamic assembly that contains this type definition.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Reflection/types/Assembly.html">Assembly</a> Assembly {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="AssemblyQualifiedNameTopic1"></a><a name="AssemblyQualifiedName">AssemblyQualifiedName</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns the full name of this type qualified by the display name of the assembly.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/String.html">string</a> AssemblyQualifiedName {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The format of the returned string is: <p> &lt;FullTypeName&gt;, &lt;AssemblyDisplayName&gt; </p>
<p> See  <a href="../../System.Reflection/types/AssemblyName.html">AssemblyName</a> for a description of the format of the display name of an assembly.</p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="AttributesTopic1"></a><a name="Attributes">Attributes</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#Attributes">System.Type.Attributes</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the attributes associated with the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> Attributes {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd></dd>
</dl><b>See also: 
			</b><br> <a href="#GetAttributeFlagsImpl">Type.GetAttributeFlagsImpl</a> |  <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="BaseTypeTopic1"></a><a name="BaseType">BaseType</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Retrieves the base type of this type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Type.html">Type</a> BaseType {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="DeclaringTypeTopic1"></a><a name="DeclaringType">DeclaringType</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns the type that declared this type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Type.html">Type</a> DeclaringType {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="FullNameTopic1"></a><a name="FullName">FullName</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Retrieves the full path of this type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/String.html">string</a> FullName {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The returned format is "enclosingTypeFullName+nestedTypeName" for nested types and "typeName" for non-nested types.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="GUIDTopic1"></a><a name="GUID">GUID</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Retrieves the GUID of this type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Guid.html">Guid</a> GUID {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not currently supported for incomplete types.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="HasElementTypeTopic1"></a><a name="HasElementType">HasElementType</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#HasElementType">System.Type.HasElementType</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the current  <a href="../../System/types/Type.html">Type</a> encompasses or refers to another type; that is, whether the current  <a href="../../System/types/Type.html">Type</a> is an array, a pointer, or is passed by reference.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> HasElementType {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> For example, Type.GetType("Int32[]").HasElementType returns <b>true</b>, but Type.GetType("Int32").HasElementType returns <b>false</b>. HasElementType also returns <b>true</b> for "Int32*" and "Int32&amp;".</dd>
</dl><b>Example</b><dl>
<dd>
<pre>

public class MyClass 
{
}

public class Type_HasElementType
{
   public static void Main()
   {
      try
      {
         // An non array or pointer or reference element. 
         MyClass myObject1 = new MyClass();
         Object myObject2 = myObject1 ; 

         // An object of array type. 
         MyClass[] myObject3 = new MyClass[5];
         Object myObject4 = myObject3 ; 

         Object[] myObjects = new Object[] { myObject1, myObject2, myObject3, myObject4 };
         
         Console.WriteLine("\nCheck whether the object refers to array or pointer or reference type.\n");                     
         for(int i = 0; i &lt; myObjects.Length; i++)
         {
            if(myObjects[i].GetType().HasElementType)
               Console.WriteLine("'myObject{0}' refers to an array or pointer or reference", i);
            else
               Console.WriteLine("'myObject{0}' does not refer to an array or pointer or reference", i);
         }
      }
      catch( Exception e )
      {
         Console.WriteLine( "Exception: {0} \n", e.Message ) ; 
      }	
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#HasElementTypeImpl">Type.HasElementTypeImpl</a> |  <a href="#IsArray">Type.IsArray</a> |  <a href="#IsPointer">Type.IsPointer</a> |  <a href="#IsByRef">Type.IsByRef</a> |  <a href="#GetElementType">Type.GetElementType</a> |  <a href="#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsAbstractTopic1"></a><a name="IsAbstract">IsAbstract</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsAbstract">System.Type.IsAbstract</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is abstract and must be overridden.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsAbstract {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>

public abstract class MyAbstractClass 
{
}

public class MyClass
{
}

public class Type_IsAbstract
{
   public static void Main()
   {
      try
      {
         Console.WriteLine("\nChecking whether the type is abstract\n"); 

         // Check whether the return Type is abstract or not.
         Console.WriteLine("'MyAbstractClass' is {0}", 
            (typeof(MyAbstractClass).IsAbstract) ? 
            "an abstract class" :
            "not an abstract class" );

         // Check whether the return Type is abstract or not.
         Console.WriteLine("'MyClass' is {0}",
            (typeof(MyClass).IsAbstract) ?
            "an abstract class" : 
            "not an abstract class" );
			
      }
      catch( Exception e )
      {
         Console.WriteLine( "Exception: {0} \n", e.Message ); 
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsAnsiClassTopic1"></a><a name="IsAnsiClass">IsAnsiClass</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsAnsiClass">System.Type.IsAnsiClass</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the string format attribute <b>AnsiClass</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsAnsiClass {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#StringFormatMask">TypeAttributes.StringFormatMask</a> selects the string format attributes. The string format attributes enhance interoperability by defining how strings should be interpreted.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
public class MyClass
{
   protected string myField = "A sample protected field" ;
}

public class MyType_IsAnsiClass
{
   public static void Main()
   {
      try
      {
         MyClass myObject = new MyClass();
       
         // Get the type of the 'MyClass'.
         Type myType = typeof(MyClass);

         // Get the field information and the attributes associated with 'MyClass'.
         FieldInfo myFieldInfo = myType.GetField("myField",
            BindingFlags.NonPublic|BindingFlags.Instance);
    
         Console.WriteLine( "\nChecking for AnsiClass attribute for a field\n"); 
         // Get and display the name, field, and the AnsiClass attribute.
         Console.WriteLine("Name of Class: {0} \nValue of Field: {1} \nIsAnsiClass = {2}",
            myType.FullName, myFieldInfo.GetValue(myObject),
            myType.IsAnsiClass);
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception : {0}",e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsUnicodeClass">Type.IsUnicodeClass</a> |  <a href="#IsAutoClass">Type.IsAutoClass</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsArrayTopic1"></a><a name="IsArray">IsArray</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsArray">System.Type.IsArray</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is an array.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsArray {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System/types/Array.html">Array</a> class returns <b>false</b> because it is not an array.<p> This property is read-only.</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following example demonstrates using the <b>IsArray</b> property.<pre>
using System;
class TestIsArray 
{
   public static void Main() 
   {
   int [] array = {1,2,3,4};
   Type at = typeof(Array);
   Type t = array.GetType();
   Console.WriteLine("Type is {0}. IsArray? {1}", at, at.IsArray);
   Console.WriteLine("Type is {0}. IsArray? {1}", t, t.IsArray);
   }
}

    </pre>
<p> This code produces the following output: </p>
<pre>
              				Type is System.Array. IsArray? False
              				Type is System.Int32[]. IsArray? True
              			
            </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#IsArrayImpl">Type.IsArrayImpl</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsAutoClassTopic1"></a><a name="IsAutoClass">IsAutoClass</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsAutoClass">System.Type.IsAutoClass</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the string format attribute <b>AutoClass</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsAutoClass {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#StringFormatMask">TypeAttributes.StringFormatMask</a> selects the string format attributes. The string format attributes enhance interoperability by defining how strings should be interpreted.</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsAnsiClass">Type.IsAnsiClass</a> |  <a href="#IsUnicodeClass">Type.IsUnicodeClass</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsAutoLayoutTopic1"></a><a name="IsAutoLayout">IsAutoLayout</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsAutoLayout">System.Type.IsAutoLayout</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the class layout attribute <b>AutoLayout</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsAutoLayout {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#LayoutMask">TypeAttributes.LayoutMask</a> is used to select the class layout attributes. The class layout attributes (<b>AutoLayout</b><i>,</i><b>SequentialLayout</b> and <b>ExplicitLayout</b>) define how the fields of the class instance are laid out in memory.<p> Use the <b>AutoLayout</b> attribute to let the runtime engine decide the best way to layout the objects of the class. Classes marked with the <b>AutoLayout</b> attribute indicate that the loader will choose the appropriate way to lay out the class; any layout information that may have been specified is ignored.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
// The MyDemoAttribute class is selected as AutoLayout.
[StructLayoutAttribute(LayoutKind.Auto)]
public class MyDemoAttribute
{
}

public class MyTypeClass
{
   public static void Main(string[] args)
   { 
      MyAutoLayoutMethod("MyDemoAttribute");    
   }

    public static void MyAutoLayoutMethod(string typeName)
   {
      try
      {
         // Create an object of 'Type' class using the 'GetType' method.
         Type  myType=Type.GetType(typeName);
         // Get and display the 'IsAutoLayout' property of the 
         // 'MyDemoAttribute' instance.
         Console.WriteLine("\n The 'Autolayout' property for the 'MyDemoAttribute' is: {0}.",myType.IsAutoLayout); 
      }
      catch(Exception e)
      {
         Console.WriteLine("\nThe following exception is raised: {0}." ,e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsLayoutSequential">Type.IsLayoutSequential</a> |  <a href="#IsExplicitLayout">Type.IsExplicitLayout</a> | <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconmetadataoverview.asp">MSDN: metadataoverview</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsByRefTopic1"></a><a name="IsByRef">IsByRef</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsByRef">System.Type.IsByRef</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is passed by reference.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsByRef {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>See also: 
			</b><br> <a href="#IsByRefImpl">Type.IsByRefImpl</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsClassTopic1"></a><a name="IsClass">IsClass</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsClass">System.Type.IsClass</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is a class; that is, not a value type or interface.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsClass {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This property returns <b>true</b> for <b>Type</b> instances representing  <a href="../../System/types/Enum.html">Enum</a> and  <a href="../../System/types/ValueType.html">ValueType</a>.<p> The  <a href="../../System.Reflection/types/TypeAttributes.html#ClassSemanticsMask">TypeAttributes.ClassSemanticsMask</a> distinguishes a type declaration as class, interface, or value type.</p>
<p> This property is read-only.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
public  class MyDemoClass
{
   
}

public class MyTypeClass
{
   public static void Main(string[] args)
   {
      try
      {
         Type  myType=Type.GetType("MyDemoClass");
         // Get and display the 'IsClass' property of the 'MyDemoClass' instance.
         Console.WriteLine("\n'MyDemoClass' is of type 'Class': {0}.", myType.IsClass); 
      }
      catch(Exception e)
      {
         Console.WriteLine("\nThe following exception is raised: {0}." ,e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsInterface">Type.IsInterface</a> |  <a href="#IsValueType">Type.IsValueType</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsCOMObjectTopic1"></a><a name="IsCOMObject">IsCOMObject</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsCOMObject">System.Type.IsCOMObject</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is a COM object.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsCOMObject {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This method returns <b>false</b> for COM interfaces because they are not objects. COM interfaces can be implemented by Microsoft .NET Framework objects.<p> You can also load a COM class and get a <b>Type</b> object for that COM class by using the  tool.</p>
</dd>
</dl><b>See also: 
			</b><br> <a href="#IsCOMObjectImpl">Type.IsCOMObjectImpl</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsContextfulTopic1"></a><a name="IsContextful">IsContextful</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsContextful">System.Type.IsContextful</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> can be hosted in a context.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsContextful {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> A context intercepts calls to the class members and enforces policies that are applied to the class, such as synchronization. For more detailed information on remoting contexts, see  <a href="../../System.Runtime.Remoting.Contexts/types/Context.html">Context</a>.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>

public class MyContextBoundClass: ContextBoundObject
{
   public string myString = "This class demonstrates the isContextful and isMarshalByRef properties.";
}

public class MyTypeDemoClass
{
   public static void Main()
   {
      try
      {
         // Check if the types can be hosted in a Context.
         Console.WriteLine ("The Contextful property for the '{0}' type is: {1}", typeof(MyTypeDemoClass).Name, typeof(MyTypeDemoClass).IsContextful);
         Console.WriteLine ("The Contextful property for the '{0}' type is: {1}", typeof(MyContextBoundClass).Name, typeof(MyContextBoundClass).IsContextful);

         // Check if the types are marshalled by reference.
         Console.WriteLine ("The MarshalByRef property of '{0}' is: {1} ", typeof(MyTypeDemoClass).Name, typeof(MyTypeDemoClass).IsMarshalByRef);
         Console.WriteLine ("The MarshalByRef property of '{0}' is: {1} ", typeof(MyContextBoundClass).Name, typeof(MyContextBoundClass).IsMarshalByRef);
         // Check if the types are primitive datatypes.
         Console.WriteLine ("'{0}' is a primitive datatype : {1} ", typeof(int).Name, typeof(int).IsPrimitive);
         Console.WriteLine ("'{0}' is a primitive datatype : {1} ", typeof(string).Name, typeof(string).IsPrimitive);
      } 
      catch (Exception e)
      {
         Console.WriteLine("The following exception is raised : " + e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#IsContextfulImpl">Type.IsContextfulImpl</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsEnumTopic1"></a><a name="IsEnum">IsEnum</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsEnum">System.Type.IsEnum</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the current  <a href="../../System/types/Type.html">Type</a> represents an enumeration.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsEnum {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This property returns <b>true</b> for an enumeration, but not for the  <a href="../../System/types/Enum.html">Enum</a> type itself, which is a class.<p> This property is read-only.</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following example demonstrates using the <b>IsEnum</b> property.<pre>
using System;
public enum Color 
{
Red, Blue, Green
}
class TestIsEnum 
{
   public static void Main() 
   {
   Type colorType = typeof(Color);
   Type enumType = typeof(Enum);
   Console.WriteLine("Color is enum? {0}", colorType.IsEnum);
   Console.WriteLine("Color is valueType? {0}", colorType.IsValueType);
   Console.WriteLine("Enum is enum Type? {0}", enumType.IsEnum);
   Console.WriteLine("Enum is value? {0}", enumType.IsValueType);
   }
}

    </pre>
<p> This code produces the following output: </p>
<pre>
              				Color is enum? True
              				Color is valueType? True
              				Enum is enum Type? False
              				Enum is value? False
              			
            </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsExplicitLayoutTopic1"></a><a name="IsExplicitLayout">IsExplicitLayout</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsExplicitLayout">System.Type.IsExplicitLayout</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the class layout attribute <b>ExplicitLayout</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsExplicitLayout {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#LayoutMask">TypeAttributes.LayoutMask</a> is used to select the class layout attributes. The class layout attributes (<b>AutoLayout</b><i>,</i><b>SequentialLayout</b> and <b>ExplicitLayout</b>) define how the fields of the class instance are laid out in memory.<p> Classes marked with the <b>ExplicitLayout</b> attribute cause the loader to ignore field sequence and to use the explicit layout rules provided, in the form of field offsets, overall class size and alignment, or all of these.</p>
<p> Use the <b>ExplicitLayout</b> attribute to specify the offsets at which each field starts, or to specify the overall size and, optionally, the packing size of the objects of the class. The packing size is the empty memory space between fields and must be 1, 2, 4, 8 or 16 bytes.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
//The class is selected for the ExplicitLayout.
[StructLayoutAttribute(LayoutKind.Explicit)]
public class MyDemoAttribute
{
}

public class MyTypeClass
{
   public static void Main(string[] args)
   {
      MyIsExplicitLayoutMethod("MyDemoAttribute");     
   }
   public static void MyIsExplicitLayoutMethod(string typeName)
   {
     try
      {
         // Create an object of 'Type' class using the 'GetType' method.
         Type  myType=Type.GetType(typeName);
         // Get and display the 'IsExplicitLayout' property.
         Console.WriteLine("\n'MyDemoAttribute' instance's 'IsExplicitLayout' property is: {0}.",myType.IsExplicitLayout); 
      }
      catch(Exception e)
      {
         Console.WriteLine("\nThe following exception is raised: {0}." ,e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsAutoLayout">Type.IsAutoLayout</a> |  <a href="#IsLayoutSequential">Type.IsLayoutSequential</a> | <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconmetadataoverview.asp">MSDN: metadataoverview</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsImportTopic1"></a><a name="IsImport">IsImport</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsImport">System.Type.IsImport</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> was imported from another class.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsImport {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsInterfaceTopic1"></a><a name="IsInterface">IsInterface</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsInterface">System.Type.IsInterface</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is an interface; that is, not a class or a value type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsInterface {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#ClassSemanticsMask">TypeAttributes.ClassSemanticsMask</a> distinguishes a type declaration as class, interface or value type.<p> This property is read-only.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
// Interface declaration.
interface myIFace
{

}

class MyIsInterface 
{
   public static void Main(string []args)
   {
      try
      {
         // Get the attribute IsInterface for myIFace.
         bool myBool1 = typeof(myIFace).IsInterface;    
         //Display the IsInterface attribute for myIFace.
         Console.WriteLine("The type mentioned is an interface: {0}",myBool1);
         // Get the attribute IsInterface for MyIsInterface.
         bool myBool2 = typeof(MyIsInterface).IsInterface;    
         //Display the IsInterface attribute for MyIsInterface.
         Console.WriteLine("The type mentioned is an interface: {0}",myBool2);         
      }
      catch(Exception e)
      {
         Console.WriteLine("\nThe following exception is raised : {0}",e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsClass">Type.IsClass</a> |  <a href="#IsValueType">Type.IsValueType</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsLayoutSequentialTopic1"></a><a name="IsLayoutSequential">IsLayoutSequential</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsLayoutSequential">System.Type.IsLayoutSequential</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the class layout attribute <b>SequentialLayout</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsLayoutSequential {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#LayoutMask">TypeAttributes.LayoutMask</a> is used to select the class layout attributes. The class layout attributes (<b>AutoLayout</b><i>,</i><b>SequentialLayout</b> and <b>ExplicitLayout</b>) define how the fields of the class instance are laid out in memory.<p> Classes marked with the <b>SequentialLayout</b> attribute guides the loader to preserve field order as emitted, but otherwise the specific offsets are calculated based on the common language runtime type of the field; these may be shifted by explicit offset, padding, or alignment information.</p>
<p> Use the <b>SequentialLayout</b> attribute to layout the objects of the class sequentially and to specify the packing size between adjacent fields. The packing size is the empty memory space between fields and must be 1, 2, 4, 8 or 16 bytes. A field will be aligned to its natural size or to the packing size, whichever results in a smaller offset.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
// MyTypeSequential1 class declaration.
class MyTypeSequential1
{
}

[StructLayoutAttribute(LayoutKind.Sequential)]
class MyTypeSequential2
{
   public static void Main(string []args)
   {
      try
      {
         // Create an instance of 'myTypeSeq1' class.
         MyTypeSequential1 myObj1 = new MyTypeSequential1();
         Type myTypeObj1 = myObj1.GetType();
         // Check and displays the attribute 'SequentialLayout'.
         Console.WriteLine("\nThe object myObj1 has 'IsLayoutSequential': {0}", myObj1.GetType().IsLayoutSequential);
         // Create an instance of 'myTypeSeq2' class.
         MyTypeSequential2 myObj2 = new MyTypeSequential2();
         Type myTypeObj2 = myObj2.GetType();
         // Check and displays the attribute 'SequentialLayout'.
         Console.WriteLine("\nThe object myObj2 has 'IsLayoutSequential': {0}", myObj2.GetType().IsLayoutSequential);
      }
      catch(Exception e)
      {
         Console.WriteLine("\nThe following exception is raised: {0}",e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsAutoLayout">Type.IsAutoLayout</a> |  <a href="#IsExplicitLayout">Type.IsExplicitLayout</a> | <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconmetadataoverview.asp">MSDN: metadataoverview</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsMarshalByRefTopic1"></a><a name="IsMarshalByRef">IsMarshalByRef</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsMarshalByRef">System.Type.IsMarshalByRef</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the Type is marshaled by reference.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsMarshalByRef {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>

public class MyContextBoundClass: ContextBoundObject
{
   public string myString = "This class demonstrates the isContextful and isMarshalByRef properties.";
}

public class MyTypeDemoClass
{
   public static void Main()
   {
      try
      {
         // Check if the types can be hosted in a Context.
         Console.WriteLine ("The Contextful property for the '{0}' type is: {1}", typeof(MyTypeDemoClass).Name, typeof(MyTypeDemoClass).IsContextful);
         Console.WriteLine ("The Contextful property for the '{0}' type is: {1}", typeof(MyContextBoundClass).Name, typeof(MyContextBoundClass).IsContextful);

         // Check if the types are marshalled by reference.
         Console.WriteLine ("The MarshalByRef property of '{0}' is: {1} ", typeof(MyTypeDemoClass).Name, typeof(MyTypeDemoClass).IsMarshalByRef);
         Console.WriteLine ("The MarshalByRef property of '{0}' is: {1} ", typeof(MyContextBoundClass).Name, typeof(MyContextBoundClass).IsMarshalByRef);
         // Check if the types are primitive datatypes.
         Console.WriteLine ("'{0}' is a primitive datatype : {1} ", typeof(int).Name, typeof(int).IsPrimitive);
         Console.WriteLine ("'{0}' is a primitive datatype : {1} ", typeof(string).Name, typeof(string).IsPrimitive);
      } 
      catch (Exception e)
      {
         Console.WriteLine("The following exception is raised : " + e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#IsMarshalByRefImpl">Type.IsMarshalByRefImpl</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsNestedAssemblyTopic1"></a><a name="IsNestedAssembly">IsNestedAssembly</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsNestedAssembly">System.Type.IsNestedAssembly</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is nested and visible only within its own assembly.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsNestedAssembly {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#VisibilityMask">TypeAttributes.VisibilityMask</a> selects the visibility attributes.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
// Enclose a class.
class MyClassA
{
   // Internal nested class.
   internal class MyClassB
   {
   }
}
class MyTestClass
{
   public static void Main(string[] args)
   {  
      // Get the Type of the nested class.
      Type myTypeB = typeof(MyClassA.MyClassB);
      // Get the 'IsNestedAssembly' property  of the nested class
      // 'Type'.
      Console.WriteLine("\nThe nested class has the property 'IsNestedAssembly' value: "+ 
                         myTypeB.IsNestedAssembly.ToString());
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsNestedFamANDAssemTopic1"></a><a name="IsNestedFamANDAssem">IsNestedFamANDAssem</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsNestedFamANDAssem">System.Type.IsNestedFamANDAssem</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is nested and visible only to classes that belong to both its own family and its own assembly.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsNestedFamANDAssem {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#VisibilityMask">TypeAttributes.VisibilityMask</a> selects the visibility attributes.<p> A  <a href="../../System/types/Type.html">Type</a> object's family is defined as all objects of the exact same  <a href="../../System/types/Type.html">Type</a> and of its subtypes.</p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsNestedFamilyTopic1"></a><a name="IsNestedFamily">IsNestedFamily</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsNestedFamily">System.Type.IsNestedFamily</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is nested and visible only within its own family.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsNestedFamily {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#VisibilityMask">TypeAttributes.VisibilityMask</a> selects the visibility attributes.<p> A  <a href="../../System/types/Type.html">Type</a> object's family is defined as all objects of the exact same  <a href="../../System/types/Type.html">Type</a> and of its subtypes.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
// Enclose a class.
class MyClassA
{
   // Protected nested class.
   protected class MyClassB
   {
   }   
}
class MyTestClass : MyClassA
{
   public static void Main(string[] args)
   {  
      // Get the Type of the nested class.
      Type myTypeB = typeof(MyClassA.MyClassB);
      // Get the 'IsNestedFamily' property the of the nested class
      // 'Type'.
      Console.WriteLine("\nThe nested class has the property 'IsNestedFamily' value: "+
                        myTypeB.IsNestedFamily.ToString());      
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsNestedFamORAssemTopic1"></a><a name="IsNestedFamORAssem">IsNestedFamORAssem</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsNestedFamORAssem">System.Type.IsNestedFamORAssem</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is nested and visible only to classes that belong to either its own family or to its own assembly.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsNestedFamORAssem {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#VisibilityMask">TypeAttributes.VisibilityMask</a> selects the visibility attributes.<p> A  <a href="../../System/types/Type.html">Type</a> object's family is defined as all objects of the exact same  <a href="../../System/types/Type.html">Type</a> and of its subtypes.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
// Enclose a class.
class MyClassA
{
   // Protected internal nested class.
   protected internal class MyClassB
   {
   }
}
class MyTestClass 
{
   public static void Main(string[] args)
   {        
      // Get the Type of the nested class.
      Type myTypeB = typeof(MyClassA.MyClassB);
      // Get the 'IsNestedFamORAssem' property of the nested class 
      // 'Type'.
      Console.WriteLine("\nThe nested class has the property 'IsNestedFamORAssem' value: "+
                        myTypeB.IsNestedFamORAssem.ToString()); 
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsNestedPrivateTopic1"></a><a name="IsNestedPrivate">IsNestedPrivate</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsNestedPrivate">System.Type.IsNestedPrivate</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is nested and declared private.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsNestedPrivate {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#VisibilityMask">TypeAttributes.VisibilityMask</a> selects the visibility attributes.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
// Outer class.
public class MyClassA
{
   // Private nested class.
   private class MyClassB
   {
   }
   public static void Main(string[] args)
   {	
      // Get the Type of the nested class.
      Type myTypeB = typeof(MyClassA.MyClassB);
      // Get the 'IsNestedPrivate' property of the nested class 'Type'.
      Console.WriteLine("\nThe nested class has the property 'IsNestedPrivate'value: "+
                        myTypeB.IsNestedPrivate.ToString());	
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsNestedPublicTopic1"></a><a name="IsNestedPublic">IsNestedPublic</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsNestedPublic">System.Type.IsNestedPublic</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether a class is nested and declared public.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsNestedPublic {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#VisibilityMask">TypeAttributes.VisibilityMask</a> selects the visibility attributes.</dd>
</dl><b>Example</b><dl>
<dd> The following example demonstrates the <b>IsNestedPublic</b> property. A nested class MyClassB is declared as public and the <b>IsNestedPublic</b> property value is displayed.<pre>

using System;

// Enclose a class.
public class MyClassA
{
   // Public nested class.
   public class MyClassB
   {
   }
   public static void Main(string[] args)
   {	
      // Get the Type of the nested class.
      Type myTypeB = typeof(MyClassA.MyClassB);
      // Get the 'IsNestedPublic' property of the nested class
      // 'Type'.
      Console.WriteLine("\nThe nested class has the property 'IsNestedPublic' value: "+
                        myTypeB.IsNestedPublic.ToString());			
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsNotPublicTopic1"></a><a name="IsNotPublic">IsNotPublic</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsNotPublic">System.Type.IsNotPublic</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the top-level  <a href="../../System/types/Type.html">Type</a> is not declared public.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsNotPublic {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd><b>IsPublic</b> and <b>IsNotPublic</b> get the visibility of the top-level type only.<p> <a href="../../System.Reflection/types/TypeAttributes.html#VisibilityMask">TypeAttributes.VisibilityMask</a> selects the visibility attributes.</p>
</dd>
</dl><b>Example</b><dl>
<dd> This example shows the use of <b>IsNotPublic</b> to get the visibility of the top-level type.<pre>
 using System;
 using System.IO;
 using System.Reflection;
 
 class MyMemberInfo { 
 
   public static void Main(string[] args) { 
 
    Console.WriteLine ("\nReflection.MemberInfo");
 
    //Get the Type and MemberInfo 
 
    Type MyType =Type.GetType("System.IO.File");
 
    MemberInfo[] Mymemberinfoarray = MyType.GetMembers();
 
    //Get and display the DeclaringType method
 
    Console.WriteLine("\nThere are {0} members in {1}.",
       Mymemberinfoarray.Length, MyType.FullName);
 
    Console.WriteLine("Is {0} public? {1}", MyType.FullName,
       MyType.IsPublic.ToString());
   }
 }

    </pre>
<p> This code produces the following output: </p>
<p> There are 27 members in System.IO.File.</p>
<p> Is System.IO.File public? False </p>
<p> The following code example demonstrates why you cannot use <b>IsPublic</b> and <b>IsNotPublic</b> for nested classes.</p>
<pre>
public class A {
   public class B { }
   private class C { }
}

    </pre>
<p> For nested classes, ignore the results of <b>IsPublic</b> and <b>IsNotPublic</b> and pay attention only to the results of <b>IsNestedPublic</b> and <b>IsNestedPrivate</b>. The reflection output for this code fragment would be as follows: </p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Class
                </TH>
<TH>
                  IsNotPublic
                </TH>
<TH>
                  IsPublic
                </TH>
<TH>
                  IsNestedPublic
                </TH>
<TH>
                  IsNestedPrivate
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  A
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  TRUE
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  FALSE
                </TD>
</TR>
<TR valign="top">
<TD>
                  B
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  TRUE
                </TD>
<TD>
                  FALSE
                </TD>
</TR>
<TR valign="top">
<TD>
                  C
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  TRUE
                </TD>
</TR>
</table>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsPointerTopic1"></a><a name="IsPointer">IsPointer</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsPointer">System.Type.IsPointer</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is a pointer.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsPointer {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This property is read-only.</dd>
</dl><b>See also: 
			</b><br> <a href="#IsPointerImpl">Type.IsPointerImpl</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsPrimitiveTopic1"></a><a name="IsPrimitive">IsPrimitive</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsPrimitive">System.Type.IsPrimitive</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is one of the primitive types.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsPrimitive {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The primitive types are  <a href="../../System/types/Boolean.html">Boolean</a>,  <a href="../../System/types/Byte.html">Byte</a>,  <a href="../../System/types/SByte.html">SByte</a>,  <a href="../../System/types/Int16.html">Int16</a>,  <a href="../../System/types/UInt16.html">UInt16</a>,  <a href="../../System/types/Int32.html">Int32</a>,  <a href="../../System/types/UInt32.html">UInt32</a>,  <a href="../../System/types/Int64.html">Int64</a>,  <a href="../../System/types/UInt64.html">UInt64</a>,  <a href="../../System/types/Char.html">Char</a>,  <a href="../../System/types/Double.html">Double</a>, and  <a href="../../System/types/Single.html">Single</a>.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
         // Check if the types are primitive datatypes.
         Console.WriteLine ("'{0}' is a primitive datatype : {1} ", typeof(int).Name, typeof(int).IsPrimitive);
         Console.WriteLine ("'{0}' is a primitive datatype : {1} ", typeof(string).Name, typeof(string).IsPrimitive);

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/Boolean.html">Boolean</a> |  <a href="../../System/types/Byte.html">Byte</a> |  <a href="../../System/types/SByte.html">SByte</a> |  <a href="../../System/types/Int16.html">Int16</a> |  <a href="../../System/types/UInt16.html">UInt16</a> |  <a href="../../System/types/Int32.html">Int32</a> |  <a href="../../System/types/UInt32.html">UInt32</a> |  <a href="../../System/types/Int64.html">Int64</a> |  <a href="../../System/types/UInt64.html">UInt64</a> |  <a href="../../System/types/Char.html">Char</a> |  <a href="../../System/types/Double.html">Double</a> |  <a href="../../System/types/Single.html">Single</a> |  <a href="#IsPrimitiveImpl">Type.IsPrimitiveImpl</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsPublicTopic1"></a><a name="IsPublic">IsPublic</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsPublic">System.Type.IsPublic</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the top-level  <a href="../../System/types/Type.html">Type</a> is declared public.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsPublic {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd><b>IsPublic</b> and <b>IsNotPublic</b> get the visibility of the top-level type only.<p> <a href="../../System.Reflection/types/TypeAttributes.html#VisibilityMask">TypeAttributes.VisibilityMask</a> selects the visibility attributes.</p>
</dd>
</dl><b>Example</b><dl>
<dd> This example shows the use of <b>IsPublic</b> to get the visibility of the top-level type.<pre>
 using System;
 using System.IO;
 using System.Reflection;
 
 class MyMemberInfo { 
 
   public static void Main(string[] args) { 
 
    Console.WriteLine ("\nReflection.MemberInfo");
 
    //Get the Type and MemberInfo 
 
    Type MyType =Type.GetType("System.IO.File");
 
    MemberInfo[] Mymemberinfoarray = MyType.GetMembers();
 
    //Get and display the DeclaringType method
 
    Console.WriteLine("\nThere are {0} members in {1}.",
       Mymemberinfoarray.Length, MyType.FullName);
 
    Console.WriteLine("Is {0} public? {1}", MyType.FullName,
       MyType.IsPublic.ToString());
   }
 }

    </pre>
<p> This code produces the following output: </p>
<p> There are 27 members in System.IO.File.</p>
<p> Is System.IO.File public? True </p>
<p> The following code example demonstrates why you cannot use <b>IsPublic</b> and <b>IsNotPublic</b> for nested classes.</p>
<pre>
public class A {
   public class B { }
   private class C { }
}

    </pre>
<p> For nested classes, ignore the results of <b>IsPublic</b> and <b>IsNotPublic</b> and pay attention only to the results of <b>IsNestedPublic</b> and <b>IsNestedPrivate</b>. The reflection output for this code fragment would be as follows: </p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Class
                </TH>
<TH>
                  IsNotPublic
                </TH>
<TH>
                  IsPublic
                </TH>
<TH>
                  IsNestedPublic
                </TH>
<TH>
                  IsNestedPrivate
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  A
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  TRUE
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  FALSE
                </TD>
</TR>
<TR valign="top">
<TD>
                  B
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  TRUE
                </TD>
<TD>
                  FALSE
                </TD>
</TR>
<TR valign="top">
<TD>
                  C
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  TRUE
                </TD>
</TR>
</table>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsSealedTopic1"></a><a name="IsSealed">IsSealed</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsSealed">System.Type.IsSealed</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is declared sealed.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsSealed {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
      // Declare class 'MyTestClass' as sealed.
      sealed public class MyTestClass
      {
      }
      public static void Main(string []args)
      {
         try
         {
            bool myBool = false;
            MyTestClass myTestClassInstance = new MyTestClass();
            // Get Type of 'myTestClassInstance'.
            Type   myType = myTestClassInstance.GetType();
            // Get the 'IsSealed' property of the 'MyTestClass' instance.
            myBool = myType.IsSealed;
            Console.WriteLine("\n{0} class is Sealed: {1}.",myType.FullName,myBool.ToString ());
         }
         catch (Exception e)
         {
            Console.WriteLine("\nThe following exception is raised: {0}",e.Message);
         }
      }

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsSerializableTopic1"></a><a name="IsSerializable">IsSerializable</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsSerializable">System.Type.IsSerializable</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is serializable.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsSerializable {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
      // Declare a class as public with [Serializable] attribute.
      [Serializable] public class MyTestClass 
      {
      }
      public static void Main(string []args)
      {
         try
         {
            bool myBool = false;
            MyTestClass myTestClassInstance = new MyTestClass();
            // Get Type of 'myTestClassInstance'.
            Type myType = myTestClassInstance.GetType();
            // Get the 'IsSerializable' property of the 'MyTestClass' instance.
            myBool = myType.IsSerializable;
            Console.WriteLine("\n{0} class is Serializable: {1}.",myType.FullName,myBool.ToString ());
         }
         catch (Exception e)
         {
            Console.WriteLine("\nThe following exception is raised: {0}",e.Message);
         }
      }

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="../../System.Runtime.Serialization/types/ISerializable.html">ISerializable</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsSpecialNameTopic1"></a><a name="IsSpecialName">IsSpecialName</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsSpecialName">System.Type.IsSpecialName</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> has a name that requires special handling.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsSpecialName {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of types that might require special treatment by some compilers.</dd>
</dl><b>Example</b><dl>
<dd> This example shows a use of <b>IsSpecialName</b> to filter internal or private members out of a list.<pre>
private void DumpMethods(Type aType)
 {
 if (!ShowMethods)
 return;
 MethodInfo[] mInfo = aType.GetMethods();
 myWriter.WriteLine("Methods"); 
 bool found = false;            
 
   if (mInfo.Length != 0)
   {
    for ( int i=0; i &lt; mInfo.Length; i++ )
    {
    // Only display methods declared in this type. Also 
    // filter out any methods with special names, because these
    // cannot be generally called by the user. That is, their 
    // functionality is usually exposed in other ways, for example,
    // property get/set methods are exposed as properties.
             
     if (mInfo[i].DeclaringType == aType &amp;&amp; !mInfo[i].IsSpecialName)
     {        
      found = true;
      StringBuilder modifiers = new StringBuilder();
      if (mInfo[i].IsStatic)   {modifiers.Append("static ");}     
      if (mInfo[i].IsPublic)   {modifiers.Append("public ");}     
      if (mInfo[i].IsFamily)   {modifiers.Append("protected ");}     
      if (mInfo[i].IsAssembly) {modifiers.Append("internal ");}     
      if (mInfo[i].IsPrivate)  {modifiers.Append("private ");}     
    myWriter.WriteLine("{0} {1}", modifiers, mInfo[i]);
      }
    }                      
  }                    
      if (!found)
      {
       myWriter.WriteLine("(none)");
      }
 }

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsUnicodeClassTopic1"></a><a name="IsUnicodeClass">IsUnicodeClass</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsUnicodeClass">System.Type.IsUnicodeClass</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the string format attribute <b>UnicodeClass</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsUnicodeClass {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#StringFormatMask">TypeAttributes.StringFormatMask</a> is used to select the string format attributes. The string format attributes enhance interoperability by defining how strings should be interpreted.</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsAnsiClass">Type.IsAnsiClass</a> |  <a href="#IsAutoClass">Type.IsAutoClass</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsValueTypeTopic1"></a><a name="IsValueType">IsValueType</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsValueType">System.Type.IsValueType</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is a value type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsValueType {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Value types are those that are represented as sequences of bits; value types are not classes or interfaces. These are referred to as "structs" in some programming languages. Enums are a special case of value types.<p> This property returns true for enumerations, but not for the  <a href="../../System/types/Enum.html">Enum</a> type itself, which is a class. For an example that demonstrates this behavior, see  <a href="#IsEnum">Type.IsEnum</a>.</p>
<p> This property is read-only.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
      // Declare enum type.
      enum MyEnum
      {
         One,
         Two
      }
      public static void Main(string []args)
      {
         try
         {
            bool myBool = false;
            MyEnum myTestEnum = MyEnum.One;
            // Get Type of 'myTestEnum'.
            Type   myType = myTestEnum.GetType();
            // Get the 'IsValueType' property of the 'MyTestEnum' 
            // of variable.
            myBool = myType.IsValueType;
            Console.WriteLine("\n {0} is value type: {1}.",myType.FullName,myBool.ToString());
         }
         catch (Exception e)
         {
            Console.WriteLine("\nThe following exception is raised: {0}",e.Message);
         }
      }

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsClass">Type.IsClass</a> |  <a href="#IsInterface">Type.IsInterface</a> |  <a href="../../System/types/ValueType.html">ValueType</a> |  <a href="#IsValueTypeImpl">Type.IsValueTypeImpl</a> |  <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsClass">Type.IsClass</a> |  <a href="#IsInterface">Type.IsInterface</a> |  <a href="../../System/types/ValueType.html">ValueType</a> |  <a href="#IsValueTypeImpl">Type.IsValueTypeImpl</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="MemberTypeTopic1"></a><a name="MemberType">MemberType</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#MemberType">System.Type.MemberType</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a bitmask indicating the member type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Reflection/types/MemberTypes.html">MemberTypes</a> MemberType {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd> The following code example shows the <b>MemberType</b> field as a parameter to the <b>GetMember</b> method: <pre>
MemberInfo[] others = t.GetMember(mi.Name, mi.MemberType, BindingFlags.Public |
BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Instance);

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MemberTypes.html">MemberTypes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="ModuleTopic1"></a><a name="Module">Module</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Retrieves the dynamic module that contains this type definition.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Reflection/types/Module.html">Module</a> Module {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="NameTopic1"></a><a name="Name">Name</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Retrieves the name of this type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/String.html">string</a> Name {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="NamespaceTopic1"></a><a name="Namespace">Namespace</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Retrieves the namespace where this <b>TypeBuilder</b> is defined.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/String.html">string</a> Namespace {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="PackingSizeTopic1"></a><a name="PackingSize">PackingSize</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Retrieves the packing size of this type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection.Emit/types/PackingSize.html">PackingSize</a> PackingSize {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="ReflectedTypeTopic1"></a><a name="ReflectedType">ReflectedType</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns the type that was used to obtain this type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Type.html">Type</a> ReflectedType {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="SizeTopic1"></a><a name="Size">Size</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Retrieves the total size of a type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Int32.html">int</a> Size {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="TypeHandleTopic1"></a><a name="TypeHandle">TypeHandle</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Not supported in dynamic modules.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/RuntimeTypeHandle.html">RuntimeTypeHandle</a> TypeHandle {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> Not supported in dynamic modules.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="TypeInitializerTopic1"></a><a name="TypeInitializer">TypeInitializer</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#TypeInitializer">System.Type.TypeInitializer</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the initializer for the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> TypeInitializer {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Class initializers are available through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>, and  <a href="#GetConstructors">Type.GetConstructors</a>.</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="TypeTokenTopic1"></a><a name="TypeToken">TypeToken</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns the type token of this type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection.Emit/types/TypeToken.html">TypeToken</a> TypeToken {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="UnderlyingSystemTypeTopic1"></a><a name="UnderlyingSystemType">UnderlyingSystemType</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns the underlying system type for this <b>TypeBuilder</b>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Type.html">Type</a> UnderlyingSystemType {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/InvalidOperationException.html">InvalidOperationException</a></td>
<td> This type is an enum but there is no underlying system type.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#UnderlyingSystemType">IReflect.UnderlyingSystemType</a></dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="AddDeclarativeSecurityTopic1"></a><a name="AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">AddDeclarativeSecurity</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Security.Permissions/types/SecurityAction.html">SecurityAction</a> <i>action</i>,</font><br>   <font color="#008080"><a href="../../System.Security/types/PermissionSet.html">PermissionSet</a> <i>pset</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Adds declarative security to this type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public void AddDeclarativeSecurity(<br>   <font color="#008080"><a href="../../System.Security.Permissions/types/SecurityAction.html">SecurityAction</a> <i>action</i>,</font><br>   <font color="#008080"><a href="../../System.Security/types/PermissionSet.html">PermissionSet</a> <i>pset</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>action</i><br><dl>
<dd>
<param> The security action to be taken such as Demand, Assert, and so on.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>pset</i><br><dl>
<dd>
<param> The set of permissions the action applies to.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentOutOfRangeException.html">ArgumentOutOfRangeException</a></td>
<td> The <i>action</i> is invalid (<b>RequestMinimum</b>, <b>RequestOptional</b>, and <b>RequestRefuse</b> are invalid).</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/InvalidOperationException.html">InvalidOperationException</a></td>
<td> The containing type has been created using  <a href="#CreateType">TypeBuilder.CreateType</a>.<p> -or- </p>
<p> The permission set <i>pset</i> contains an action that was added earlier by <b>AddDeclarativeSecurity</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>pset</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd><b>AddDeclarativeSecurity</b> may be called several times with each call specifying a security action (such as Demand, Assert, or Deny) and a set of permissions that apply to the action.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="AddInterfaceImplementationTopic1"></a><a name="AddInterfaceImplementation(System.Type)">AddInterfaceImplementation</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>interfaceType</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Adds an interface that this type implements.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public void AddInterfaceImplementation(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>interfaceType</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>interfaceType</i><br><dl>
<dd>
<param> The interface that this type implements.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>interfaceType</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/InvalidOperationException.html">InvalidOperationException</a></td>
<td> The type was previously created using  <a href="#CreateType">TypeBuilder.CreateType</a>.</td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="CreateTypeTopic1"></a><a name="CreateType">CreateType</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Creates a  <a href="../../System/types/Type.html">Type</a> object for the class. After defining fields and methods on the class, <b>CreateType</b> is called in order to load its <b>Type</b> object.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Type.html">Type</a> CreateType();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns the new  <a href="../../System/types/Type.html">Type</a> object for this class.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/InvalidOperationException.html">InvalidOperationException</a></td>
<td> This type has been previously created.<p> -or- </p>
<p> The enclosing type has not been created.</p>
<p> -or- </p>
<p> This type is non-abstract and contains an abstract method.</p>
<p> -or- </p>
<p> This type is abstract and has a method with a method body.</p>
<p> -or- </p>
<p> This type is not an abstract class or an interface and has a method without a method body.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> If the type contains invalid Microsoft Intermediate Language (MSIL) code.<p> -or- </p>
<p> The branch target is specified using a 1-byte offset but the target is at a distance greater than 127 bytes from the branch.</p>
</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> If this type is a nested type, the  <a href="#CreateType">TypeBuilder.CreateType</a> must be called on the nesting (enclosing) type before calling the method on this type.<p> If the nesting type contains a field that is a value type defined as a nested type (for example, a field that is an enum defined as a nested type), calling  <a href="#CreateType">TypeBuilder.CreateType</a> on the nesting type will generate a  <a href="../../System/types/AppDomain.html#TypeResolve">AppDomain.TypeResolve</a> event. This is because the loader cannot determine the size of the nesting type until the nested type has been completed. The caller should define a handler for the  <a href="../../System/types/AppDomain.html#TypeResolve">AppDomain.TypeResolve</a> event to complete the definition of the nested type by calling  <a href="#CreateType">TypeBuilder.CreateType</a> on the nested type's  <a href="../../System.Reflection.Emit/types/TypeBuilder.html">TypeBuilder</a>. The following example shows how to define the event handler.</p>
<pre>

using System;
using System.Reflection;
using System.Reflection.Emit;
using System.Threading;
using System.Text;
using System.Resources;
using System.Collections;
using System.IO;

public class NestedEnum {    
    internal static TypeBuilder enumType = null;
    internal static Type tNested = null;   
    internal static Type tNesting = null;

    public static void Main(String[] args) {
	AssemblyName asmName = new AssemblyName();
	asmName.Name = "NestedEnum";
	AssemblyBuilder asmBuild = Thread.GetDomain().DefineDynamicAssembly(asmName, AssemblyBuilderAccess.RunAndSave);
	ModuleBuilder modBuild = asmBuild.DefineDynamicModule("ModuleOne", "NestedEnum.dll");       

	// Hook up the event listening.
	TypeResolveHandler typeResolveHandler = new TypeResolveHandler(modBuild);
	// Add a listener for the type resolve events.
	AppDomain currentDomain = Thread.GetDomain();
	ResolveEventHandler resolveHandler = new ResolveEventHandler(typeResolveHandler.ResolveEvent);
	currentDomain.TypeResolve += resolveHandler;

	TypeBuilder tb = modBuild.DefineType("aType", TypeAttributes.Public);
	TypeBuilder eb = tb.DefineNestedType("anEnum", TypeAttributes.NestedPublic | TypeAttributes.Sealed, typeof(Enum), null);
	eb.DefineField("value__", typeof(int), FieldAttributes.Private | FieldAttributes.SpecialName);
	FieldBuilder fb = eb.DefineField("foo", eb, FieldAttributes.Public | FieldAttributes.Literal | FieldAttributes.Static);
	fb.SetConstant(1);

	enumType = eb;

	// Comment out this field.
	// When this field is defined, the loader cannot determine the size
	// of the type. Therefore, a TypeResolve event is generated when the
	// nested type is completed.
	tb.DefineField("bar", eb, FieldAttributes.Public);        

	tNesting = tb.CreateType();
	if (tNesting == null)
	    Console.WriteLine("NestingType CreateType failed but didn't throw!");	

	try {
	    tNested = eb.CreateType();
	    if (tNested == null)
		Console.WriteLine("NestedType CreateType failed but didn't throw!");	
	}
	catch {
	    // This is needed because you might have already completed the type in the TypeResolve event.
	}

	if (tNested != null) {
	    Type x = tNested.DeclaringType;
	    if (x == null)
		Console.WriteLine("oops");
	    else 
		Console.WriteLine(x.Name);
	}

	asmBuild.Save( "NestedEnum.dll" );

	// Remove the listener for the type resolve events.
	currentDomain.TypeResolve -= resolveHandler;
    }
}

// Helper class called when a resolve type event is raised.
class TypeResolveHandler 
{
    private Module m_Module;

    public TypeResolveHandler(Module mod)
    {
	m_Module = mod;
    }

    public Assembly ResolveEvent(Object sender, ResolveEventArgs args)
    {
	Console.WriteLine(args.Name);
	// Use args.Name to look up the type name. In this case, you are getting anEnum.
	try {
	    NestedEnum.tNested = NestedEnum.enumType.CreateType();
	}
	catch {
	    // This is needed to throw away InvalidOperationException.
	    // Loader might send the TypeResolve event more than once
	    // and the type might be complete already.
	}

	// Complete the type.		    
	return m_Module.Assembly;
    }
}
    

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="DefineConstructorTopic1"></a><a name="DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">DefineConstructor</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/MethodAttributes.html">MethodAttributes</a> <i>attributes</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callingConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>parameterTypes</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Adds a new constructor to the class, with the given attributes and signature.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection.Emit/types/ConstructorBuilder.html">ConstructorBuilder</a> DefineConstructor(<br>   <font color="#008080"><a href="../../System.Reflection/types/MethodAttributes.html">MethodAttributes</a> <i>attributes</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callingConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>parameterTypes</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>attributes</i><br><dl>
<dd>
<param> The attributes of the constructor.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>callingConvention</i><br><dl>
<dd>
<param> The calling convention of the constructor.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>parameterTypes</i><br><dl>
<dd>
<param> The types of the parameters of the constructor.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The defined constructor.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/InvalidOperationException.html">InvalidOperationException</a></td>
<td> The type was previously created using  <a href="#CreateType">TypeBuilder.CreateType</a>.</td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="DefineDefaultConstructorTopic1"></a><a name="DefineDefaultConstructor(System.Reflection.MethodAttributes)">DefineDefaultConstructor</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/MethodAttributes.html">MethodAttributes</a> <i>attributes</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Defines the default constructor. The constructor defined here will simply call the default constructor of the parent.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection.Emit/types/ConstructorBuilder.html">ConstructorBuilder</a> DefineDefaultConstructor(<br>   <font color="#008080"><a href="../../System.Reflection/types/MethodAttributes.html">MethodAttributes</a> <i>attributes</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>attributes</i><br><dl>
<dd>
<param> A <b>MethodAttributes</b> object representing the attributes to be applied to the constructor.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns the constructor.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> The parent class does not have a default constructor </td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Since the default constructor is automatically defined, it is only necessary to call this method if the attributes on the default constructor should be set to something other than MethodBase.Constructor. This method is provided here to make it easier to set the attributes.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="DefineEventTopic1"></a><a name="DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">DefineEvent</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/EventAttributes.html">EventAttributes</a> <i>attributes</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>eventtype</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Adds a new event to the class, with the given name, attributes and event type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection.Emit/types/EventBuilder.html">EventBuilder</a> DefineEvent(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/EventAttributes.html">EventAttributes</a> <i>attributes</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>eventtype</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The name of the event.<i>name</i> cannot contain embedded nulls.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>attributes</i><br><dl>
<dd>
<param> The attributes of the event.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>eventtype</i><br><dl>
<dd>
<param> The type of the event.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The defined event.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td> The length of <i>name</i> is zero.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p> -or- </p>
<p><i>eventtype</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/InvalidOperationException.html">InvalidOperationException</a></td>
<td> The type was previously created using  <a href="#CreateType">TypeBuilder.CreateType</a></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="DefineFieldTopic1"></a><a name="DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">DefineField</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>fieldName</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>type</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/FieldAttributes.html">FieldAttributes</a> <i>attributes</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Adds a new field to the class, with the given name, attributes and field type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection.Emit/types/FieldBuilder.html">FieldBuilder</a> DefineField(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>fieldName</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>type</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/FieldAttributes.html">FieldAttributes</a> <i>attributes</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>fieldName</i><br><dl>
<dd>
<param> The name of the field.<i>fieldName </i> cannot contain embedded nulls.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>type</i><br><dl>
<dd>
<param> The type of the field 
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>attributes</i><br><dl>
<dd>
<param> The attributes of the field.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The defined field.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td> The length of <i>fieldName</i> is zero.<p> -or- </p>
<p><i>type</i> is System.Void.</p>
<p> -or- </p>
<p> A total size was specified for the parent class of this field.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>fieldName</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/InvalidOperationException.html">InvalidOperationException</a></td>
<td> The type was previously created using <b>CreateType</b> <a href="../../System.Reflection.Emit/types/TypeBuilder.html">TypeBuilder</a>.</td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="DefineInitializedDataTopic1"></a><a name="DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">DefineInitializedData</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Byte.html">byte[]</a> <i>data</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/FieldAttributes.html">FieldAttributes</a> <i>attributes</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Defines initialized data field in the .sdata section of the portable executable (PE) file.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection.Emit/types/FieldBuilder.html">FieldBuilder</a> DefineInitializedData(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Byte.html">byte[]</a> <i>data</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/FieldAttributes.html">FieldAttributes</a> <i>attributes</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The name used to refer to the data.<i>name</i> cannot contain embedded nulls.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>data</i><br><dl>
<dd>
<param> The blob of data.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>attributes</i><br><dl>
<dd>
<param> The attributes for the field.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A field to reference the data.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td> Length of <i>name</i> is zero.<p> -or- </p>
<p> The size of the data is less than or equal to zero or greater than 0x0fffffff.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> or <i>data</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/InvalidOperationException.html">InvalidOperationException</a></td>
<td> <a href="../../System.Reflection.Emit/types/ModuleBuilder.html#CreateGlobalFunctions">ModuleBuilder.CreateGlobalFunctions</a> has been previously called.</td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="DefineMethodTopic1"></a><a name="DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">DefineMethod</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/MethodAttributes.html">MethodAttributes</a> <i>attributes</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>parameterTypes</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Adds a new method to the class, with the given name and method signature.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection.Emit/types/MethodBuilder.html">MethodBuilder</a> DefineMethod(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/MethodAttributes.html">MethodAttributes</a> <i>attributes</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>parameterTypes</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The name of the method.<i>name</i> cannot contain embedded nulls.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>attributes</i><br><dl>
<dd>
<param> The attributes of the method.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>returnType</i><br><dl>
<dd>
<param> The return type of the method.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>parameterTypes</i><br><dl>
<dd>
<param> The types of the parameters of the method.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The defined method.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td> The length of <i>name</i> is zero.<p> -or- </p>
<p> The type of the parent of this method is an interface and this method is not virtual.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/InvalidOperationException.html">InvalidOperationException</a></td>
<td> The type was previously created using  <a href="#CreateType">TypeBuilder.CreateType</a></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="DefineMethodTopic2"></a><a name="DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">DefineMethod</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/MethodAttributes.html">MethodAttributes</a> <i>attributes</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callingConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>parameterTypes</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Adds a new method to the class, with the given name and method signature.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection.Emit/types/MethodBuilder.html">MethodBuilder</a> DefineMethod(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/MethodAttributes.html">MethodAttributes</a> <i>attributes</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callingConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>parameterTypes</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The name of the method.<i>name</i> cannot contain embedded nulls.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>attributes</i><br><dl>
<dd>
<param> The attributes of the method.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>callingConvention</i><br><dl>
<dd>
<param> The calling convention of the method.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>returnType</i><br><dl>
<dd>
<param> The return type of the method.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>parameterTypes</i><br><dl>
<dd>
<param> The types of the parameters of the method.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The defined method.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td> The length of <i>name</i> is zero.<p> -or- </p>
<p> The type of the parent of this method is an interface and this method is not virtual.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/InvalidOperationException.html">InvalidOperationException</a></td>
<td> The type was previously created using  <a href="#CreateType">TypeBuilder.CreateType</a></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="DefineMethodOverrideTopic1"></a><a name="DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">DefineMethodOverride</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> <i>methodInfoBody</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> <i>methodInfoDeclaration</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Specifies a given method body that implements a given method declaration.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public void DefineMethodOverride(<br>   <font color="#008080"><a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> <i>methodInfoBody</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> <i>methodInfoDeclaration</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>methodInfoBody</i><br><dl>
<dd>
<param> The method body to be used. This should be a <b>MethodBuilder</b> object.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>methodInfoDeclaration</i><br><dl>
<dd>
<param> The method whose declaration is to be used.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>methodInfoBody</i> does not belong to this class.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>methodInfoBody</i> or <i>methodInfoDeclaration</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/InvalidOperationException.html">InvalidOperationException</a></td>
<td> The type was previously created using  <a href="#CreateType">TypeBuilder.CreateType</a>.<p> -or- </p>
<p> The method <i>methodInfoBody</i> 's declaring type is not this type.</p>
</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd><b>DefineMethodOverride</b> defines a method impl. A method impl is a token point to an implementation and a token pointing to a declaration that the body will implement. The body must be defined on the type the method impl is defined and the body must be virtual. The declaration can be made to a method defined on an interface implemented by the type, a method on a derived class or a method defined in the type. If the declaration is on an interface only, the slot defined for the interface is altered. If the declaration is made to a method on a base type then the slot for the method is overridden and any duplicates for the overridden method are also replaced. The method overridden cannot be the actual method declared. If the method is on the same type then the slot is replaced and any duplicates for the replaced methods are overridden.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="DefineNestedTypeTopic1"></a><a name="DefineNestedType(System.String)">DefineNestedType</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Defines a nested type given its name.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection.Emit/types/TypeBuilder.html">TypeBuilder</a> DefineNestedType(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The full path of the type.<i>name</i> cannot contain embedded nulls.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The defined nested type.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td> Length of <i>name</i> is zero.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p> -or- </p>
<p> A null interface is specified in the <i>interfaces</i> array.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/InvalidOperationException.html">InvalidOperationException</a></td>
<td> The type was previously created using  <a href="#CreateType">TypeBuilder.CreateType</a>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The nested type needs to be complete before you can reflect on it using  <a href="../../System/types/Type.html#GetMembers">Type.GetMembers</a>,  <a href="../../System/types/Type.html#GetNestedType(System.String)">Type.GetNestedType</a>, or  <a href="../../System/types/Type.html#GetNestedTypes">Type.GetNestedTypes</a>.<p> See the description of  <a href="#CreateType">TypeBuilder.CreateType</a> for the order in which nested types and nesting types should be completed.</p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="DefineNestedTypeTopic2"></a><a name="DefineNestedType(System.String,System.Reflection.TypeAttributes)">DefineNestedType</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> <i>attr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Defines a nested type given its name and attributes.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection.Emit/types/TypeBuilder.html">TypeBuilder</a> DefineNestedType(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> <i>attr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The full path of the type.<i>name</i> cannot contain embedded nulls.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>attr</i><br><dl>
<dd>
<param> The attributes of the type.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The defined nested type.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td> The nested attribute is not specified.<p> -or- </p>
<p> This type is sealed.</p>
<p> -or- </p>
<p> This type is an array.</p>
<p> -or- </p>
<p> This type is an interface but the nested type is not an interface.</p>
<p> -or- </p>
<p> The length of <i>name</i> is zero.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p><b>-</b> or- </p>
<p> A null interface is specified in the <i>interfaces</i> array.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/InvalidOperationException.html">InvalidOperationException</a></td>
<td> The type was previously created using  <a href="#CreateType">TypeBuilder.CreateType</a>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The nested type needs to be complete before you can reflect on it using  <a href="../../System/types/Type.html#GetMembers">Type.GetMembers</a>,  <a href="../../System/types/Type.html#GetNestedType(System.String)">Type.GetNestedType</a>, or  <a href="../../System/types/Type.html#GetNestedTypes">Type.GetNestedTypes</a>.<p> See the description of  <a href="#CreateType">TypeBuilder.CreateType</a> for the order in which nested types and nesting types should be completed.</p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="DefineNestedTypeTopic3"></a><a name="DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">DefineNestedType</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> <i>attr</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>parent</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Defines a nested type given its name, attributes, and the type that it extends.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection.Emit/types/TypeBuilder.html">TypeBuilder</a> DefineNestedType(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> <i>attr</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>parent</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The full path of the type.<i>name</i> cannot contain embedded nulls.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>attr</i><br><dl>
<dd>
<param> The attributes of the type.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>parent</i><br><dl>
<dd>
<param> The type that the nested type extends.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The defined nested type.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td> The nested attribute is not specified.<p> -or- </p>
<p> This type is sealed.</p>
<p> -or- </p>
<p> This type is an array.</p>
<p> -or- </p>
<p> This type is an interface but the nested type is not an interface.</p>
<p> -or- </p>
<p> The length of <i>name</i> is zero.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p><b>-</b> or- </p>
<p> A null interface is specified in the <i>interfaces</i> array.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/InvalidOperationException.html">InvalidOperationException</a></td>
<td> The type was previously created using  <a href="#CreateType">TypeBuilder.CreateType</a>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The nested type needs to be complete before you can reflect on it using  <a href="../../System/types/Type.html#GetMembers">Type.GetMembers</a>,  <a href="../../System/types/Type.html#GetNestedType(System.String)">Type.GetNestedType</a>, or  <a href="../../System/types/Type.html#GetNestedTypes">Type.GetNestedTypes</a>.<p> See the description of  <a href="#CreateType">TypeBuilder.CreateType</a> for the order in which nested types and nesting types should be completed.</p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="DefineNestedTypeTopic4"></a><a name="DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">DefineNestedType</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> <i>attr</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>parent</i>,</font><br>   <font color="#008080"><a href="../../System/types/Int32.html">int</a> <i>typeSize</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Defines a nested type given its name, attributes, the total size of the type, and the type that it extends.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection.Emit/types/TypeBuilder.html">TypeBuilder</a> DefineNestedType(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> <i>attr</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>parent</i>,</font><br>   <font color="#008080"><a href="../../System/types/Int32.html">int</a> <i>typeSize</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The full path of the type.<i>name</i> cannot contain embedded nulls.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>attr</i><br><dl>
<dd>
<param> The attributes of the type.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>parent</i><br><dl>
<dd>
<param> The type that the nested type extends.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>typeSize</i><br><dl>
<dd>
<param> The total size of the type.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The defined nested type.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td> The nested attribute is not specified.<p> -or- </p>
<p> This type is sealed.</p>
<p> -or- </p>
<p> This type is an array.</p>
<p> -or- </p>
<p> This type is an interface but the nested type is not an interface.</p>
<p> -or- </p>
<p> The length of <i>name</i> is zero.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p><b>-</b> or- </p>
<p> A null interface is specified in the <i>interfaces</i> array.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/InvalidOperationException.html">InvalidOperationException</a></td>
<td> if the type was previously created using  <a href="#CreateType">TypeBuilder.CreateType</a>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The nested type needs to be complete before you can reflect on it using  <a href="../../System/types/Type.html#GetMembers">Type.GetMembers</a>,  <a href="../../System/types/Type.html#GetNestedType(System.String)">Type.GetNestedType</a>, or  <a href="../../System/types/Type.html#GetNestedTypes">Type.GetNestedTypes</a>.<p> See the description of  <a href="#CreateType">TypeBuilder.CreateType</a> for the order in which nested types and nesting types should be completed.</p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="DefineNestedTypeTopic5"></a><a name="DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">DefineNestedType</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> <i>attr</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>parent</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection.Emit/types/PackingSize.html">PackingSize</a> <i>packSize</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Defines a nested type given its name, attributes, the total size of the type, and the type that it extends.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection.Emit/types/TypeBuilder.html">TypeBuilder</a> DefineNestedType(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> <i>attr</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>parent</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection.Emit/types/PackingSize.html">PackingSize</a> <i>packSize</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The full path of the type.<i>name</i> cannot contain embedded nulls.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>attr</i><br><dl>
<dd>
<param> The attributes of the type.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>parent</i><br><dl>
<dd>
<param> The type that the nested type extends.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>packSize</i><br><dl>
<dd>
<param> The packing size of the type.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The defined nested type.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td> The nested attribute is not specified.<p> -or- </p>
<p> This type is sealed.</p>
<p> -or- </p>
<p> This type is an array.</p>
<p> -or- </p>
<p> This type is an interface but the nested type is not an interface.</p>
<p> -or- </p>
<p> The length of <i>name</i> is zero.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p><b>-</b> or- </p>
<p> A null interface is specified in the <i>interfaces</i> array.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/InvalidOperationException.html">InvalidOperationException</a></td>
<td> The type was previously created using  <a href="#CreateType">TypeBuilder.CreateType</a>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The nested type needs to be complete before you can reflect on it using  <a href="../../System/types/Type.html#GetMembers">Type.GetMembers</a>,  <a href="../../System/types/Type.html#GetNestedType(System.String)">Type.GetNestedType</a>, or  <a href="../../System/types/Type.html#GetNestedTypes">Type.GetNestedTypes</a>.<p> See the description of  <a href="#CreateType">TypeBuilder.CreateType</a> for the order in which nested types and nesting types should be completed.</p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="DefineNestedTypeTopic6"></a><a name="DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">DefineNestedType</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> <i>attr</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>parent</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>interfaces</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Defines a nested type given its name, attributes, the type that it extends, and the interfaces that it implements.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection.Emit/types/TypeBuilder.html">TypeBuilder</a> DefineNestedType(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> <i>attr</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>parent</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>interfaces</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The full path of the type.<i>name</i> cannot contain embedded nulls.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>attr</i><br><dl>
<dd>
<param> The attributes of the type.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>parent</i><br><dl>
<dd>
<param> The type that the nested type extends.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>interfaces</i><br><dl>
<dd>
<param> The interfaces that the nested type implements.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The defined nested type.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td> The nested attribute is not specified.<p> -or- </p>
<p> This type is sealed.</p>
<p> -or- </p>
<p> This type is an array.</p>
<p> -or- </p>
<p> This type is an interface but the nested type is not an interface.</p>
<p> -or- </p>
<p> The length of <i>name</i> is zero.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b> or a null interface is specified in the <i>interfaces</i> array.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/InvalidOperationException.html">InvalidOperationException</a></td>
<td> The type was previously created using  <a href="#CreateType">TypeBuilder.CreateType</a>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The nested type needs to be complete before you can reflect on it using  <a href="../../System/types/Type.html#GetMembers">Type.GetMembers</a>,  <a href="../../System/types/Type.html#GetNestedType(System.String)">Type.GetNestedType</a>, or  <a href="../../System/types/Type.html#GetNestedTypes">Type.GetNestedTypes</a>.<p> See the description of  <a href="#CreateType">TypeBuilder.CreateType</a> for the order in which nested types and nesting types should be completed.</p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="DefinePInvokeMethodTopic1"></a><a name="DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">DefinePInvokeMethod</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>dllName</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/MethodAttributes.html">MethodAttributes</a> <i>attributes</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callingConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>parameterTypes</i>,</font><br>   <font color="#008080"><a href="../../System.Runtime.InteropServices/types/CallingConvention.html">CallingConvention</a> <i>nativeCallConv</i>,</font><br>   <font color="#008080"><a href="../../System.Runtime.InteropServices/types/CharSet.html">CharSet</a> <i>nativeCharSet</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Defines a <b>PInvoke</b> method given its name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <b>PInvoke</b> flags.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection.Emit/types/MethodBuilder.html">MethodBuilder</a> DefinePInvokeMethod(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>dllName</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/MethodAttributes.html">MethodAttributes</a> <i>attributes</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callingConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>parameterTypes</i>,</font><br>   <font color="#008080"><a href="../../System.Runtime.InteropServices/types/CallingConvention.html">CallingConvention</a> <i>nativeCallConv</i>,</font><br>   <font color="#008080"><a href="../../System.Runtime.InteropServices/types/CharSet.html">CharSet</a> <i>nativeCharSet</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The name of the <b>PInvoke</b> method.<i>name</i> cannot contain embedded nulls.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>dllName</i><br><dl>
<dd>
<param> The name of the DLL in which the <b>PInvoke</b> method is defined.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>attributes</i><br><dl>
<dd>
<param> The attributes of the method.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>callingConvention</i><br><dl>
<dd>
<param> The method's calling convention.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>returnType</i><br><dl>
<dd>
<param> The method's return type.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>parameterTypes</i><br><dl>
<dd>
<param> The types of the method's parameters.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>nativeCallConv</i><br><dl>
<dd>
<param> The native calling convention.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>nativeCharSet</i><br><dl>
<dd>
<param> The method's native character set.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The defined <b>PInvoke</b> method.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td> The method is not static.<p> -or- </p>
<p> The parent type is an interface.</p>
<p> -or- </p>
<p> The method is abstract.</p>
<p> -or- </p>
<p> The method was previously defined.</p>
<p> -or- </p>
<p> The length of <i>name</i> or <i>dllName</i> is zero.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> or <i>dllName</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/InvalidOperationException.html">InvalidOperationException</a></td>
<td> The containing type has been previously created using  <a href="#CreateType">TypeBuilder.CreateType</a>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Some DLL import attributes (see the description of System.Runtime.InteropServices.DllImportAttribute) cannot be specified as arguments to this method. Such attributes should be set by emitting a custom attribute for the method. For example, the DLL import attribute <b>PreserveSig</b> is set by emitting a custom attribute.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="DefinePInvokeMethodTopic2"></a><a name="DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">DefinePInvokeMethod</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>dllName</i>,</font><br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>entryName</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/MethodAttributes.html">MethodAttributes</a> <i>attributes</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callingConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>parameterTypes</i>,</font><br>   <font color="#008080"><a href="../../System.Runtime.InteropServices/types/CallingConvention.html">CallingConvention</a> <i>nativeCallConv</i>,</font><br>   <font color="#008080"><a href="../../System.Runtime.InteropServices/types/CharSet.html">CharSet</a> <i>nativeCharSet</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Defines a <b>PInvoke</b> method given its name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <b>PInvoke</b> flags.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection.Emit/types/MethodBuilder.html">MethodBuilder</a> DefinePInvokeMethod(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>dllName</i>,</font><br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>entryName</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/MethodAttributes.html">MethodAttributes</a> <i>attributes</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callingConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>parameterTypes</i>,</font><br>   <font color="#008080"><a href="../../System.Runtime.InteropServices/types/CallingConvention.html">CallingConvention</a> <i>nativeCallConv</i>,</font><br>   <font color="#008080"><a href="../../System.Runtime.InteropServices/types/CharSet.html">CharSet</a> <i>nativeCharSet</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The name of the <b>PInvoke</b> method.<i>name</i> cannot contain embedded nulls.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>dllName</i><br><dl>
<dd>
<param> The name of the DLL in which the PInvoke method is defined.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>entryName</i><br><dl>
<dd>
<param> The name of the entry point in the DLL.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>attributes</i><br><dl>
<dd>
<param> The attributes of the method.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>callingConvention</i><br><dl>
<dd>
<param> The method's calling convention.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>returnType</i><br><dl>
<dd>
<param> The method's return type.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>parameterTypes</i><br><dl>
<dd>
<param> The types of the method's parameters.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>nativeCallConv</i><br><dl>
<dd>
<param> The native calling convention.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>nativeCharSet</i><br><dl>
<dd>
<param> The method's native character set.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The defined PInvoke method.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td> The method is not static.<p> -or- </p>
<p> The parent type is an interface.</p>
<p> -or- </p>
<p> The method is abstract.</p>
<p> -or- </p>
<p> The method was previously defined.</p>
<p> -or- </p>
<p> The length of <i>name,</i><i>dllName,</i> or <i>entryName</i> is zero.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name, dllName</i>, or <i>entryName</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/InvalidOperationException.html">InvalidOperationException</a></td>
<td> The containing type has been previously created using  <a href="#CreateType">TypeBuilder.CreateType</a>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Some DLL import attributes (see the description of System.Runtime.InteropServices.DllImportAttribute) cannot be specified as arguments to this method. Such attributes should be set by emitting a custom attribute for the method. For example, the DLL import attribute <b>PreserveSig</b> is set by emitting a custom attribute.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="DefinePropertyTopic1"></a><a name="DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">DefineProperty</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/PropertyAttributes.html">PropertyAttributes</a> <i>attributes</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>parameterTypes</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Adds a new property to the class, with the given name and property signature.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection.Emit/types/PropertyBuilder.html">PropertyBuilder</a> DefineProperty(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/PropertyAttributes.html">PropertyAttributes</a> <i>attributes</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>parameterTypes</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The name of the property.<i>name</i> cannot contain embedded nulls.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>attributes</i><br><dl>
<dd>
<param> The attributes of the property.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>returnType</i><br><dl>
<dd>
<param> The return type of the property.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>parameterTypes</i><br><dl>
<dd>
<param> The types of the parameters of the property.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The defined property.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td> The length of <i>name</i> is zero.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b><p> -or- </p>
<p> if any of the elements of the <i>parameterTypes</i> array is <b>null</b></p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/InvalidOperationException.html">InvalidOperationException</a></td>
<td> The type was previously created using  <a href="#CreateType">TypeBuilder.CreateType</a></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="DefineTypeInitializerTopic1"></a><a name="DefineTypeInitializer">DefineTypeInitializer</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Defines the initializer for this type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection.Emit/types/ConstructorBuilder.html">ConstructorBuilder</a> DefineTypeInitializer();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns a type initializer.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/InvalidOperationException.html">InvalidOperationException</a></td>
<td> The containing type has been previously created using  <a href="#CreateType">TypeBuilder.CreateType</a>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The initializer created is always public.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="DefineUninitializedDataTopic1"></a><a name="DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">DefineUninitializedData</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Int32.html">int</a> <i>size</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/FieldAttributes.html">FieldAttributes</a> <i>attributes</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Defines uninitialized data field in the .sdata section of the portable executable (PE) file.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection.Emit/types/FieldBuilder.html">FieldBuilder</a> DefineUninitializedData(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Int32.html">int</a> <i>size</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/FieldAttributes.html">FieldAttributes</a> <i>attributes</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The name used to refer to the data.<i>name</i> cannot contain embedded nulls.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>size</i><br><dl>
<dd>
<param> The blob of data.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>attributes</i><br><dl>
<dd>
<param> The attributes for the field.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A field to reference the data.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td> Length of <i>name</i> is zero.<p> -or- </p>
<p> The size of the data is less than or equal to zero or greater than 0x003f0000.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/InvalidOperationException.html">InvalidOperationException</a></td>
<td> The type was previously created using  <a href="#CreateType">TypeBuilder.CreateType</a>.</td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="EqualsTopic1"></a><a name="Equals(System.Object)">Equals</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>o</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#Equals(System.Object)">System.Type.Equals</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Determines if the underlying system type of the current  <a href="../../System/types/Type.html">Type</a> is the same as the underlying system type of the specified  <a href="../../System/types/Object.html">Object</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Boolean.html">bool</a> Equals(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>o</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>o</i><br><dl>
<dd>
<param> The  <a href="../../System/types/Object.html">Object</a> whose underlying system type is to be compared with the underlying system type of the current  <a href="../../System/types/Type.html">Type</a>.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the underlying system type of <i>o</i> is the same as the underlying system type of the current  <a href="../../System/types/Type.html">Type</a>; otherwise, <b>false</b>. This method also returns <b>false</b> if the object specified by the <i>o</i> parameter is not a <b>Type</b>.</dd>
</dl><b>Remarks</b><dl>
<dd> This method overrides  <a href="../../System/types/Object.html#Equals(System.Object)">Object.Equals</a>.</dd>
</dl><b>Example</b><dl>
<dd> The following example uses <b>Equals</b> to compare two <b>Object</b> instances.<pre>
using System;
 using System.Reflection;
 
 class EqType
 {
   public static void Main(String[] args)
   {
    Type a = typeof(EqType);
    Type b = typeof(Type);
    Console.WriteLine("{0}", a.Equals(b).ToString());
    b = (new EqType()).GetType();
    Console.WriteLine("{0}", a.Equals(b).ToString());
   }
 }
 
 //This code produces the following output:
 //False
 //True

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#UnderlyingSystemType">Type.UnderlyingSystemType</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="EqualsTopic2"></a><a name="Equals(System.Type)">Equals</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>o</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#Equals(System.Type)">System.Type.Equals</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Determines if the underlying system type of the current  <a href="../../System/types/Type.html">Type</a> is the same as the underlying system type of the specified  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> Equals(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>o</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>o</i><br><dl>
<dd>
<param> The  <a href="../../System/types/Type.html">Type</a> whose underlying system type is to be compared with the underlying system type of the current  <a href="../../System/types/Type.html">Type</a>.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the underlying system type of <i>o</i> is the same as the underlying system type of the current  <a href="../../System/types/Type.html">Type</a>; otherwise, <b>false</b>.</dd>
</dl><b>Example</b><dl>
<dd> The following example uses <b>Equals</b> to compare two types.<pre>
 using System;
 using System.Reflection;
 
 class EqType
 {
   public static void Main(String[] args)
   {
    int a = 1;
    float b = 1;
    Console.WriteLine("{0}", a.Equals(b).ToString());
    b=a;
    Console.WriteLine("{0}", a.Equals(b).ToString());
   }
 }
 
 //This code produces the following output:
 //False
 //False

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#UnderlyingSystemType">Type.UnderlyingSystemType</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="FinalizeTopic1"></a><a name="Finalize">Finalize</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#Finalize">System.Object.Finalize</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            ~TypeBuilder();</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="FindInterfacesTopic1"></a><a name="FindInterfaces(System.Reflection.TypeFilter,System.Object)">FindInterfaces</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/TypeFilter.html">TypeFilter</a> <i>filter</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>filterCriteria</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#FindInterfaces(System.Reflection.TypeFilter,System.Object)">System.Type.FindInterfaces</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns an array of  <a href="../../System/types/Type.html">Type</a> objects representing a filtered list of interfaces implemented or inherited by the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/Type.html">Type[]</a> FindInterfaces(<br>   <font color="#008080"><a href="../../System.Reflection/types/TypeFilter.html">TypeFilter</a> <i>filter</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>filterCriteria</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>filter</i><br><dl>
<dd>
<param> The  <a href="../../System.Reflection/types/TypeFilter.html">TypeFilter</a> delegate that compares the interfaces against <i>filterCriteria</i>. The  <a href="../../System.Reflection/types/TypeFilter.html">TypeFilter</a> delegate that compares the interfaces against <i>filterCriteria</i>.</dd>
</dl>
</p>
</dd>
<dd>
<p><i>filterCriteria</i><br><dl>
<dd>
<param> The search criteria that determines whether an interface should be included in the returned array.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System/types/Type.html">Type</a> objects representing a filtered list of the interfaces implemented or inherited by the current  <a href="../../System/types/Type.html">Type</a>.<p> -or- </p>
<p> An empty array of type  <a href="../../System/types/Type.html">Type</a>, if no interfaces matching the filter are implemented or inherited by the current  <a href="../../System/types/Type.html">Type</a>.</p>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>filter</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/TargetInvocationException.html">TargetInvocationException</a></td>
<td> A static initializer is invoked and throws an exception.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This method can be overridden by a derived class.<p> The  <a href="../../System.Reflection/types/Module.html#FilterTypeName">Module.FilterTypeName</a> and  <a href="../../System.Reflection/types/Module.html#FilterTypeNameIgnoreCase">Module.FilterTypeNameIgnoreCase</a> delegates supplied by the  <a href="../../System.Reflection/types/Module.html">Module</a> class may also be used, in lieu of the  <a href="../../System.Reflection/types/TypeFilter.html">TypeFilter</a> delegate.</p>
<p> All of the interfaces implemented by this class are considered during the search, whether declared by a base class or this class itself.</p>
<p> This method searches the base class hierarchy, returning each of the matching interfaces each class implements as well as all the matching interfaces each of those interfaces implements (that is, the transitive closure of the matching interfaces is returned). No duplicate interfaces are returned.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
using System;
using System.Xml;
using System.Reflection;

public class MyFindInterfacesSample 
{
   public static void Main()
   {
      try
      {
         XmlDocument myXMLDoc = new XmlDocument();
         myXMLDoc.LoadXml("&lt;book genre='novel' ISBN='1-861001-57-5'&gt;" +
            "&lt;title&gt;Pride And Prejudice&lt;/title&gt;" + "&lt;/book&gt;");
         Type myType = myXMLDoc.GetType();

         // Specify the TypeFilter delegate that compares the interfaces against filter criteria.
         TypeFilter myFilter = new TypeFilter(MyInterfaceFilter);
         String[] myInterfaceList = new String[2] {"System.Collections.IEnumerable",
             "System.Collections.ICollection"};

         for(int index=0; index &lt; myInterfaceList.Length; index++)
         {
            Type[] myInterfaces = myType.FindInterfaces(myFilter, myInterfaceList[index]);
				
            if (myInterfaces.Length &gt; 0) 
            {
               Console.WriteLine("\nThe {0} implements the interface {1}", myType, myInterfaceList[index]);	
               for(int j =0;j &lt; myInterfaces.Length;j++)
                  Console.WriteLine("Interfaces supported #{0} : {1}",j,myInterfaces[j].ToString());
            }
            else
               Console.WriteLine("\nThe {0} does not implement the interface {1}",myType,myInterfaceList[index]);	
         }
      }
      catch(ArgumentNullException e)
      {
         Console.WriteLine("ArgumentNullException : " + e.Message);
      }
      catch(TargetInvocationException e)
      {
         Console.WriteLine("TargetInvocationException : " + e.Message);
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception : " + e.Message);
      }
   }
      
	public static bool MyInterfaceFilter(Type typeObj,Object criteriaObj)
	{
		if(typeObj.ToString() == criteriaObj.ToString())
		   return true;
		else
		   return false;
	}
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/Module.html">Module</a> |  <a href="../../System.Reflection/types/TypeFilter.html">TypeFilter</a> |  <a href="#GetInterface(System.String)">Type.GetInterface</a> |  <a href="#GetInterfaces">Type.GetInterfaces</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="FindMembersTopic1"></a><a name="FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">FindMembers</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/MemberTypes.html">MemberTypes</a> <i>memberType</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/MemberFilter.html">MemberFilter</a> <i>filter</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>filterCriteria</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">System.Type.FindMembers</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns a filtered array of  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> objects of the specified member type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo[]</a> FindMembers(<br>   <font color="#008080"><a href="../../System.Reflection/types/MemberTypes.html">MemberTypes</a> <i>memberType</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/MemberFilter.html">MemberFilter</a> <i>filter</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>filterCriteria</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>memberType</i><br><dl>
<dd>
<param> A <b>MemberTypes</b> object indicating the type of member to search for.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>filter</i><br><dl>
<dd>
<param> The delegate that does the comparisons, returning <b>true</b> if the member currently being inspected matches the <i>filterCriteria</i> and <b>false</b> otherwise. You can use the <b>FilterAttribute</b>, <b>FilterName</b>, and <b>FilterNameIgnoreCase</b> delegates supplied by this class. The first uses the fields of <b>FieldAttributes</b>, <b>MethodAttributes</b>, and <b>MethodImplAttributes</b> as search criteria, and the other two delegates use <b>String</b> objects as the search criteria.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>filterCriteria</i><br><dl>
<dd>
<param> The search criteria that determines whether a member is returned in the array of <b>MemberInfo</b> objects.<p> The fields of <b>FieldAttributes</b>, <b>MethodAttributes</b>, and <b>MethodImplAttributes</b> can be used in conjunction with the <b>FilterAttribute</b> delegate supplied by this class.</p> The search criteria that determines whether a member is returned in the array of <b>MemberInfo</b> objects.<p> The fields of <b>FieldAttributes</b>, <b>MethodAttributes</b>, and <b>MethodImplAttributes</b> can be used in conjunction with the <b>FilterAttribute</b> delegate supplied by this class.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A filtered array of  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> objects of the specified member type.<p> -or- </p>
<p> An empty array of type  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a>, if the current  <a href="../../System/types/Type.html">Type</a> does not have members of type <i>memberType</i> that match the filter criteria.</p>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>filter</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This method can be overridden by a derived class.<p> Members include properties, methods, fields, events, and so on. If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which members to include in the search: </p>
<UL>
<li><i>Instance</i> to include instance members in the search.</li>
<li><i>Static</i> to include static members in the search.</li>
<li><i>Public</i> to include public members in the search.</li>
<li><i>NonPublic</i> to include non-public members (that is, private and protected members) in the search.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><i>DeclaredOnly</i> to search only the members declared on the  <a href="../../System/types/Type.html">Type</a>, not members that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> Valid values for MemberType are defined in MemberInfo. If no such members are found, an empty array is returned.</p>
<p> Class initializers are available through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>, and  <a href="#GetConstructors">Type.GetConstructors</a>.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre></pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMember(System.String)">Type.GetMember</a> |  <a href="#GetMembers">Type.GetMembers</a> |  <a href="#GetDefaultMembers">Type.GetDefaultMembers</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetArrayRankTopic1"></a><a name="GetArrayRank">GetArrayRank</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetArrayRank">System.Type.GetArrayRank</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the number of dimensions in an  <a href="../../System/types/Array.html">Array</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/Int32.html">int</a> GetArrayRank();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An  <a href="../../System/types/Int32.html">Int32</a> containing the number of dimensions in the current <b>Type</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> The functionality of this method is unsupported in the base class and must be implemented in a derived class instead.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td> The current <b>Type</b> is not an array.</td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
using System;

class MyArrayRankSample
{
   public static void Main()
   {
      try
      {
         int[,,] myArray = new int[,,] {{{12,2,35},{300,78,33}},{{92,42,135},{30,7,3}}};
         Type myType = myArray.GetType();

         Console.WriteLine("Contents of myArray: {{{12,2,35},{300,78,33}},{{92,42,135},{30,7,3}}}");
         Console.WriteLine("The rank for myArray is: {0}", myType.GetArrayRank());
      }
      catch(NotSupportedException e)
      {
         Console.WriteLine("NotSupportedException raised.");
         Console.WriteLine("Source: " + e.Source);
         Console.WriteLine("Message: " + e.Message);
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception raised.");
         Console.WriteLine("Source: " + e.Source);
         Console.WriteLine("Message: " + e.Message);
      }      
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/Array.html">Array</a> |  <a href="../../System/types/Array.html#Rank">Array.Rank</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="GetAttributeFlagsImplTopic1"></a><a name="GetAttributeFlagsImpl">GetAttributeFlagsImpl</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns the implementation attribute flags.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected override <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> GetAttributeFlagsImpl();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns the implementation attribute flags.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetConstructorTopic1"></a><a name="GetConstructor(System.Type[])">GetConstructor</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetConstructor(System.Type[])">System.Type.GetConstructor</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for a public instance constructor whose parameters match the types in the specified array.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> GetConstructor(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the constructor to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> to get a constructor that takes no parameters.</p>
<p> -or- </p>
<p> <a href="#EmptyTypes">Type.EmptyTypes</a>.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the constructor to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> to get a constructor that takes no parameters.</p>
<p> -or- </p>
<p> <a href="#EmptyTypes">Type.EmptyTypes</a>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> object representing the public instance constructor whose parameters match the types in the parameter type array, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>types</i> is <b>null</b>.<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> <a href="#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetConstructor</a> looks for public instance constructors and cannot be used to obtain a class initializer. Class initializers are available through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>,  <a href="#GetConstructors">Type.GetConstructors</a>, and  <a href="#TypeInitializer">Type.TypeInitializer</a>.<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p><br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>

using System;
using System.Reflection;
using System.Security;

public class MyClass1
{
   public MyClass1(){}
   public MyClass1(int i){}

   public static void Main()
   {
      try
      {
         Type myType = typeof(MyClass1);
         Type[] types = new Type[1];
         types[0] = typeof(int);
         // Get the constructor that takes an integer as a parameter.
         ConstructorInfo constructorInfoObj = myType.GetConstructor(types);
         if (constructorInfoObj != null)
         {
            Console.WriteLine("The constructor of the class MyClass1 that takes an " + 
               "integer as a parameter is: "); 
            Console.WriteLine(constructorInfoObj.ToString());
         }
         else
         {
            Console.WriteLine("The constructor of the class MyClass1 that takes an integer " +
               "as a parameter is not available."); 
         }
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception caught.");
         Console.WriteLine("Source: " + e.Source);
         Console.WriteLine("Message: " + e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetConstructorImpl</a> |  <a href="#GetConstructors">Type.GetConstructors</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetConstructorTopic2"></a><a name="GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">GetConstructor</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">System.Type.GetConstructor</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> GetConstructor(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the constructor to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</p>
<p> -or- </p>
<p> <a href="#EmptyTypes">Type.EmptyTypes</a>.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the constructor to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</p>
<p> -or- </p>
<p> <a href="#EmptyTypes">Type.EmptyTypes</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the parameter type array. The default binder does not process this parameter.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> object representing the constructor that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>types</i> is <b>null</b>.<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.<p> -or- </p>
<p><i>modifiers</i> is multidimensional.</p>
<p> -or- </p>
<p><i>types</i> and <i>modifiers</i> do not have the same length.</p>
</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The <i>types</i> array and the <i>modifiers</i> array have the same length. A parameter specified in the <i>types</i> array can have the following attributes, which are specified in the <i>modifiers</i> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.<p> If an exact match does not exist, the <i>binder</i> will attempt to coerce the parameter types specified in the <i>types</i> array in order to select a match. If the <i>binder</i> is unable to select a match, then <b>null</b> is returned.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which constructors to include in the search: </p>
<UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public constructors in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public constructors (that is, private and protected constructors) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static members up the hierarchy.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p> <a href="#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetConstructor</a> cannot be used to obtain a class initializer. Class initializers are available through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>,  <a href="#GetConstructors">Type.GetConstructors</a>, and  <a href="#TypeInitializer">Type.TypeInitializer</a>.<br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
using System;
using System.Reflection;
using System.Security;


public class MyClass1
{
   public MyClass1(int i){}

   public static void Main()
   {
      try
      {
         Type myType = typeof(MyClass1);
         Type[] types = new Type[1];
         types[0] = typeof(int);
         // Get the constructor that is public and takes an integer parameter.
         ConstructorInfo constructorInfoObj = myType.GetConstructor(
            BindingFlags.Instance | BindingFlags.Public, null, types, null);
         if (constructorInfoObj != null )
         {
            Console.WriteLine("The constructor of the MyClass1 class that is public " +
               "and takes an integer as a parameter is:");
            Console.WriteLine(constructorInfoObj.ToString());
         }
         else
         {
            Console.WriteLine("The constructor of the MyClass1 class that is public " +
               "and takes an integer as a parameter is not available.");
         }
      }
      catch(ArgumentNullException e)
      {
         Console.WriteLine("ArgumentNullException: " + e.Message);
      }
      catch(ArgumentException e)
      {
         Console.WriteLine("ArgumentException: " + e.Message);
      }
      catch(SecurityException e)
      {
         Console.WriteLine("SecurityException: " + e.Message);
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception: " + e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="../../System.Reflection/types/Binder.html">Binder</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetConstructorImpl</a> |  <a href="#GetConstructors">Type.GetConstructors</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetConstructorTopic3"></a><a name="GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">GetConstructor</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">System.Type.GetConstructor</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> GetConstructor(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>callConvention</i><br><dl>
<dd>
<param> The  <a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the constructor to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the constructor to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <i>types</i> array. The default binder does not process this parameter.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> object representing the constructor that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>types</i> is <b>null</b>.<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.<p> -or- </p>
<p><i>modifiers</i> is multidimensional.</p>
<p> -or- </p>
<p><i>types</i> and <i>modifiers</i> do not have the same length.</p>
</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Although the default binder does not process  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> (the <i>modifiers</i> parameter), you can use the abstract  <a href="../../System.Reflection/types/Binder.html">Binder</a> class to write a custom binder that does process <i>modifiers</i>.<b>ParameterModifier</b> is only used when calling through COM interop, and only parameters that are passed by reference are handled.<p> The <i>types</i> array and the <i>modifiers</i> array have the same length. A parameter specified in the <i>types</i> array can have the following attributes, which are specified in the <i>modifiers</i> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.</p>
<p> If an exact match does not exist, the <i>binder</i> will attempt to coerce the parameter types specified in the <i>types</i> array in order to select a match. If the <i>binder</i> is unable to select a match, then <b>null</b> is returned.</p>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which constructors to include in the search: </p>
<UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public constructors in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public constructors (that is, private and protected constructors) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static members up the hierarchy.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> <a href="#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetConstructor</a> cannot be used to obtain a class initializer. Class initializers are available through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>,  <a href="#GetConstructors">Type.GetConstructors</a>, and  <a href="#TypeInitializer">Type.TypeInitializer</a>.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
<p> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL><br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
using System;
using System.Reflection;
using System.Security;


public class MyClass1
{
   public MyClass1(int i){}

   public static void Main()
   {
      try
      {
         Type  myType = typeof(MyClass1);
         Type[] types = new Type[1];
         types[0] = typeof(int);
         // Get the constructor that is public, instance method and takes an integer parameter.
         ConstructorInfo constructorInfoObj = myType.GetConstructor(
            BindingFlags.Instance | BindingFlags.Public, null,
            CallingConventions.HasThis, types, null);
         if(constructorInfoObj != null)
         {
            Console.WriteLine("The constructor of the class MyClass1 that is a public " +
               "instance method and takes an integer as a parameter is: ");
            Console.WriteLine(constructorInfoObj.ToString());
         }
         else
         {
            Console.WriteLine("The Constructor of the class 'MyClass1' that is a public instance " +
               "method and takes an integer as a parameter is not available.");
         }
      }
      catch(ArgumentNullException e)
      {
         Console.WriteLine("ArgumentNullException: " + e.Message);
      }
      catch(ArgumentException e)
      {
         Console.WriteLine("ArgumentException: " + e.Message);
      }
      catch(SecurityException e)
      {
         Console.WriteLine("SecurityException: " + e.Message);
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception: " + e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="../../System.Reflection/types/Binder.html">Binder</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetConstructorImpl</a> |  <a href="#GetConstructors">Type.GetConstructors</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="GetConstructorImplTopic1"></a><a name="GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">GetConstructorImpl</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected override <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> GetConstructorImpl(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to conduct a case-sensitive search for public methods.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to conduct a case-sensitive search for public methods.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="../../System/types/Type.html#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="../../System/types/Type.html#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>callConvention</i><br><dl>
<dd>
<param> The  <a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the constructor to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the constructor to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <i>types</i> array.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> object representing the constructor that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not implemented for incomplete type.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetConstructorsTopic1"></a><a name="GetConstructors">GetConstructors</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetConstructors">System.Type.GetConstructors</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns all the public constructors defined for the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo[]</a> GetConstructors();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> objects representing all the public constructors defined for the current  <a href="../../System/types/Type.html">Type</a>, including the type initializer if it is defined.<p> -or- </p>
<p> An empty array of type  <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a>, if no public constructors are defined for the current  <a href="../../System/types/Type.html">Type</a>.</p>
</dd>
</dl><b>Remarks</b><dl>
<dd> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.<br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
<p> This method calls <a href="../../System/types/Type.html#getconstructorstopic2">GetConstructors</a>. It will not find static constructors unless you explicitly pass <b>BindingFlags.Static</b>, as shown in the examples.</p>
<p> Class initializers are available through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>, and  <a href="#GetConstructors">Type.GetConstructors</a>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> This example shows the output of <b>GetConstructors()</b> from a class that has two instance constructors and one static constructor.<pre>
 using System;
 using System.Reflection;
 
 public class t {
     public t() {}
     static t() {}
     public t(int i) {}
 
     public static void Main() {
         ConstructorInfo[] p = typeof(t).GetConstructors();
         Console.WriteLine(p.Length);
 
         for (int i=0;i&lt;p.Length;i++) {
             Console.WriteLine(p[i].IsStatic);
         }
     }
 }

    </pre>
<p> The output of this code is: </p>
<p> 2 </p>
<p> False </p>
<p> False </p>
<p> Because <b>GetConstructors</b> () only calls the Public and Instance <b>BindingFlags</b>, the static constructor is neither counted by the <b>for</b> expression nor evaluated by <b>IsStatic</b>.</p>
<p> Use <b>GetConstructors</b> (BindingFlags) and pass it <b>BindingFlags.Public</b> | <b>BindingFlags.Static</b> | <b>BindingFlags.NonPublic</b> | <b>BindingFlags.Instance</b> to find static constructors, as follows: </p>
<pre>
 using System;
 using System.Reflection;
  
 public class t {
     public t() {}
     static t() {}
     public t(int i) {}
 
     public static void Main() {
         ConstructorInfo[] p = typeof(t).GetConstructors(
            BindingFlags.Public | BindingFlags.Static |
            BindingFlags.NonPublic | BindingFlags.Instance);
         Console.WriteLine(p.Length);
 
         for (int i=0;i&lt;p.Length;i++) {
             Console.WriteLine(p[i].IsStatic);
         }
     }
 }

    </pre>
<p> Now the output is: </p>
<p> 3 </p>
<p> False </p>
<p> True </p>
<p> False </p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> |  <a href="#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetConstructor</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetConstructorsTopic2"></a><a name="GetConstructors(System.Reflection.BindingFlags)">GetConstructors</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns an array of  <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> objects representing the public and non-public constructors defined for this class, as specified.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo[]</a> GetConstructors(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> This must be a bit flag from  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> as in <b>InvokeMethod</b>, <b>NonPublic</b>, and so on.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns an array of  <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> objects representing the specified constructors defined for this class. If no constructors are defined, an empty array is returned.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not implemented for incomplete types.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a><b>TypeInformation</b> required for non-public members.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetCustomAttributesTopic1"></a><a name="GetCustomAttributes(System.Boolean)">GetCustomAttributes</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>inherit</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns all the custom attributes defined for this type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Object.html">object[]</a> GetCustomAttributes(<br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>inherit</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>inherit</i><br><dl>
<dd>
<param> Specifies whether to search this member's inheritance chain to find the attributes.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns an array of objects representing all the custom attributes of this type.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not currently supported for incomplete types. Retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> and call  <a href="../../System.Reflection/types/MemberInfo.html#GetCustomAttributes(System.Boolean)">MemberInfo.GetCustomAttributes</a> on the returned  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/ICustomAttributeProvider.html#GetCustomAttributes(System.Boolean)">ICustomAttributeProvider.GetCustomAttributes</a></dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetCustomAttributesTopic2"></a><a name="GetCustomAttributes(System.Type,System.Boolean)">GetCustomAttributes</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>attributeType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>inherit</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Checks if the specified custom attribute type is defined.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Object.html">object[]</a> GetCustomAttributes(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>attributeType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>inherit</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>attributeType</i><br><dl>
<dd>
<param> The  <a href="../../System/types/Type.html">Type</a> object to which the custom attributes are applied.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>inherit</i><br><dl>
<dd>
<param> Specifies whether to search this member's inheritance chain to find the attributes.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if one or more instance of <i>attributeType</i> is defined on this member; otherwise, <b>false</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not currently supported for incomplete types. Retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> and call  <a href="../../System.Reflection/types/MemberInfo.html#GetCustomAttributes(System.Boolean)">MemberInfo.GetCustomAttributes</a> on the returned  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/ICustomAttributeProvider.html#GetCustomAttributes(System.Type,System.Boolean)">ICustomAttributeProvider.GetCustomAttributes</a></dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetDefaultMembersTopic1"></a><a name="GetDefaultMembers">GetDefaultMembers</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetDefaultMembers">System.Type.GetDefaultMembers</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the members defined for the current  <a href="../../System/types/Type.html">Type</a> whose  <a href="../../System.Reflection/types/DefaultMemberAttribute.html">DefaultMemberAttribute</a> is set.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo[]</a> GetDefaultMembers();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> objects representing all default members of the current  <a href="../../System/types/Type.html">Type</a>.<p> -or- </p>
<p> An empty array of type  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a>, if the current  <a href="../../System/types/Type.html">Type</a> does not have default members.</p>
</dd>
</dl><b>Remarks</b><dl>
<dd> This method can be overridden by a derived class.<p> Members include properties, methods, fields, events, and so on.</p>
<p> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>

using System;
using System.Reflection;
using System.IO;

[DefaultMemberAttribute("Age")]   
public class MyClass
{
   public void Name(String s) {}
      public int Age
      {
      get
         {
	 return 20;
	 }
      }
   public static void Main()
   {
      try
      {
         Type  myType = typeof(MyClass);
         MemberInfo[] memberInfoArray = myType.GetDefaultMembers();
         if (memberInfoArray.Length &gt; 0)
         {
            Console.WriteLine("The default members of the class MyClass are:\n"); 
               foreach(MemberInfo memberInfoObj in memberInfoArray)
               {
                  Console.WriteLine("The default member name is: " + memberInfoObj.ToString());
               }
         }
         else
         {
         Console.WriteLine("No default members are available."); 
         }
      }
      catch(InvalidOperationException e)
      {
         Console.WriteLine("InvalidOperationException: " + e.Message);
      }
      catch(IOException e)
      {
         Console.WriteLine("IOException: " + e.Message);
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception: " + e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> |  <a href="../../System.Reflection/types/DefaultMemberAttribute.html">DefaultMemberAttribute</a> |  <a href="#GetMember(System.String)">Type.GetMember</a> |  <a href="#GetMembers">Type.GetMembers</a> |  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="GetElementTypeTopic1"></a><a name="GetElementType">GetElementType</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Calling this method always throws  <a href="../../System/types/NotSupportedException.html">NotSupportedException</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Type.html">Type</a> GetElementType();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> This method is not supported. No value is returned.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not supported.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetEventTopic1"></a><a name="GetEvent(System.String)">GetEvent</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetEvent(System.String)">System.Type.GetEvent</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns the  <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> object representing the specified event.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> GetEvent(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of an event which is declared or inherited by the current  <a href="../../System/types/Type.html">Type</a>.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The  <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> object representing the specified event which is declared or inherited by the current  <a href="../../System/types/Type.html">Type</a>, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
<p> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
			Type myType = typeof(System.Windows.Forms.Button);
         EventInfo myEvent = myType.GetEvent("Click");
         if(myEvent != null)
         {
            Console.WriteLine("Looking for Click event in Button class.");
            Console.WriteLine(myEvent.ToString());
         }
         else
            Console.WriteLine("The Click event is not available with Button class");

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="#GetEvents">Type.GetEvents</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetEventTopic2"></a><a name="GetEvent(System.String,System.Reflection.BindingFlags)">GetEvent</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns the event with the specified name.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> GetEvent(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The name of the event to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> This invocation attribute. This must be a bit flag from  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a>: <b>InvokeMethod</b>, <b>NonPublic</b>, and so on.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns an  <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> object representing the event declared or inherited by this type with the specified name. If there are no matches, then an empty array is returned.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not implemented for incomplete types.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetEventsTopic1"></a><a name="GetEvents">GetEvents</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns the events for the public events declared or inherited by this type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Reflection/types/EventInfo.html">EventInfo[]</a> GetEvents();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns an array of  <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> objects representing the public events declared or inherited by this type. An empty array is returned if there are no public events.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not implemented for incomplete types.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetEventsTopic2"></a><a name="GetEvents(System.Reflection.BindingFlags)">GetEvents</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns the public and non-public events that are declared by this type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Reflection/types/EventInfo.html">EventInfo[]</a> GetEvents(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> This must be a bit flag from  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a>, as in <b>InvokeMethod</b>, <b>NonPublic</b>, and so on.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns an array of  <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> objects representing the public and non-public events declared or inherited by this type. An empty array is returned if there are no events, as specified.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not implemented for incomplete types.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a><b>TypeInformation</b> required for non-public members </dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetFieldTopic1"></a><a name="GetField(System.String)">GetField</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetField(System.String)">System.Type.GetField</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the field with the specified name.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo</a> GetField(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the data field to get.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo</a> object representing the field with the specified name, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
public class MyFieldClassA
{
	public string field = "A Field";
	public string Field
	{
		get
		{
			return field;
		}
		set
		{
			if(field!=value)
			{
				field=value;
         }
		}
	}
}
public class MyFieldClassB
{
	public string field = "B Field";
	public string Field 
	{
		get
		{
			return field;
		}
		set
		{
			if(field!=value)
			{
				field=value;
			}
		}
	}
}

public class MyFieldInfoClass
{
	public static void Main()
	{
		try
		{
			MyFieldClassB myFieldObjectB = new MyFieldClassB();
			MyFieldClassA myFieldObjectA = new MyFieldClassA();

			Type myTypeA = Type.GetType("MyFieldClassA");
			FieldInfo myFieldInfo = myTypeA.GetField("field");
		
			Type myTypeB = Type.GetType("MyFieldClassB");
			FieldInfo myFieldInfo1 = myTypeB.GetField("field", BindingFlags.Public | BindingFlags.Instance);

			Console.WriteLine("The value of the field is : {0} ", myFieldInfo.GetValue(myFieldObjectA));
			Console.WriteLine("The value of the field is : {0} ", myFieldInfo1.GetValue(myFieldObjectB));
		}
		catch(SecurityException e)
		{
			Console.WriteLine("Exception Raised !");
			Console.WriteLine("Message :"+e.Message);
		}
		catch(ArgumentNullException e)
		{
			Console.WriteLine("Exception Raised !");
			Console.WriteLine("Message :"+e.Message);
		}
		catch(Exception e)
		{
			Console.WriteLine("Exception Raised !");
			Console.WriteLine("Message :"+e.Message);
		}
	}
}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetFields">Type.GetFields</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetFieldTopic2"></a><a name="GetField(System.String,System.Reflection.BindingFlags)">GetField</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns the field specified by the given name.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo</a> GetField(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The name of the field to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> This must be a bit flag from  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> as in <b>InvokeMethod</b>, <b>NonPublic</b>, and so on.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns the  <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo</a> object representing the field declared or inherited by this type with the specified name and public or non-public modifier. If there are no matches then <b>null</b> is returned.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not implemented for incomplete types.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#GetField(System.String,System.Reflection.BindingFlags)">IReflect.GetField</a></dd>
</dl><b>Remarks</b><dl>
<dd> Retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a><b>TypeInformation</b> required for non-public members.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetFieldsTopic1"></a><a name="GetFields">GetFields</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetFields">System.Type.GetFields</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns all the public fields of the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo[]</a> GetFields();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo</a> objects representing all the public fields defined for the current  <a href="../../System/types/Type.html">Type</a>.<p> -or- </p>
<p> An empty array of type  <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo</a>, if no public fields are defined for the current  <a href="../../System/types/Type.html">Type</a>.</p>
</dd>
</dl><b>Remarks</b><dl>
<dd> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.<br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
			Console.WriteLine("HashCode of the System.Windows.Forms.Button type is  : {0}",
            typeof(System.Windows.Forms.Button).GetHashCode());

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo</a> |  <a href="#GetField(System.String,System.Reflection.BindingFlags)">Type.GetField</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetFieldsTopic2"></a><a name="GetFields(System.Reflection.BindingFlags)">GetFields</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns the public and non-public fields that are declared by this type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo[]</a> GetFields(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> This must be a bit flag from  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a>: <b>InvokeMethod</b>, <b>NonPublic</b>, and so on.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns an array of  <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo</a> objects representing the public and non-public fields declared or inherited by this type. An empty array is returned if there are no fields, as specified.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not implemented for incomplete types.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#GetFields(System.Reflection.BindingFlags)">IReflect.GetFields</a></dd>
</dl><b>Remarks</b><dl>
<dd> Retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a><b>TypeInformation</b> required for non-public members </dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetHashCodeTopic1"></a><a name="GetHashCode">GetHashCode</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetHashCode">System.Type.GetHashCode</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns the hash code for this instance.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Int32.html">int</a> GetHashCode();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An  <a href="../../System/types/Int32.html">Int32</a> containing the hash code for this instance.</dd>
</dl><b>Remarks</b><dl>
<dd> This method overrides  <a href="../../System/types/Object.html#GetHashCode">Object.GetHashCode</a>.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
			Console.WriteLine("HashCode of the System.Windows.Forms.Button type is  : {0}",
            typeof(System.Windows.Forms.Button).GetHashCode());

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetInterfaceTopic1"></a><a name="GetInterface(System.String)">GetInterface</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetInterface(System.String)">System.Type.GetInterface</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the interface with the specified name.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Type.html">Type</a> GetInterface(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the interface to get.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System/types/Type.html">Type</a> object representing the interface with the specified name, implemented or inherited by the current  <a href="../../System/types/Type.html">Type</a>, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/TargetInvocationException.html">TargetInvocationException</a></td>
<td> A static initializer is invoked and throws an exception.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
    public static void Main()
    {
        Hashtable hashtableObj = new Hashtable();
        Type objType = hashtableObj.GetType();
        MemberInfo[] arrayMemberInfo;
        MethodInfo[] arrayMethodInfo;
        try
        {   
            // Get the methods implemented in 'IDeserializationCallback' interface.
            arrayMethodInfo =objType.GetInterface("IDeserializationCallback").GetMethods();
            Console.WriteLine ("\nMethods of 'IDeserializationCallback' Interface :");
            for(int index=0;index &lt; arrayMethodInfo.Length ;index++)
                Console.WriteLine (arrayMethodInfo[index].ToString() ); 

            // Get FullName for interface by using Ignore case search.
            Console.WriteLine ("\nMethods of 'IEnumerable' Interface");
            arrayMethodInfo = objType.GetInterface("ienumerable",true).GetMethods();
            for(int index=0;index &lt; arrayMethodInfo.Length ;index++)
               Console.WriteLine (arrayMethodInfo[index].ToString()); 
           
            //Get the Interface methods for 'IDictionary' interface
            InterfaceMapping interfaceMappingObj;
            interfaceMappingObj = objType.GetInterfaceMap(typeof(IDictionary));
            arrayMemberInfo = interfaceMappingObj.InterfaceMethods;
            Console.WriteLine ("\nHashtable class Implements the following IDictionary Interface methods :");
            for(int index=0; index &lt; arrayMemberInfo.Length; index++)
                Console.WriteLine (arrayMemberInfo[index].ToString() ); 
        }
        catch (Exception e)
        {
            Console.WriteLine ("Exception : " + e.ToString());            
        }                 
    }

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/String.html">String</a> |  <a href="#GetInterfaces">Type.GetInterfaces</a> |  <a href="#FindInterfaces(System.Reflection.TypeFilter,System.Object)">Type.FindInterfaces</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetInterfaceTopic2"></a><a name="GetInterface(System.String,System.Boolean)">GetInterface</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>ignoreCase</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns the interface implemented (directly or indirectly) by this class with the fully-qualified name matching the given interface name.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Type.html">Type</a> GetInterface(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>ignoreCase</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The name of the interface.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>ignoreCase</i><br><dl>
<dd>
<param> If true, the search is case-insensitive. If false, the search is case-sensitive.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns a  <a href="../../System/types/Type.html">Type</a> object representing the implemented interface. Returns null if no interface matching name is found.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not implemented for incomplete types.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="GetInterfaceMapTopic1"></a><a name="GetInterfaceMap(System.Type)">GetInterfaceMap</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>interfaceType</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns an interface mapping for the requested interface.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Reflection/types/InterfaceMapping.html">InterfaceMapping</a> GetInterfaceMap(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>interfaceType</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>interfaceType</i><br><dl>
<dd>
<param> The  <a href="../../System/types/Type.html">Type</a> of the interface for which the mapping is to be retrieved.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns the requested interface mapping.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not implemented for incomplete types.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="GetInterfacesTopic1"></a><a name="GetInterfaces">GetInterfaces</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns an array of all the interfaces implemented on this a class and its base classes.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Type.html">Type[]</a> GetInterfaces();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns an array of  <a href="../../System/types/Type.html">Type</a> objects representing the implemented interfaces. If none are defined, an empty array is returned.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMemberTopic1"></a><a name="GetMember(System.String)">GetMember</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetMember(System.String)">System.Type.GetMember</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the members with the specified name.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo[]</a> GetMember(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the public members to get.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> objects representing the public members with the specified name, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.<p> Members include properties, methods, fields, events, and so on.</p>
<p> This method searches the current classes and its base classes. Only public methods can be found using this method. If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
<p> Class initializers are available through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>, and  <a href="#GetConstructors">Type.GetConstructors</a>.</p>
<p> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
	public void GetMemberInfo()
	{
		String myString = "GetMember_String";

		Type myType = myString.GetType();
		// Get the members for myString starting with 'C',using searchCriteria 'C*'.
		MemberInfo[] myMembers = myType.GetMember("C*");
      if(myMembers.Length &gt; 0)
      {
         Console.WriteLine("\nThe Member(s) starting with 'C' for type {0} :", myType);
         for(int index=0; index &lt; myMembers.Length; index++)
            Console.WriteLine("Member {0} : {1}", index + 1, myMembers[index].ToString());
      }
      else
            Console.WriteLine("No Members match the Search Criteria.");    
	}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMembers">Type.GetMembers</a> |  <a href="#GetDefaultMembers">Type.GetDefaultMembers</a> |  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMemberTopic2"></a><a name="GetMember(System.String,System.Reflection.BindingFlags)">GetMember</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetMember(System.String,System.Reflection.BindingFlags)">System.Type.GetMember</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified members, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo[]</a> GetMember(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the members to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> objects representing the public members with the specified name, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#GetMember(System.String,System.Reflection.BindingFlags)">IReflect.GetMember</a></dd>
</dl><b>Remarks</b><dl>
<dd> This method can be overridden by a derived class.<p> Members include properties, methods, fields, events, and so on.</p>
<p> This method searches the current classes and its base classes. If the requested member is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which members to include in the search: </p>
<UL>
<li><i>Instance</i> to include instance members in the search.</li>
<li><i>Static</i> to include static members in the search.</li>
<li><i>Public</i> to include public members in the search.</li>
<li><i>NonPublic</i> to include non-public members (that is, private and protected members) in the search.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><i>IgnoreCase</i> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <i>IgnoreCase</i> flag.</li>
<li><i>DeclaredOnly</i> to search only the members declared on the  <a href="../../System/types/Type.html">Type</a>, not members that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> Class initializers are available through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>, and  <a href="#GetConstructors">Type.GetConstructors</a>.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
	public void GetPublicStaticMemberInfo()
	{
		String myString = "GetMember_String_BindingFlag";

		Type myType = myString.GetType();
      // Get the Public Static members for the class myString starting with 'C'.
		MemberInfo[] myMembers = myType.GetMember("C*",
                                 BindingFlags.Public |BindingFlags.Static);

      if(myMembers.Length &gt; 0)
      {
         Console.WriteLine("\nThe Public Static Member(s)  starting with 'C' for type {0} :",myType);
         for(int index=0; index &lt; myMembers.Length; index++)
            Console.WriteLine("Member {0} : {1}", index + 1, myMembers[index].ToString());
      }
      else
         Console.WriteLine("No Members match the Search Criteria.");    
	}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMembers">Type.GetMembers</a> |  <a href="#GetDefaultMembers">Type.GetDefaultMembers</a> |  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMemberTopic3"></a><a name="GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">GetMember</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/MemberTypes.html">MemberTypes</a> <i>type</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns all the public and non-public members declared or inherited by this type, as specified.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo[]</a> GetMember(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/MemberTypes.html">MemberTypes</a> <i>type</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The name of the member.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>type</i><br><dl>
<dd>
<param> The type of the member to return.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> This must be a bit flag from  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a>, as in <b>InvokeMethod</b>, <b>NonPublic</b>, and so on.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns an array of  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> objects representing the public and non-public members defined on this type if <i>nonPublic</i> is used; otherwise, only the public members are returned.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not implemented for incomplete types.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMembersTopic1"></a><a name="GetMembers">GetMembers</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetMembers">System.Type.GetMembers</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns all the public members of the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo[]</a> GetMembers();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> objects representing all the public members of the current  <a href="../../System/types/Type.html">Type</a>.<p> -or- </p>
<p> An empty array of type  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a>, if the current  <a href="../../System/types/Type.html">Type</a> does not have public members.</p>
</dd>
</dl><b>Remarks</b><dl>
<dd> Members include properties, methods, fields, events, and so on.<p> Class initializers are available through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>, and  <a href="#GetConstructors">Type.GetConstructors</a>.</p>
<p> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
class MyClass
{
   public int myInt = 0;
   public string myString = null;

   public MyClass()
   {
   }
   public void Myfunction()
   {
   }
}

class Type_GetMembers
{
   public static void Main()
   {
      try
      {
         MyClass myObject = new MyClass();
         MemberInfo[] myMemberInfo; 

         // Get the type of 'MyClass'.
         Type myType = myObject.GetType(); 
        
         // Get the information related to all public member's of 'MyClass'. 
         myMemberInfo = myType.GetMembers();
    
         Console.WriteLine( "\nThe members of class '{0}' are :\n", myType); 
         for (int i =0 ; i &lt; myMemberInfo.Length ; i++)
         {
            // Display name and type of the concerned member.
            Console.WriteLine( "'{0}' is a {1}", myMemberInfo[i].Name, myMemberInfo[i].MemberType);
         }
      }
      catch(SecurityException e)
      {
         Console.WriteLine("Exception : " + e.Message ); 
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> |  <a href="#GetMember(System.String)">Type.GetMember</a> |  <a href="#GetDefaultMembers">Type.GetDefaultMembers</a> |  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMembersTopic2"></a><a name="GetMembers(System.Reflection.BindingFlags)">GetMembers</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns the members for the public and non-public members declared or inherited by this type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo[]</a> GetMembers(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> This must be a bit flag from  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a>, such as <b>InvokeMethod</b>, <b>NonPublic</b>, and so on.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns an array of  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> objects representing the public and non-public members declared or inherited by this type. An empty array is returned if there are no matching members.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not implemented for incomplete types.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#GetMembers(System.Reflection.BindingFlags)">IReflect.GetMembers</a></dd>
</dl><b>Remarks</b><dl>
<dd> Retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a><b>TypeInformation</b> required for non-public members </dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMethodTopic1"></a><a name="GetMethod(System.String)">GetMethod</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetMethod(System.String)">System.Type.GetMethod</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the public method with the specified name.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> GetMethod(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the public method to get.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> object representing the public method with the specified name, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one method is found with the specified name.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p><br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
class MyClass
{
   public int myInt = 0;
   public string myString = null;

   public MyClass()
   {
   }
   public void Myfunction(int i)
   {
   } 
}
class Type_GetMethod
{
   public static void Main()
   {
      try
      {         
         MyClass MyObject = new MyClass();
         MethodInfo myMethodInfo; 

         // Get the type of the class 'MyClass'.
         Type myType = MyObject.GetType(); 
        
         // Get the method information for a method named 'MyFunction'. 
         myMethodInfo = myType.GetMethod("Myfunction");
         
         // Get the parameters for the method 'Myfunction'.
         ParameterInfo[] myParameters = myMethodInfo.GetParameters();
    
         Console.WriteLine( "\nThe parameters of the method 'Myfunction' of class 'MyClass' are :\n"); 
         
         // Display the position and type of the parameters.
         for(int i = 0; i &lt; myParameters.Length; i++)
            Console.WriteLine("The parameter {0} is of type {1}", 
               myParameters[i].Position + 1, myParameters[i].ParameterType);
      }
      catch (SecurityException e)
      {
         Console.WriteLine("SecurityException : " + e.Message ); 
      }
      catch (Exception e)
      {
         Console.WriteLine("Exception : " + e.Message ); 
      }      
   }
}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetMethodImpl</a> |  <a href="#GetMethods">Type.GetMethods</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMethodTopic2"></a><a name="GetMethod(System.String,System.Reflection.BindingFlags)">GetMethod</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetMethod(System.String,System.Reflection.BindingFlags)">System.Type.GetMethod</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified method, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> GetMethod(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the method to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> object representing the method that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one method is found with the specified name and matching the specified binding constraints.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#GetMethod(System.String,System.Reflection.BindingFlags)">IReflect.GetMethod</a></dd>
</dl><b>Remarks</b><dl>
<dd> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which methods to include in the search: <UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public methods in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public methods (that is, private and protected members) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static methods up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.IgnoreCase</b> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <b>IgnoreCase</b> flag.</li>
<li><b>BindingFlags.DeclaredOnly</b> to search only the methods declared on the  <a href="../../System/types/Type.html">Type</a>, not methods that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p><br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
class MyClass
{
   public void MyMethod()
   {    
   }
}

public class Type_GetMethod
{
   public static void Main()
   {
      try
      {
         // Get the type of 'MyClass'.
         Type myType = typeof(MyClass);
         
         // Get the method information of the type 'MyClass'.
         MethodInfo myMethodInfo = myType.GetMethod("MyMethod",
            BindingFlags.Public|BindingFlags.Instance );
         
         // Displays the member info to the console.
         Console.WriteLine("\nThe signature of 'MyMethod' is : {0}", myMethodInfo.ToString());
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception : {0}", e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetMethodImpl</a> |  <a href="#GetMethods">Type.GetMethods</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMethodTopic3"></a><a name="GetMethod(System.String,System.Type[])">GetMethod</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetMethod(System.String,System.Type[])">System.Type.GetMethod</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified public method whose parameters match the specified argument types.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> GetMethod(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the public method to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the method to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the method to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> object representing the public method whose parameters match the specified argument types, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one method is found with the specified name and specified parameters.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p> -or- </p>
<p><i>types</i> is <b>null</b>.</p>
<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.<p> -or- </p>
<p><i>modifiers</i> is multidimensional.</p>
<p> -or- </p>
<p><i>types</i> and <i>modifiers</i> do not have the same length.</p>
</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p><br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
            // Get a 'Type' object corresponding to 'MyClass1' class.
            Type myClassType = typeof(MyClass1);
            // Create a Type array.
            Type[] typeArray =new Type[1];
            typeArray.SetValue(typeof(int),0);
            // Find the method matching the specified argument types.
            MethodInfo myMethodInfo = 
                        myClassType.GetMethod("MyMethod",typeArray);
            Console.WriteLine("The Name of the Method :"+myMethodInfo);

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetMethodImpl</a> |  <a href="#GetMethods">Type.GetMethods</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMethodTopic4"></a><a name="GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">GetMethod</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">System.Type.GetMethod</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified public method whose parameters match the specified argument types and modifiers.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> GetMethod(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the public method to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the method to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the method to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <i>types</i> array. The default binder does not process this parameter.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> object representing the public method that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one method is found with the specified name and specified parameters.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p> -or- </p>
<p><i>types</i> is <b>null</b>.</p>
<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.<p> -or- </p>
<p><i>modifiers</i> is multidimensional.</p>
<p> -or- </p>
<p><i>types</i> and <i>modifiers</i> do not have the same length.</p>
</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Although the default binder does not process  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> (the <i>modifiers</i> parameter), you can use the abstract  <a href="../../System.Reflection/types/Binder.html">Binder</a> class to write a custom binder that does process <i>modifiers</i>.<b>ParameterModifier</b> is only used when calling through COM interop, and only parameters that are passed by reference are handled.<p> The <i>types</i> array and the <i>modifiers</i> array have the same length. A parameter specified in the <i>types</i> array can have the following attributes, which are specified in the <i>modifiers</i> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and are used for interoperability.</p>
<p> The search for <i>name</i> is case-sensitive.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p><br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetMethodImpl</a> |  <a href="#GetMethods">Type.GetMethods</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMethodTopic5"></a><a name="GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">GetMethod</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">System.Type.GetMethod</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> GetMethod(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the method to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the method to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the method to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <i>types</i> array. The default binder does not process this parameter.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> object representing the method that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one method is found with the specified name and matching the specified binding constraints.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p> -or- </p>
<p><i>types</i> is <b>null</b>.</p>
<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.<p> -or- </p>
<p><i>modifiers</i> is multidimensional.</p>
<p> -or- </p>
<p><i>types</i> and <i>modifiers</i> do not have the same length.</p>
</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">IReflect.GetMethod</a></dd>
</dl><b>Remarks</b><dl>
<dd> Although the default binder does not process  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> (the <i>modifiers</i> parameter), you can use the abstract  <a href="../../System.Reflection/types/Binder.html">Binder</a> class to write a custom binder that does process <i>modifiers</i>.<b>ParameterModifier</b> is only used when calling through COM interop, and only parameters that are passed by reference are handled.<p> The <i>types</i> array and the <i>modifiers</i> array have the same length. A parameter specified in the <i>types</i> array can have the following attributes, which are specified in the <i>modifiers</i> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.</p>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which methods to include in the search: </p>
<UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public methods in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public methods (that is, private and protected members) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static methods up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.IgnoreCase</b> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <b>IgnoreCase</b> flag.</li>
<li><b>BindingFlags.DeclaredOnly</b> to search only the methods declared on the  <a href="../../System/types/Type.html">Type</a>, not methods that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p><br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
public class MyClass
{
   public int i = 10;
   public string k = "My Field";
   public int MyMethod(int i)
   {
      this.i = i;
      return i;
   }
   public string MyMethod(string k)
   {
      this.k = k;
      return k;
   }
}
public class Type_GetMethod
{
   public static void Main()
   {
      try
      {
         // Get the type of the class 'MyClass'.
         Type myType = typeof(MyClass);

         // Get the attributes of the method and the metadata of the method 'MyMethod'.
         MethodInfo myMethodInfo = myType.GetMethod("MyMethod", 
            BindingFlags.Public | BindingFlags.Instance, null, 
            new Type[] {typeof(int)}, null);
         
         Console.WriteLine("\n Declaring type of the method '{0}' is : \n '{1}'", myMethodInfo,
            myMethodInfo.DeclaringType);
         
         // Get the attributes of the method and the metadata of the method 'MyMethod'.
         MethodInfo myMethodInfo1 = myType.GetMethod("MyMethod", 
            BindingFlags.Public | BindingFlags.Instance, null, 
            new Type[] {typeof(string)}, null);
         
         Console.WriteLine("\n Declaring type of the method '{0}' is : \n '{1}'", myMethodInfo1,
            myMethodInfo1.DeclaringType);
         
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception : {0}", e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="../../System.Reflection/types/Binder.html">Binder</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetMethodImpl</a> |  <a href="#GetMethods">Type.GetMethods</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMethodTopic6"></a><a name="GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">GetMethod</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">System.Type.GetMethod</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> GetMethod(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the method to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>callConvention</i><br><dl>
<dd>
<param> The  <a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the method to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the method to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <i>types</i> array. The default binder does not process this parameter.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> object representing the method that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one method is found with the specified name and matching the specified binding constraints.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p> -or- </p>
<p><i>types</i> is <b>null</b>.</p>
<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.<p> -or- </p>
<p><i>modifiers</i> is multidimensional.</p>
<p> -or- </p>
<p><i>types</i> and <i>modifiers</i> do not have the same length.</p>
</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Although the default binder does not process  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> (the <i>modifiers</i> parameter), you can use the abstract  <a href="../../System.Reflection/types/Binder.html">Binder</a> class to write a custom binder that does process <i>modifiers</i>.<b>ParameterModifier</b> is only used when calling through COM interop, and only parameters that are passed by reference are handled.<p> The following table shows what members of a base class are returned by the <b>GetXXX</b> methods when reflecting on a type.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
<p> The <i>types</i> array and the <i>modifiers</i> array have the same length. A parameter specified in the <i>types</i> array can have the following attributes, which are specified in the <i>modifiers</i> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.</p>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which methods to include in the search: </p>
<UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public methods in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public methods (that is, private and protected members) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static methods up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.IgnoreCase</b> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <b>IgnoreCase</b> flag.</li>
<li><b>BindingFlags.DeclaredOnly</b> to search only the methods declared on the  <a href="../../System/types/Type.html">Type</a>, not methods that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p><br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>

public class MyClass
{
   public int i = 10;
   public int j = 2;
   
   public int MyFunc(int i , int j)
   {
      int k;
      k = i * 10 - j;
      return k;
   }
}
public class Type_GetMethod
{
   public static void Main()
   {
      try
      {
         // Get the type of the class 'MyClass'.
         Type myType = typeof(MyClass);

         // Get the method information of 'MyFunc(int , int )'.
         MemberInfo myMemberInfo = myType.GetMethod("MyFunc", BindingFlags.Public |
                                                         BindingFlags.Instance, 
                                                         null, 
                                                         CallingConventions.Any,  
                                                         new Type[] {typeof(int),typeof(int)}, 
                                                         null);
         
         Console.WriteLine("\nDisplaying method 'MyFunc' : \n");
         
         // Print the method information to the console.
         Console.WriteLine("{0}", myMemberInfo);
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception : {0}", e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="../../System.Reflection/types/Binder.html">Binder</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetMethodImpl</a> |  <a href="#GetMethods">Type.GetMethods</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="GetMethodImplTopic1"></a><a name="GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">GetMethodImpl</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected override <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> GetMethodImpl(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the method to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to conduct a case-sensitive search for public methods.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to conduct a case-sensitive search for public methods.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="../../System/types/Type.html#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="../../System/types/Type.html#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>callConvention</i><br><dl>
<dd>
<param> The  <a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the method to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the method to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <i>types</i> array.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> object representing the method that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not implemented for incomplete types.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMethodsTopic1"></a><a name="GetMethods">GetMethods</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetMethods">System.Type.GetMethods</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns all the public methods of the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo[]</a> GetMethods();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> objects representing all the public methods defined for the current  <a href="../../System/types/Type.html">Type</a>.<p> -or- </p>
<p> An empty array of type  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a>, if no public methods are defined for the current  <a href="../../System/types/Type.html">Type</a>.</p>
</dd>
</dl><b>Remarks</b><dl>
<dd> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.<br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL><br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> |  <a href="#GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetMethod</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMethodsTopic2"></a><a name="GetMethods(System.Reflection.BindingFlags)">GetMethods</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns all the public and non-public methods declared or inherited by this type, as specified.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo[]</a> GetMethods(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> This must be a bit flag from  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> as in <b>InvokeMethod</b>, <b>NonPublic</b>, and so on.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns an array of  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> objects representing the public and non-public methods defined on this type if <i>nonPublic</i> is used; otherwise, only the public methods are returned.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not implemented for incomplete types.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#GetMethods(System.Reflection.BindingFlags)">IReflect.GetMethods</a></dd>
</dl><b>Remarks</b><dl>
<dd> Retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a><b>TypeInformation</b> required for non-public members </dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetNestedTypeTopic1"></a><a name="GetNestedType(System.String)">GetNestedType</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetNestedType(System.String)">System.Type.GetNestedType</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the nested type with the specified name.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Type.html">Type</a> GetNestedType(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the nested type to get.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System/types/Type.html">Type</a> object representing the nested type with the specified name, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.<p> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="#GetNestedTypes">Type.GetNestedTypes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetNestedTypeTopic2"></a><a name="GetNestedType(System.String,System.Reflection.BindingFlags)">GetNestedType</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns the public and non-public nested types that are declared by this type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Type.html">Type</a> GetNestedType(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the nested type to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to conduct a case-sensitive search for public methods.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to conduct a case-sensitive search for public methods.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System/types/Type.html">Type</a> object representing the nested type that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not implemented for incomplete types.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.<p> If this type is complete, for example, if <b>CreateType</b> has been called on this type, but there are nested types that are not complete, then <b>GetNestedTypes</b> will only return those nested types for which <b>CreateType</b> has been called.</p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetNestedTypesTopic1"></a><a name="GetNestedTypes">GetNestedTypes</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetNestedTypes">System.Type.GetNestedTypes</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns all the types nested within the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Type.html">Type[]</a> GetNestedTypes();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System/types/Type.html">Type</a> objects representing all the types nested within the current  <a href="../../System/types/Type.html">Type</a>.<p> -or- </p> An empty array of type  <a href="../../System/types/Type.html">Type</a>, if no types are nested within the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl><b>Remarks</b><dl>
<dd> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.<br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
                  // Get Type Object corresponding to MyClass.
                  Type myType=typeof(MyClass);
                  // Get array of nested type objects which are in 'MyClass'.                 
                  Type[] nestType=myType.GetNestedTypes();
                  Console.WriteLine("Number of nested types are {0}",nestType.Length);
                  foreach(Type t in nestType)
                     Console.WriteLine("Nested type is {0}",t.ToString());

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#GetNestedType(System.String)">Type.GetNestedType</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetNestedTypesTopic2"></a><a name="GetNestedTypes(System.Reflection.BindingFlags)">GetNestedTypes</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns the public and non-public nested types that are declared or inherited by this type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Type.html">Type[]</a> GetNestedTypes(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> This must be a bit flag from  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a>, as in <b>InvokeMethod</b>, <b>NonPublic</b>, and so on.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System/types/Type.html">Type</a> objects representing all the types nested within the current  <a href="../../System/types/Type.html">Type</a> that match the specified binding constraints.<p> An empty array of type  <a href="../../System/types/Type.html">Type</a>, if no types are nested within the current  <a href="../../System/types/Type.html">Type</a>, or if none of the nested types match the binding constraints.</p>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not implemented for incomplete types.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.<p> If this type is complete, for example, if <b>CreateType</b> has been called on this type, but there are nested types that are not complete, then <b>GetNestedTypes</b> will only return those nested types for which <b>CreateType</b> has been called.</p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetPropertiesTopic1"></a><a name="GetProperties">GetProperties</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetProperties">System.Type.GetProperties</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns all the public properties of the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo[]</a> GetProperties();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> objects representing all public properties of the current  <a href="../../System/types/Type.html">Type</a>.<p> -or- </p>
<p> An empty array of type  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a>, if the current  <a href="../../System/types/Type.html">Type</a> does not have public properties.</p>
</dd>
</dl><b>Remarks</b><dl>
<dd> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.<br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
				PropertyInfo[] myPropertyInfo;
				// Get the properties of 'Type' class object.
				myPropertyInfo = Type.GetType("System.Type").GetProperties();
				Console.WriteLine("Properties of System.Type are:");
            for (int i = 0; i &lt; myPropertyInfo.Length; i++)
				{
					Console.WriteLine(myPropertyInfo[i].ToString());
				}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> |  <a href="#GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">Type.GetProperty</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetPropertiesTopic2"></a><a name="GetProperties(System.Reflection.BindingFlags)">GetProperties</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns all the public and non-public properties declared or inherited by this type, as specified.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo[]</a> GetProperties(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> This invocation attribute. This must be a bit flag from  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a>: <b>InvokeMethod</b>, <b>NonPublic</b>, and so on.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns an array of <b>PropertyInfo</b> objects representing the public and non-public properties defined on this type if <i>nonPublic</i> is used; otherwise, only the public properties are returned.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not implemented for incomplete types.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#GetProperties(System.Reflection.BindingFlags)">IReflect.GetProperties</a></dd>
</dl><b>Remarks</b><dl>
<dd> Retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetPropertyTopic1"></a><a name="GetProperty(System.String)">GetProperty</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetProperty(System.String)">System.Type.GetProperty</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the public property with the specified name.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> GetProperty(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the public property to get.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> object representing the public property with the specified name, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one property is found with the specified name.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> Different languages use different syntax to specify default or parameterized properties.<pre>
            // Get Type Object corresponding to MyClass.
            Type myType=typeof(MyClass);       
            // Get PropertyInfo object by passing property name.
            PropertyInfo myPropInfo = myType.GetProperty("MyProperty");
            // Display Name propety to console.
            Console.WriteLine("The Property {0} exists",myPropInfo.Name);
            }

    </pre>
<p> Internally, this property is referred to by the name "Item" in the metadata. Therefore, any attempt to get <b>PropertyInfo</b> using reflection must specify this internal name in order for the <b>PropertyInfo</b> to be returned correctly.</p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">Type.GetPropertyImpl</a> |  <a href="#GetProperties(System.Reflection.BindingFlags)">Type.GetProperties</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetPropertyTopic2"></a><a name="GetProperty(System.String,System.Reflection.BindingFlags)">GetProperty</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetProperty(System.String,System.Reflection.BindingFlags)">System.Type.GetProperty</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified property, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> GetProperty(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the property to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> object representing the property that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one property is found with the specified name and matching the specified binding constraints.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#GetProperty(System.String,System.Reflection.BindingFlags)">IReflect.GetProperty</a></dd>
</dl><b>Remarks</b><dl>
<dd> The <i>types</i> array and the <i>modifiers</i> array have the same length. A parameter specified in the <i>types</i> array can have the following attributes, which are specified in the <i>modifiers</i> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which properties to include in the search: </p>
<UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public properties in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public properties (that is, private and protected properties ) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static properties up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.IgnoreCase</b> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <b>IgnoreCase</b> flag.</li>
<li><b>BindingFlags.DeclaredOnly</b> to search only the properties declared on the  <a href="../../System/types/Type.html">Type</a>, not properties that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> Different languages use different syntax to specify default or parameterized properties.<pre>
            // Get Type Object corresponding to MyClass.
            Type myType=typeof(MyClass);       
            // Get PropertyInfo object by passing property name and specifying BindingFlags.
            PropertyInfo myPropInfo = myType.GetProperty("MyProperty",
                                                   BindingFlags.Public|
                                                   BindingFlags.Instance);
            // Display Name propety to console.
            Console.WriteLine("{0} is a Property of 'MyClass'.",myPropInfo.Name);
            }

    </pre>
<p> Internally, this property is referred to by the name "Item" in the metadata. Therefore, any attempt to get <b>PropertyInfo</b> using reflection must specify this internal name in order for the <b>PropertyInfo</b> to be returned correctly.</p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">Type.GetPropertyImpl</a> |  <a href="#GetProperties(System.Reflection.BindingFlags)">Type.GetProperties</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetPropertyTopic3"></a><a name="GetProperty(System.String,System.Type)">GetProperty</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetProperty(System.String,System.Type)">System.Type.GetProperty</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the public property with the specified name and return type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> GetProperty(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the public property to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>returnType</i><br><dl>
<dd>
<param> The return type of the property.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> object representing the public property with the specified name, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one property is found with the specified name.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> Different languages use different syntax to specify default or parameterized properties.<pre>
			Type myType = typeof(MyClass1);
		
			// Get the 'PropertyInfo' object representing 'MyProperty1' property. 
			PropertyInfo myStringProperties1 = myType.GetProperty("MyProperty1",
				typeof(string));
			Console.WriteLine("The Name of the first Property of MyClass1 :"+myStringProperties1.Name);
			Console.WriteLine("The Type of first Property of MyClass1 :"+myStringProperties1.PropertyType);

			// Get a 'Type' array  corresponding to the indexed  property.
			Type[] myTypeArr = new Type[2];
			myTypeArr.SetValue(typeof(int),0);            
			myTypeArr.SetValue(typeof(int),1);

			// Get the 'PropertyInfo' object representing 'MyProperty2' property. 
			PropertyInfo myStringProperties2 =myType.GetProperty("Item",typeof(int),myTypeArr);
			Console.WriteLine("{0} property exists in MyClass1.",myStringProperties2.ToString());
			Console.WriteLine("The Name of the second Property of MyClass1 :"+myStringProperties2.Name);
			Console.WriteLine("The Type of second Property of MyClass1 :"+myStringProperties2.PropertyType);

    </pre>
<p> Internally, this property is referred to by the name "Item" in the metadata. Therefore, any attempt to get <b>PropertyInfo</b> using reflection must specify this internal name in order for the <b>PropertyInfo</b> to be returned correctly.</p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">Type.GetPropertyImpl</a> |  <a href="#GetProperties(System.Reflection.BindingFlags)">Type.GetProperties</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetPropertyTopic4"></a><a name="GetProperty(System.String,System.Type[])">GetProperty</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetProperty(System.String,System.Type[])">System.Type.GetProperty</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified public property whose parameters match the specified argument types.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> GetProperty(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the public property to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> object representing the public property whose parameters match the specified argument types, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one property is found with the specified name and matching the specified argument types.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p> -or- </p>
<p><i>types</i> is <b>null</b>.</p>
<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> Different languages use different syntax to specify default or parameterized properties.<pre>
				// Get Type Object.
				Type myType=typeof(MyClass1);       
				Type[] myTypeArr = new Type[2];
				// Initialize Type array.
				myTypeArr.SetValue(typeof(int),0);            
				myTypeArr.SetValue(typeof(int),1);
				// Get PropertyInfo object for indexed property 'Item' which has two integer parameters. 
				PropertyInfo myPropInfo = myType.GetProperty("Item",myTypeArr);
				// Dispaly propety to console.
				Console.WriteLine("{0} property exists in MyClass1.",myPropInfo.ToString());

    </pre>
<p> Internally, this property is referred to by the name "Item" in the metadata. Therefore, any attempt to get <b>PropertyInfo</b> using reflection must specify this internal name in order for the <b>PropertyInfo</b> to be returned correctly.</p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">Type.GetPropertyImpl</a> |  <a href="#GetProperties(System.Reflection.BindingFlags)">Type.GetProperties</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetPropertyTopic5"></a><a name="GetProperty(System.String,System.Type,System.Type[])">GetProperty</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetProperty(System.String,System.Type,System.Type[])">System.Type.GetProperty</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified public property whose parameters match the specified argument types.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> GetProperty(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the public property to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>returnType</i><br><dl>
<dd>
<param> The return type of the property.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> object representing the public property whose parameters match the specified argument types, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one property is found with the specified name and matching the specified argument types.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p> -or- </p>
<p><i>types</i> is <b>null</b>.</p>
<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">Type.GetPropertyImpl</a> |  <a href="#GetProperties(System.Reflection.BindingFlags)">Type.GetProperties</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetPropertyTopic6"></a><a name="GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">GetProperty</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">System.Type.GetProperty</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified public property whose parameters match the specified argument types and modifiers.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> GetProperty(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the public property to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>returnType</i><br><dl>
<dd>
<param> The return type of the property.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <i>types</i> array. The default binder does not process this parameter.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> object representing the public property that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one property is found with the specified name and matching the specified argument types and modifiers.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p> -or- </p>
<p><i>types</i> is <b>null</b>.</p>
<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.<p> -or- </p>
<p><i>modifiers</i> is multidimensional.</p>
<p> -or- </p>
<p><i>types</i> and <i>modifiers</i> do not have the same length.</p>
</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Although the default binder does not process  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> (the <i>modifiers</i> parameter), you can use the abstract  <a href="../../System.Reflection/types/Binder.html">Binder</a> class to write a custom binder that does process <i>modifiers</i>.<b>ParameterModifier</b> is only used when calling through COM interop, and only parameters that are passed by reference are handled.<p> The <i>types</i> array and the <i>modifiers</i> array have the same length. A parameter specified in the <i>types</i> array can have the following attributes, which are specified in the <i>modifiers</i> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.</p>
<p> The search for <i>name</i> is case-sensitive.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> Different languages use different syntax to specify default or parameterized properties.<pre>
// MyPropAA - ReadOnly
protected short m_prvPropAA = -1;
public short m_PropAA = -2;
public short this [Boolean nonPublic]
{
    //get accessor for property {short MyPropAA}
    get {
        return ((nonPublic) ? m_prvPropAA: m_PropAA);
    }
}

    </pre>
<p> Internally, this property is referred to by the name "Item" in the metadata. Therefore, any attempt to get <b>PropertyInfo</b> using reflection must specify this internal name in order for the <b>PropertyInfo</b> to be returned correctly.</p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">Type.GetPropertyImpl</a> |  <a href="#GetProperties(System.Reflection.BindingFlags)">Type.GetProperties</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetPropertyTopic7"></a><a name="GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">GetProperty</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">System.Type.GetProperty</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> GetProperty(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the property to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>returnType</i><br><dl>
<dd>
<param> The return type of the property.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <i>types</i> array. The default binder does not process this parameter.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> object representing the property that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one property is found with the specified name and matching the specified binding constraints.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p> -or- </p>
<p><i>types</i> is <b>null</b>.</p>
<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.<p> -or- </p>
<p><i>modifiers</i> is multidimensional.</p>
<p> -or- </p>
<p><i>types</i> and <i>modifiers</i> do not have the same length.</p>
</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">IReflect.GetProperty</a></dd>
</dl><b>Remarks</b><dl>
<dd> Although the default binder does not process  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> (the <i>modifiers</i> parameter), you can use the abstract  <a href="../../System.Reflection/types/Binder.html">Binder</a> class to write a custom binder that does process <i>modifiers</i>.<b>ParameterModifier</b> is only used when calling through COM interop, and only parameters that are passed by reference are handled.<p> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
<p> The <i>types</i> array and the <i>modifiers</i> array have the same length. A parameter specified in the <i>types</i> array can have the following attributes, which are specified in the <i>modifiers</i> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.</p>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which properties to include in the search: </p>
<UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public properties in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public properties (that is, private and protected properties ) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static properties up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.IgnoreCase</b> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <b>IgnoreCase</b> flag.</li>
<li><b>BindingFlags.DeclaredOnly</b> to search only the properties declared on the  <a href="../../System/types/Type.html">Type</a>, not properties that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> Different languages use different syntax to specify default or parameterized properties.<p></p>
<p> Internally, this property is referred to by the name "Item" in the metadata. Therefore, any attempt to get <b>PropertyInfo</b> using reflection must specify this internal name in order for the <b>PropertyInfo</b> to be returned correctly.</p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="../../System.Reflection/types/Binder.html">Binder</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">Type.GetPropertyImpl</a> |  <a href="#GetProperties(System.Reflection.BindingFlags)">Type.GetProperties</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="GetPropertyImplTopic1"></a><a name="GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">GetPropertyImpl</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected override <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> GetPropertyImpl(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the property to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to conduct a case-sensitive search for public properties.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to conduct a case-sensitive search for public properties.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="../../System/types/Type.html#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="../../System/types/Type.html#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>returnType</i><br><dl>
<dd>
<param> The return type of the property.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <i>types</i> array.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> object representing the property that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not implemented for incomplete types.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetTypeTopic1"></a><a name="GetType">GetType</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#GetType">System.Object.GetType</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Type.html">Type</a> GetType();</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="HasElementTypeImplTopic1"></a><a name="HasElementTypeImpl">HasElementTypeImpl</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Calling this method always throws  <a href="../../System/types/NotSupportedException.html">NotSupportedException</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected override <a href="../../System/types/Boolean.html">bool</a> HasElementTypeImpl();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> This method is not supported. No value is returned.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not supported.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="InvokeMemberTopic1"></a><a name="InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">InvokeMember</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>invokeAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>target</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object[]</a> <i>args</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">System.Type.InvokeMember</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Invokes the specified member, using the specified binding constraints and matching the specified argument list.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Object.html">object</a> InvokeMember(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>invokeAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>target</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object[]</a> <i>args</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the constructor, method, property, or field member to invoke. -or- <p> An empty string ("") to invoke the default member.</p> -or- <p> An empty string ("") to invoke the default member.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>invokeAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted. The access can be one of the <b>BindingFlags</b> such as <b>Public</b>, <b>NonPublic</b>, <b>Private</b>, <b>InvokeMethod</b>, <b>GetField</b>, and so on. The type of lookup need not be specified. If the type of lookup is omitted, <b>BindingFlags.Public</b> | <b>BindingFlags.Instance</b> will apply.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>target</i><br><dl>
<dd>
<param> The  <a href="../../System/types/Object.html">Object</a> on which to invoke the specified member.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>args</i><br><dl>
<dd>
<param> An array containing the arguments to pass to the member to invoke.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An  <a href="../../System/types/Object.html">Object</a> representing the return value of the invoked member.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>invokeAttr</i> contains <i>CreateInstance</i> and <i>typeName</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>args</i> is multidimensional.<p> -or- </p>
<p><i>invokeAttr</i> is not a valid  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> attribute.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains <i>CreateInstance</i> combined with <i>InvokeMethod</i>, <i>GetField</i>, <i>SetField</i>, <i>GetProperty</i>, or <i>SetProperty</i>.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains both <i>GetField</i> and <i>SetField</i>.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains both <i>GetProperty</i> and <i>SetProperty</i>.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains <i>InvokeMethod</i> combined with <i>SetField</i> or <i>SetProperty</i>.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains <i>SetField</i> and <i>args</i> has more than one element.</p>
<p> -or- </p>
<p> This method is called on a COM object and one of the following binding flags was not passed in: <b>BindingFlags.InvokeMethod</b>, <b>BindingFlags.GetProperty</b>, <b>BindingFlags.SetProperty</b>, <b>BindingFlags.PutDispProperty</b>, or <b>BindingFlags.PutRefDispProperty</b>.</p>
<p> -or- </p>
<p> One of the named parameter arrays contains a string that is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/MemberAccessException.html">MemberAccessException</a></td>
<td> The specified member is a class initializer.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/MissingFieldException.html">MissingFieldException</a></td>
<td> The field or property cannot be found.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/MissingMethodException.html">MissingMethodException</a></td>
<td> The method cannot be found.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Security/types/SecurityException.html">SecurityException</a></td>
<td> The specified member is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public members outside the current assembly.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/TargetException.html">TargetException</a></td>
<td> The specified member cannot be invoked on <i>target</i>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one method matches the binding criteria.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which members to include in the search: <UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public members in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public members (that is, private and protected members) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static members up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.IgnoreCase</b> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <b>IgnoreCase</b> flag.</li>
<li><b>BindingFlags.DeclaredOnly</b> to search only the members declared on the  <a href="../../System/types/Type.html">Type</a>, not members that were simply inherited.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> invocation flags can be used to denote what action to take with the member: </p>
<UL>
<li><b>CreateInstance</b> to invoke a constructor.<i>name</i> is ignored. Not valid with other invocation flags.</li>
<li><b>InvokeMethod</b> to invoke a method, but not a constructor or a type initializer. Not valid with <b>SetField</b> or <b>SetProperty</b>.</li>
<li><b>GetField</b> to get the value of a field. Not valid with <b>SetField</b>.</li>
<li><b>SetField</b> to set the value of a field. Not valid with <b>GetField</b>.</li>
<li><b>GetProperty</b> to get a property. Not valid with <b>SetProperty</b>.</li>
<li><b>SetProperty</b> to set a property. Not valid with <b>GetProperty</b>.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> A method will be invoked if the following conditions are true: </p>
<UL>
<li> The number of parameters in the method declaration equals the number of arguments in the <i>args</i> array (unless default arguments are defined on the member), and </li>
<li> The type of each arguments can be converted by the binder to the type of the parameter.</li>
</UL> The binder will find all of the matching methods. These methods are found based upon the type of binding requested ( <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> values <b>InvokeMethod</b>, <b>GetProperty</b>, and so on). The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.<p> After the method is selected, it is invoked. Accessibility is checked at that point. The search may control which set of methods are searched based upon the accessibility attribute associated with the method. The  <a href="../../System.Reflection/types/Binder.html#BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)">Binder.BindToMethod</a> method of the  <a href="../../System.Reflection/types/Binder.html">Binder</a> class is responsible for selecting the method to be invoked. The default binder selects the most specific match.</p>
<p> Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through  <a href="../../System.Reflection/System.Reflection.html">System.Reflection</a> whenever the code is fully trusted.</p>
<p> You can use Type.InvokeMember to set a field to a particular value by specifying BindingFlags.SetField. For example, if you want to set a public instance field named F on class C, and F is a <b>String</b> you can say: </p><code>
              typeof(C).InvokeMember( "F",
              BindingFlags.SetField, null, C, new Object{ "strings new value"}, null, null,
              null );
            </code><p> Now suppose that F is a <b>String[]</b> you can say: </p><code>
              typeof(C).InvokeMember( "F",
              BindingFlags.SetField, null, C, new Object{new String[]{"a","z","c","d"}, null,
              null, null );
            </code><p> which will initialize the field F to this new array. Furthermore you can use Type.InvokeMember to set a position in an array by supplying to the index of the value and then the next value by doing the following: </p><code>
              typeof(C).InvokeMember( "F",
              BindingFlags.SetField, null, C, new Object{1, "b"}, null, null, null );
            </code><p> This will change string "z" in the array that F holds to string "b".</p>
</dd>
</dl><b>Example</b><dl>
<dd> Here are syntax examples using <b>InvokeMember</b> to invoke, get, and set various members.<pre>
using System;
using System.IO;
using System.Reflection;

public class Sample
{
 public void Method()
 {

//Call a static method
 Type t = typeof (TestClass);
 t.InvokeMember ("SayHello", BindingFlags.Public | BindingFlags.InvokeMethod | BindingFlags.Static, null, null, new object [] {});
         
 //Call an instance method
 TestClass c = new TestClass ();
 c.GetType().InvokeMember ("AddUp", BindingFlags.Public | BindingFlags.InvokeMethod, null, c, new object [] {});
 c.GetType().InvokeMember ("AddUp", BindingFlags.Public | BindingFlags.InvokeMethod, null, c, new object [] {});
         
 //Call a method with arguments
 object [] args = new object [] {100.09, 184.45};
 object result;
 result = t.InvokeMember ("ComputeSum", BindingFlags.Public | BindingFlags.InvokeMethod | BindingFlags.Static, null, null, args);
 Console.WriteLine ("{0} + {1} = {2}", args[0], args[1], result);
         
 //Get a field value
 result = t.InvokeMember ("Name", BindingFlags.Public | BindingFlags.GetField, null, c, new object [] {});
 Console.WriteLine ("Name == {0}", result);
         
 //Set a field
 t.InvokeMember ("Name", BindingFlags.Public |BindingFlags.SetField, null, c, new object [] {"NewName"});
 result = t.InvokeMember ("Name", BindingFlags.Public |BindingFlags.GetField, null, c, new object [] {});
 Console.WriteLine ("Name == {0}", result);
         
 //Get an indexed property value
 int  index = 3;
 result = t.InvokeMember ("Item", BindingFlags.Public |BindingFlags.GetProperty , null, c, new object [] {index});
 Console.WriteLine ("Item[{0}] == {1}", index, result);
         
 //Set an indexed property value
 index = 3;
 t.InvokeMember ("Item", BindingFlags.Public |BindingFlags.SetProperty, null, c, new object [] {index, "NewValue"});
 result = t.InvokeMember ("Item", BindingFlags.Public |BindingFlags.GetProperty , null, c, new object [] {index});
 Console.WriteLine ("Item[{0}] == {1}", index, result);
         
 //Get a field or property
 result = t.InvokeMember ("Name", BindingFlags.Public |BindingFlags.GetField | BindingFlags.GetProperty, null, c, new object [] {});
 Console.WriteLine ("Name == {0}", result);
 result = t.InvokeMember ("Value", BindingFlags.Public |BindingFlags.GetField | BindingFlags.GetProperty, null, c, new object [] {});
 Console.WriteLine ("Value == {0}", result);
         
 //Call a method using named arguments
 object[] argValues = new object [] {"Mouse", "Micky"};
 String [] argNames = new String [] {"lastName", "firstName"};
 t.InvokeMember ("PrintName", BindingFlags.Public |BindingFlags.InvokeMethod, null, null, argValues, null, null, argNames);
         
 //Call the default member of a type
 Type t3 = typeof (TestClass2);
 t3.InvokeMember ("", BindingFlags.Public |BindingFlags.InvokeMethod, null, new TestClass2(), new object [] {});
         
 //Invoking a ByRef member
 MethodInfo m = t.GetMethod("Swap");
 args = new object[2];
 args[0] = 1;
 args[1] = 2;
 m.Invoke(new TestClass(),args);
 Console.WriteLine ("{0}, {1}", args[0], args[1]);
 Console.WriteLine ("\r\nPress Return to exit.");
 Console.Read();

 }
}

// Class added so sample will compile
public class TestClass {}

// Class added so sample will compile
public class TestClass2 {}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting members that are not public. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#MemberAccess">ReflectionPermissionFlag.MemberAccess</a></dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/SecurityPermission.html">SecurityPermission</a> to call unmanaged code. Associated enumeration:  <a href="../../System.Security.Permissions/types/SecurityPermissionFlag.html#UnmanagedCode">SecurityPermissionFlag.UnmanagedCode</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/Binder.html">Binder</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Reflection/types/ParameterAttributes.html">ParameterAttributes</a> |  <a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="InvokeMemberTopic2"></a><a name="InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">InvokeMember</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>invokeAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>target</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object[]</a> <i>args</i>,</font><br>   <font color="#008080"><a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> <i>culture</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">System.Type.InvokeMember</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Object.html">object</a> InvokeMember(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>invokeAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>target</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object[]</a> <i>args</i>,</font><br>   <font color="#008080"><a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> <i>culture</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the constructor, method, property, or field member to invoke.<p> -or- </p>
<p> An empty string ("") to invoke the default member.</p> The  <a href="../../System/types/String.html">String</a> containing the name of the constructor, method, property, or field member to invoke.<p> -or- </p>
<p> An empty string ("") to invoke the default member.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>invokeAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted. The access can be one of the <b>BindingFlags</b> such as <b>Public</b>, <b>NonPublic</b>, <b>Private</b>, <b>InvokeMethod</b>, <b>GetField</b>, and so on. The type of lookup need not be specified. If the type of lookup is omitted, <b>BindingFlags.Public</b> | <b>BindingFlags.Instance</b> will apply.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>target</i><br><dl>
<dd>
<param> The  <a href="../../System/types/Object.html">Object</a> on which to invoke the specified member.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>args</i><br><dl>
<dd>
<param> An array containing the arguments to pass to the member to invoke.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>culture</i><br><dl>
<dd>
<param> The  <a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.<p> -or- </p>
<p><b>null</b> to use the current thread's  <a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a>.</p> The  <a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.<p> -or- </p>
<p><b>null</b> to use the current thread's  <a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An  <a href="../../System/types/Object.html">Object</a> representing the return value of the invoked member.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>invokeAttr</i> contains <i>CreateInstance</i> and <i>typeName</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>args</i> is multidimensional.<p> -or- </p>
<p><i>invokeAttr</i> is not a valid  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> attribute.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains <i>CreateInstance</i> combined with <i>InvokeMethod</i>, <i>GetField</i>, <i>SetField</i>, <i>GetProperty</i>, or <i>SetProperty</i>.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains both <i>GetField</i> and <i>SetField</i>.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains both <i>GetProperty</i> and <i>SetProperty</i>.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains <i>InvokeMethod</i> combined with <i>SetField</i> or <i>SetProperty</i>.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains <i>SetField</i> and <i>args</i> has more than one element.</p>
<p> -or- </p>
<p> This method is called on a COM object and one of the following binding flags was not passed in: <b>BindingFlags.InvokeMethod</b>, <b>BindingFlags.GetProperty</b>, <b>BindingFlags.SetProperty</b>, <b>BindingFlags.PutDispProperty</b>, or <b>BindingFlags.PutRefDispProperty</b>.</p>
<p> -or- </p>
<p> One of the named parameter arrays contains a string that is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/MemberAccessException.html">MemberAccessException</a></td>
<td> The specified member is a class initializer.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/MissingFieldException.html">MissingFieldException</a></td>
<td> The field or property cannot be found.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/MissingMethodException.html">MissingMethodException</a></td>
<td> The method cannot be found.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Security/types/SecurityException.html">SecurityException</a></td>
<td> The specified member is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public members outside the current assembly.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/TargetException.html">TargetException</a></td>
<td> The specified member cannot be invoked on <i>target</i>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one method matches the binding criteria.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Although the default binder does not process  <a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> (the <i>culture</i> parameter), you can use the abstract  <a href="../../System.Reflection/types/Binder.html">Binder</a> class to write a custom binder that does process <i>culture</i>.<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which members to include in the search: </p>
<UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public members in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public members (that is, private and protected members) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static members up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.IgnoreCase</b> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <b>IgnoreCase</b> flag.</li>
<li><b>BindingFlags.DeclaredOnly</b> to search only the members declared on the  <a href="../../System/types/Type.html">Type</a>, not members that were simply inherited.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> invocation flags can be used to denote what action to take with the member: </p>
<UL>
<li><b>CreateInstance</b> to invoke a constructor.<i>name</i> is ignored. Not valid with other invocation flags.</li>
<li><b>InvokeMethod</b> to invoke a method, but not a constructor or a type initializer. Not valid with <b>SetField</b> or <b>SetProperty</b>.</li>
<li><b>GetField</b> to get the value of a field. Not valid with <b>SetField</b>.</li>
<li><b>SetField</b> to set the value of a field. Not valid with <b>GetField</b>.</li>
<li><b>GetProperty</b> to get a property. Not valid with <b>SetProperty</b>.</li>
<li><b>SetProperty</b> to set a property. Not valid with <b>GetProperty</b>.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> A method will be invoked if the following conditions are true: </p>
<UL>
<li> The number of parameters in the method declaration equals the number of arguments in the <i>args</i> array (unless default arguments are defined on the member).</li>
<li> The type of each arguments can be converted by the binder to the type of the parameter.</li>
</UL> The binder will find all of the matching methods. These methods are found based upon the type of binding requested ( <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> values <b>InvokeMethod</b>, <b>GetProperty</b>, and so on). The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.<p> After the method is selected, it is invoked. Accessibility is checked at that point. The search may control which set of methods are searched based upon the accessibility attribute associated with the method. The  <a href="../../System.Reflection/types/Binder.html#BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)">Binder.BindToMethod</a> method of the  <a href="../../System.Reflection/types/Binder.html">Binder</a> class is responsible for selecting the method to be invoked. The default binder selects the most specific match.</p>
<p> Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through Reflection whenever the code is fully trusted.</p>
<p> You can use Type.InvokeMember to set a field to a particular value by specifying BindingFlags.SetField. For example, if you want to set a public instance field named F on class C, and F is a <b>String</b> you can say: </p><code>
              typeof(C).InvokeMember( "F",
              BindingFlags.SetField, null, C, new Object{ "strings new value"}, null, null,
              null );
            </code><p> Now suppose that F is a <b>String[]</b> you can say: </p><code>
              typeof(C).InvokeMember( "F",
              BindingFlags.SetField, null, C, new Object{new String[]{"a","z","c","d"}, null,
              null, null );
            </code><p> which will initialize the field F to this new array. Furthermore you can use Type.InvokeMember to set a position in an array by supplying to the index of the value and then the next value by doing the following: </p><code>
              typeof(C).InvokeMember( "F",
              BindingFlags.SetField, null, C, new Object{1, "b"}, null, null, null );
            </code><p> This will change string "z" in the array that F holds to string "b".</p>
</dd>
</dl><b>Example</b><dl>
<dd> Here are syntax examples using <b>InvokeMember</b> to invoke, get, and set various members.<pre>
using System;
using System.IO;
using System.Reflection;

public class Sample
{
 public void Method()
 {

//Call a static method
 Type t = typeof (TestClass);
 t.InvokeMember ("SayHello", BindingFlags.Public | BindingFlags.InvokeMethod | BindingFlags.Static, null, null, new object [] {});
         
 //Call an instance method
 TestClass c = new TestClass ();
 c.GetType().InvokeMember ("AddUp", BindingFlags.Public | BindingFlags.InvokeMethod, null, c, new object [] {});
 c.GetType().InvokeMember ("AddUp", BindingFlags.Public | BindingFlags.InvokeMethod, null, c, new object [] {});
         
 //Call a method with arguments
 object [] args = new object [] {100.09, 184.45};
 object result;
 result = t.InvokeMember ("ComputeSum", BindingFlags.Public | BindingFlags.InvokeMethod | BindingFlags.Static, null, null, args);
 Console.WriteLine ("{0} + {1} = {2}", args[0], args[1], result);
         
 //Get a field value
 result = t.InvokeMember ("Name", BindingFlags.Public | BindingFlags.GetField, null, c, new object [] {});
 Console.WriteLine ("Name == {0}", result);
         
 //Set a field
 t.InvokeMember ("Name", BindingFlags.Public |BindingFlags.SetField, null, c, new object [] {"NewName"});
 result = t.InvokeMember ("Name", BindingFlags.Public |BindingFlags.GetField, null, c, new object [] {});
 Console.WriteLine ("Name == {0}", result);
         
 //Get an indexed property value
 int  index = 3;
 result = t.InvokeMember ("Item", BindingFlags.Public |BindingFlags.GetProperty , null, c, new object [] {index});
 Console.WriteLine ("Item[{0}] == {1}", index, result);
         
 //Set an indexed property value
 index = 3;
 t.InvokeMember ("Item", BindingFlags.Public |BindingFlags.SetProperty, null, c, new object [] {index, "NewValue"});
 result = t.InvokeMember ("Item", BindingFlags.Public |BindingFlags.GetProperty , null, c, new object [] {index});
 Console.WriteLine ("Item[{0}] == {1}", index, result);
         
 //Get a field or property
 result = t.InvokeMember ("Name", BindingFlags.Public |BindingFlags.GetField | BindingFlags.GetProperty, null, c, new object [] {});
 Console.WriteLine ("Name == {0}", result);
 result = t.InvokeMember ("Value", BindingFlags.Public |BindingFlags.GetField | BindingFlags.GetProperty, null, c, new object [] {});
 Console.WriteLine ("Value == {0}", result);
         
 //Call a method using named arguments
 object[] argValues = new object [] {"Mouse", "Micky"};
 String [] argNames = new String [] {"lastName", "firstName"};
 t.InvokeMember ("PrintName", BindingFlags.Public |BindingFlags.InvokeMethod, null, null, argValues, null, null, argNames);
         
 //Call the default member of a type
 Type t3 = typeof (TestClass2);
 t3.InvokeMember ("", BindingFlags.Public |BindingFlags.InvokeMethod, null, new TestClass2(), new object [] {});
         
 //Invoking a ByRef member
 MethodInfo m = t.GetMethod("Swap");
 args = new object[2];
 args[0] = 1;
 args[1] = 2;
 m.Invoke(new TestClass(),args);
 Console.WriteLine ("{0}, {1}", args[0], args[1]);
 Console.WriteLine ("\r\nPress Return to exit.");
 Console.Read();

 }
}

// Class added so sample will compile
public class TestClass {}

// Class added so sample will compile
public class TestClass2 {}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting members that are not public. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#MemberAccess">ReflectionPermissionFlag.MemberAccess</a></dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/SecurityPermission.html">SecurityPermission</a> to call unmanaged code. Associated enumeration:  <a href="../../System.Security.Permissions/types/SecurityPermissionFlag.html#UnmanagedCode">SecurityPermissionFlag.UnmanagedCode</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/Binder.html">Binder</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Reflection/types/ParameterAttributes.html">ParameterAttributes</a> |  <a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="InvokeMemberTopic3"></a><a name="InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">InvokeMember</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>invokeAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>target</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object[]</a> <i>args</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i>,</font><br>   <font color="#008080"><a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> <i>culture</i>,</font><br>   <font color="#008080"><a href="../../System/types/String.html">string[]</a> <i>namedParameters</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Invokes the specified member. The method that is to be invoked must be accessible and provide the most specific match with the specified argument list, under the contraints of the specified binder and invocation attributes.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Object.html">object</a> InvokeMember(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>invokeAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>target</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object[]</a> <i>args</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i>,</font><br>   <font color="#008080"><a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> <i>culture</i>,</font><br>   <font color="#008080"><a href="../../System/types/String.html">string[]</a> <i>namedParameters</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The name of the member to invoke. This can be a constructor, method, property, or field. A suitable invocation attribute must be specified. Note that it is possible to invoke the default member of a class by passing an empty string as the name of the member.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>invokeAttr</i><br><dl>
<dd>
<param> The invocation attribute. This must be a bit flag from <b>BindingFlags</b>.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <b>MemberInfo</b> objects using reflection. If binder is <b>null</b>, the default binder is used. See  <a href="../../System.Reflection/types/Binder.html">Binder</a>.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>target</i><br><dl>
<dd>
<param> The object on which to invoke the specified member. If the member is static, this parameter is ignored.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>args</i><br><dl>
<dd>
<param> An argument list. This is an array of Objects that contains the number, order, and type of the parameters of the member to be invoked. If there are no parameters this should be null.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of the same length as args with elements that represent the attributes associated with the arguments of the member to be invoked. A parameter has attributes associated with it in the metadata. They are used by various interoperability services. See the metadata specs for more details.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>culture</i><br><dl>
<dd>
<param> An instance of <b>CultureInfo</b> used to govern the coercion of types. If this is null, the <b>CultureInfo</b> for the current thread is used. (Note that this is necessary to, for example, convert a String that represents 1000 to a Double value, since 1000 is represented differently by different cultures.) 
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>namedParameters</i><br><dl>
<dd>
<param> Each parameter in the <i>namedParameters</i> array gets the value in the corresponding element in the <i>args</i> array. If the length of <i>args</i> is greater than the length of <i>namedParameters</i>, the remaining argument values are passed in order.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns the return value of the invoked member.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not currently supported for incomplete types.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">IReflect.InvokeMember</a></dd>
</dl><b>Remarks</b><dl>
<dd> A method will be invoked if the number of parameters in the method declaration equals the number of arguments in the specified argument list, and the type of each argument can be converted by the binder to the type of the parameter.<p> The binder will find all of the matching methods. These methods are found based on the type of binding requested (BindingFlags.InvokeMethod, BindingFlags.GetProperties, and so on.). The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder. After the method is selected, it will be invoked. Accessibility is checked at that point. The search can control which set of methods are searched based upon the accessibility attribute associated with the method. The <b>IBinder.BindToMethod</b> method is responsible for selecting the method to be invoked. The default binder selects the most specific match.</p><br><br><b>Note </b> Access restrictions are ignored for fully-trusted code. That is, private constructors, methods, fields, and properties can be accessed and invoked using Reflection whenever the code is fully-trusted. This method is not currently supported. You can retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="IsArrayImplTopic1"></a><a name="IsArrayImpl">IsArrayImpl</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Always returns <b>false</b>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected override <a href="../../System/types/Boolean.html">bool</a> IsArrayImpl();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns <b>false</b>.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="IsAssignableFromTopic1"></a><a name="IsAssignableFrom(System.Type)">IsAssignableFrom</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>c</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Determines whether an instance of the current  <a href="../../System/types/Type.html">Type</a> can be assigned from an instance of the specified <b>Type</b>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Boolean.html">bool</a> IsAssignableFrom(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>c</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>c</i><br><dl>
<dd>
<param> The <b>Type</b> to compare with the current <b>Type</b>.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the <i>c</i> parameter and the current  <a href="../../System/types/Type.html">Type</a> represent the same type, or if the current <b>Type</b> is in the inheritance hierarchy of <i>c</i>, or if the current <b>Type</b> is an interface that <i>c</i> supports.<b>false</b> if none of these conditions are the case, or if <i>c</i> is a null reference (not set or empty).</dd>
</dl><b>Remarks</b><dl>
<dd> This method can be overridden by a derived class.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="IsByRefImplTopic1"></a><a name="IsByRefImpl">IsByRefImpl</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Always returns <b>false</b>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected override <a href="../../System/types/Boolean.html">bool</a> IsByRefImpl();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Always <b>false</b>.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="IsCOMObjectImplTopic1"></a><a name="IsCOMObjectImpl">IsCOMObjectImpl</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Checks if this type imports a COM type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected override <a href="../../System/types/Boolean.html">bool</a> IsCOMObjectImpl();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns <b>true</b> if this type imports a COM type; otherwise, <b>false</b>.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="IsContextfulImplTopic1"></a><a name="IsContextfulImpl">IsContextfulImpl</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsContextfulImpl">System.Type.IsContextfulImpl</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Implements the  <a href="#IsContextful">Type.IsContextful</a> property and determines whether the  <a href="../../System/types/Type.html">Type</a> can be hosted in a context.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected virtual <a href="../../System/types/Boolean.html">bool</a> IsContextfulImpl();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the  <a href="../../System/types/Type.html">Type</a> can be hosted in a context; otherwise, <b>false</b>.</dd>
</dl><b>Remarks</b><dl>
<dd> This method can be overridden by a derived class.<p> A context intercepts calls to the class members and enforce policies that are applied to the class, such as synchronization.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
public class MyTypeDelegatorClass : TypeDelegator
{
   public string myElementType = null;
   private Type myType = null ; 

   public MyTypeDelegatorClass(Type myType) : base(myType)
   {
      this.myType = myType;
   }

   // Override 'IsContextfulImpl' method of 'Type' class.
   protected override bool IsContextfulImpl()
   {
      // Check whether the type is contextful.
      if(myType.IsContextful)
      { 
         myElementType = " is contextful ";
         return true;
      }
      return false;
   }
}

public class MyTypeDemoClass
{
   public static void Main()
   {
      try
      {
         MyTypeDelegatorClass myType;
         Console.WriteLine ("Check whether 'MyContextBoundClass' can be hosted in a context.");
         // Check if 'MyContextBoundClass' type is contextful.
         myType = new MyTypeDelegatorClass(typeof(MyContextBoundClass));
         if( myType.IsContextful)
         {
            Console.WriteLine(typeof(MyContextBoundClass) + " can be hosted in a context.");
         }
         else
         {
            Console.WriteLine(typeof(MyContextBoundClass) + " cannot be hosted in a context.");
         }

         // Check if 'int' type is contextful.
         myType = new MyTypeDelegatorClass(typeof(MyTypeDemoClass));
         Console.WriteLine ("\nCheck whether 'MyTypeDemoClass' can be hosted in a context.");
         if( myType.IsContextful)
         {
            Console.WriteLine(typeof(MyTypeDemoClass) + " can be hosted in a context.");
         }
         else
         {
            Console.WriteLine(typeof(MyTypeDemoClass) + " cannot be hosted in a context.");
         }
      }
      catch( Exception e )
      {
         Console.WriteLine("Exception: {0}", e.Message);
      }
   }
}

// This class is used to demonstrate 'IsContextfulImpl' method.
public class MyContextBoundClass : ContextBoundObject
{
   public string myString = "This class is used to demonstrate members of the 'Type' class.";
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#IsContextful">Type.IsContextful</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="IsDefinedTopic1"></a><a name="IsDefined(System.Type,System.Boolean)">IsDefined</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>attributeType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>inherit</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Set a custom attribute using a custom attribute builder.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Boolean.html">bool</a> IsDefined(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>attributeType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>inherit</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>attributeType</i><br><dl>
<dd>
<param> The <b>Type</b> object to which the custom attributes are applied.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>inherit</i><br><dl>
<dd>
<param> Specifies whether to search this member's inheritance chain to find the attributes.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if one or more instance of <i>attributeType</i> is defined on this member; otherwise <b>false</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not currently supported for incomplete types. Retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> and call  <a href="../../System.Reflection/types/MemberInfo.html#IsDefined(System.Type,System.Boolean)">MemberInfo.IsDefined</a> on the returned  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/ICustomAttributeProvider.html#IsDefined(System.Type,System.Boolean)">ICustomAttributeProvider.IsDefined</a></dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="IsInstanceOfTypeTopic1"></a><a name="IsInstanceOfType(System.Object)">IsInstanceOfType</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>o</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsInstanceOfType(System.Object)">System.Type.IsInstanceOfType</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Determines whether the specified object is an instance of the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/Boolean.html">bool</a> IsInstanceOfType(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>o</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>o</i><br><dl>
<dd>
<param> The object to compare with the current <b>Type</b>.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the current <b>Type</b> is in the inheritance hierarchy of the object represented by the <i>o</i> parameter, or if the current Type is an interface that <i>o</i> supports.<b>false</b> if neither of these conditions is the case, or if <i>o</i> is <b>null</b>.</dd>
</dl><b>Remarks</b><dl>
<dd> This method can be overridden by a derived class.</dd>
</dl><b>Example</b><dl>
<dd> The following example demonstrates the use of the <b>IsInstanceOfType</b> method.<pre>
using System;
public interface IMyIfc {}
public class MyClass : IMyIfc {}
public class MyDerivedClass : MyClass {}
class IsInstanceTest 
{
   public static void Main() 
   {
   Type imyifcType=typeof(IMyIfc);
   MyClass mc = new MyClass();
   Type mcType = mc.GetType();
   MyClass mdc = new MyDerivedClass();
   Type mdcType = mdc.GetType();
   int [] array  = new int [10];
   Type arrayType = typeof(Array);
   Console.WriteLine("int[] is instance of Array? {0}", arrayType.IsInstanceOfType(array));
   Console.WriteLine("myclass instance is instance of MyClass? {0}", mcType.IsInstanceOfType(mc));
   Console.WriteLine("myderivedclass instance is instance of MyClass? {0}", mcType.IsInstanceOfType(mdc));
   Console.WriteLine("myclass instance is instance of IMyIfc? {0}", imyifcType.IsInstanceOfType(mc));
   Console.WriteLine("myderivedclass instance is instance of IMyIfc? {0}", imyifcType.IsInstanceOfType(mdc));
   }
}

    </pre>
<p> This code produces the following output: </p>
<pre>
              				int[] is instance of Array? True 
              				myclass instance is instance of MyClass? True 
              				myderivedclass instance is instance of MyClass? True 
              				myclass instance is instance of IMyIfc? True 
              				myderivedclass instance is instance of IMyIfc? True
              			
            </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="IsMarshalByRefImplTopic1"></a><a name="IsMarshalByRefImpl">IsMarshalByRefImpl</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsMarshalByRefImpl">System.Type.IsMarshalByRefImpl</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Implements the  <a href="#IsMarshalByRef">Type.IsMarshalByRef</a> property and determines whether the  <a href="../../System/types/Type.html">Type</a> is marshalled by reference.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected virtual <a href="../../System/types/Boolean.html">bool</a> IsMarshalByRefImpl();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the  <a href="../../System/types/Type.html">Type</a> is marshalled by reference; otherwise, <b>false</b>.</dd>
</dl><b>Remarks</b><dl>
<dd> This method can be overridden by a derived class.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
public class MyTypeDelegatorClass : TypeDelegator
{
   public string myElementType = null;
   private Type myType = null ; 

   public MyTypeDelegatorClass(Type myType) : base(myType)
   {
      this.myType = myType;
   }

   // Override 'IsMarshalByRefImpl' method of 'Type' class.
   protected override bool IsMarshalByRefImpl()
   {
      // Check whether the type is marshalled by reference.
      if(myType.IsMarshalByRef)
      { 
         myElementType = " marshalled by reference";
         return true;
      }
      return false;
   }
}

public class MyTypeDemoClass
{
   public static void Main()
   {
      try
      {
         MyTypeDelegatorClass myType;
         Console.WriteLine ("Check whether 'MyContextBoundClass' is marshalled by reference");
         // Check if 'MyContextBoundClass' type is marshalled by reference.
         myType = new MyTypeDelegatorClass(typeof(MyContextBoundClass));
         if( myType.IsMarshalByRef )
         {
            Console.WriteLine(typeof(MyContextBoundClass) + " is marshalled by reference.");
         }
         else
         {
            Console.WriteLine(typeof(MyContextBoundClass) + " is not marshalled by reference.");
         }

         // Check if 'int' type is marshalled by reference.
         myType = new MyTypeDelegatorClass(typeof(int));
         Console.WriteLine ("\nCheck whether 'int' is marshalled by reference");
         if( myType.IsMarshalByRef)
         {
            Console.WriteLine(typeof(int) + " is marshalled by reference.");
         }
         else
         {
            Console.WriteLine(typeof(int) + " is not marshalled by reference.");
         }
      }
      catch( Exception e )
      {
         Console.WriteLine("Exception: {0}", e.Message);
      }
   }
}
// This class is used to demonstrate 'IsMarshalByRefImpl' method.
public class MyContextBoundClass : ContextBoundObject
{
   public string myString = "This class is used demonstrate members of the 'Type' class.";
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#IsMarshalByRef">Type.IsMarshalByRef</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="IsPointerImplTopic1"></a><a name="IsPointerImpl">IsPointerImpl</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Always returns <b>false</b>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected override <a href="../../System/types/Boolean.html">bool</a> IsPointerImpl();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Always <b>false</b>.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="IsPrimitiveImplTopic1"></a><a name="IsPrimitiveImpl">IsPrimitiveImpl</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Always returns <b>false</b>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected override <a href="../../System/types/Boolean.html">bool</a> IsPrimitiveImpl();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns <b>false</b>.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="IsSubclassOfTopic1"></a><a name="IsSubclassOf(System.Type)">IsSubclassOf</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>c</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Checks if this type is a derived class of the given type <i>c</i>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Boolean.html">bool</a> IsSubclassOf(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>c</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>c</i><br><dl>
<dd>
<param> A  <a href="../../System/types/Type.html">Type</a> that is to be checked 
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Read-only. Returns <b>true</b> if this type is the same as the type <i>c</i>, or is a subtype of type <i>c</i>; otherwise, <b>false</b>.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="IsValueTypeImplTopic1"></a><a name="IsValueTypeImpl">IsValueTypeImpl</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsValueTypeImpl">System.Type.IsValueTypeImpl</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Implements the  <a href="#IsValueType">Type.IsValueType</a> property and determines whether the  <a href="../../System/types/Type.html">Type</a> is a value type; that is, not a class or an interface.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected virtual <a href="../../System/types/Boolean.html">bool</a> IsValueTypeImpl();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the  <a href="../../System/types/Type.html">Type</a> is a value type; otherwise, <b>false</b>.</dd>
</dl><b>Remarks</b><dl>
<dd> Value types describe values that are represented as sequences of bits; value types are not classes or interfaces. These are referred to as "structs" in some programming languages. Enums are value types.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
public class MyTypeDelegator : TypeDelegator
{
   public string myElementType = null;
   private Type myType = null ; 

   public MyTypeDelegator(Type myType) : base(myType)
   {
      this.myType = myType;
   }

   // Override 'IsValueTypeImpl()' method of 'Type' class.
   protected override bool IsValueTypeImpl()
   {
      // Check whether the type is an value type.
      if(myType.IsValueType)
      {
         myElementType = "value";
         return true;
      }
      // The type is not value type.
      return false;
   }  
}
public class Type_IsValueTypeImpl 
{
   public class MyClass
   {
   }
   public static void Main()
   {
      try
      {
         int myInt = 0 ; 
         MyClass myClass = new MyClass ();

         MyTypeDelegator myType = new MyTypeDelegator(myInt.GetType());
         Console.WriteLine("\nCheck whether a variable refers to a value type.\n");
         
         // Check if 'myType' is a value type.  
         if( myType.IsValueType)
            Console.WriteLine("\n'myInt' is a {0} type.", myType.myElementType);
         else
            Console.WriteLine("\n'myInt' is not a value type.");

         myType = new MyTypeDelegator(myClass.GetType());

         // Check if 'myType' is a value type.  
         if( myType.IsValueType)
            Console.WriteLine("\n'myClass' is a {0} type.", myType.myElementType);
         else
            Console.WriteLine("\n'myClass' is not a value type.");

      }
      catch( Exception e )
      {
            Console.WriteLine("\nThe following exception is raised:" +e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsClass">Type.IsClass</a> |  <a href="#IsInterface">Type.IsInterface</a> |  <a href="../../System/types/ValueType.html">ValueType</a> |  <a href="#IsValueType">Type.IsValueType</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="MemberwiseCloneTopic1"></a><a name="MemberwiseClone">MemberwiseClone</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#MemberwiseClone">System.Object.MemberwiseClone</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected <a href="../../System/types/Object.html">object</a> MemberwiseClone();</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="SetCustomAttributeTopic1"></a><a name="SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">SetCustomAttribute</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection.Emit/types/CustomAttributeBuilder.html">CustomAttributeBuilder</a> <i>customBuilder</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Set a custom attribute using a custom attribute builder.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public void SetCustomAttribute(<br>   <font color="#008080"><a href="../../System.Reflection.Emit/types/CustomAttributeBuilder.html">CustomAttributeBuilder</a> <i>customBuilder</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>customBuilder</i><br><dl>
<dd>
<param> An instance of a helper class to define the custom attribute.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>con</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> SecurityAction.Demand, ReflectionEmit </dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="SetCustomAttributeTopic2"></a><a name="SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">SetCustomAttribute</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> <i>con</i>,</font><br>   <font color="#008080"><a href="../../System/types/Byte.html">byte[]</a> <i>binaryAttribute</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Sets a custom attribute using a specified custom attribute blob.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public void SetCustomAttribute(<br>   <font color="#008080"><a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> <i>con</i>,</font><br>   <font color="#008080"><a href="../../System/types/Byte.html">byte[]</a> <i>binaryAttribute</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>con</i><br><dl>
<dd>
<param> The constructor for the custom attribute.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binaryAttribute</i><br><dl>
<dd>
<param> A byte blob representing the attributes.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>con</i> or <i>binaryAttribute</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> See the metadata specifications in the Tool Developers Guide for details on how to format <i>binaryAttribute</i>.</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> SecurityAction.Demand, ReflectionEmit </dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="SetParentTopic1"></a><a name="SetParent(System.Type)">SetParent</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>parent</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Sets the parent of this <b>Type</b>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public void SetParent(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>parent</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>parent</i><br><dl>
<dd>
<param> The parent type.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>parent</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/InvalidOperationException.html">InvalidOperationException</a></td>
<td> if the type was previously created using  <a href="#CreateType">TypeBuilder.CreateType</a>.</td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="ToStringTopic1"></a><a name="ToString">ToString</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns the name of the type excluding the namespace.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/String.html">string</a> ToString();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Read-only. The name of the type excluding the namespace.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite">
<h3 align="center"><a href="#TopOfPage">
					Top of page
				</a></h3><i><a href="../../documentation_license.txt">
				  Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
				</a></i></body>
</html>
