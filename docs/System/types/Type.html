<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../refdoc.css">
<title>Type: System.Type</title>
</head>
<body><a name="TopOfPage"></a><h2>System.Type Class</h2><b>Assembly: </b>Mscorlib.dll<br><b>Namespace: </b>System<br><dl>
<dt><b>Summary</b></dt>
<dd> Represents type declarations: class types, interface types, array types, value types, and enumeration types.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code>[Serializable]<br><b>public abstract class Type : MemberInfo, IReflect</b></code></td>
</tr>
</table>
</dd>
</dl><b>Thread Safety</b><br><dl>
<dd> This type is safe for multithreaded operations.</dd>
</dl><b>Remarks</b><dl>
<dd><b>Type</b> is the root of all reflection operations and the object that represents a type inside the system.<b>Type</b> is an abstract base class that allows multiple implementations. The system will always provide the derived class RuntimeType. In reflection, all classes beginning with the word Runtime are created only once per object in the system and support comparison operations.<br><br><b>Notes to inheritors: </b> When you inherit from <b>Type</b>, you must override the following members:  <a href="#GUID">Type.GUID</a>, <a href="../../System/types/Type.html#invokemembertopic3">InvokeMember</a>,  <a href="#Module">Type.Module</a>,  <a href="#Assembly">Type.Assembly</a>,  <a href="#TypeHandle">Type.TypeHandle</a>,  <a href="#FullName">Type.FullName</a>,  <a href="#Namespace">Type.Namespace</a>,  <a href="#AssemblyQualifiedName">Type.AssemblyQualifiedName</a>,  <a href="#BaseType">Type.BaseType</a>,  <a href="#GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetConstructorImpl</a>, <a href="../../System/types/Type.html#getconstructorstopic2">GetConstructors</a>,  <a href="#GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetMethodImpl</a>, <a href="../../System/types/Type.html#getmethodstopic2">GetMethods</a>, <a href="../../System/types/Type.html#getfieldtopic2">GetField</a>, <a href="../../System/types/Type.html#getfieldstopic2">GetFields</a>, <a href="../../System/types/Type.html#getinterfacetopic2">GetInterface</a>,  <a href="#GetInterfaces">Type.GetInterfaces</a>, <a href="../../System/types/Type.html#geteventtopic2">GetEvent</a>, <a href="../../System/types/Type.html#geteventstopic2">GetEvents</a>,  <a href="#GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">Type.GetPropertyImpl</a>, <a href="../../System/types/Type.html#getpropertiestopic2">GetProperties</a>, <a href="../../System/types/Type.html#getnestedtypetopic2">GetNestedType</a>, <a href="../../System/types/Type.html#getnestedtypestopic2">GetNestedTypes</a>,  <a href="#GetAttributeFlagsImpl">Type.GetAttributeFlagsImpl</a>,  <a href="#IsArrayImpl">Type.IsArrayImpl</a>,  <a href="#IsByRefImpl">Type.IsByRefImpl</a>,  <a href="#IsPointerImpl">Type.IsPointerImpl</a>,  <a href="#IsPrimitiveImpl">Type.IsPrimitiveImpl</a>,  <a href="#IsCOMObjectImpl">Type.IsCOMObjectImpl</a>,  <a href="#GetElementType">Type.GetElementType</a>,  <a href="#HasElementTypeImpl">Type.HasElementTypeImpl</a>,  <a href="#UnderlyingSystemType">Type.UnderlyingSystemType</a>,  <a href="../../System.Reflection/types/MemberInfo.html#Name">MemberInfo.Name</a>,  <a href="../../System.Reflection/types/MemberInfo.html#IsDefined(System.Type,System.Boolean)">MemberInfo.IsDefined</a>, <a href="../../System.Reflection/types/MemberInfo.html#getcustomattributestopic1">System.Reflection.MemberInfo.GetCustomAttributes</a>, and <a href="../../System.Reflection/types/MemberInfo.html#getcustomattributestopic2">System.Reflection.MemberInfo.GetCustomAttributes</a>.<p> This class is the primary way to access metadata, and it acts as a gateway to the Reflection API. Use the members of <b>Type</b> to get information about a type declaration, such as the constructors, methods, fields, properties, and events of a class, as well as the module and the assembly in which the class is deployed.</p>
<p> A <b>Type</b> object that represents a type is unique; that is, two <b>Type</b> object references refer to the same object if and only if they represent the same type. This allows for the synchronization of multiple static method invocations and for comparison of <b>Type</b> objects using reference equality.</p>
<p> This class is thread safe; multiple threads can concurrently read from or write to an instance of this type. An instance of <b>Type</b> can represent any of the following types: </p>
<UL>
<li> Classes </li>
<li> Value types </li>
<li> Arrays </li>
<li> Interfaces </li>
<li> Pointers </li>
<li> Enumerations </li>
</UL>
<p> A reference to the <b>Type</b> object associated with a type can be obtained in the following ways.</p>
<UL>
<li> The  <a href="../../System/types/Object.html#GetType">Object.GetType</a> method returns a <b>Type</b> object that represents the type of an instance.</li>
<li> The static <b>GetType</b> methods return a <b>Type</b> object that represents a type specified by its fully qualified name.</li>
<li> The  <a href="../../System.Reflection/types/Module.html#GetTypes">Module.GetTypes</a>,  <a href="../../System.Reflection/types/Module.html#GetType(System.String,System.Boolean)">Module.GetType</a>, and  <a href="../../System.Reflection/types/Module.html#FindTypes(System.Reflection.TypeFilter,System.Object)">Module.FindTypes</a> methods return <b>Type</b> objects that represent the types defined in a module. The first can be used to obtain an array of <b>Type</b> objects for all of the public and private types defined in a module. (You can obtain an instance of <b>Module</b> through the  <a href="../../System.Reflection/types/Assembly.html#GetModule(System.String)">Assembly.GetModule</a> or  <a href="../../System.Reflection/types/Assembly.html#GetModules">Assembly.GetModules</a> methods, or through the  <a href="#Module">Type.Module</a> property.) </li>
<li> The  <a href="#FindInterfaces(System.Reflection.TypeFilter,System.Object)">Type.FindInterfaces</a> method returns a filtered list of interface types supported by a type.</li>
<li> The  <a href="#GetElementType">Type.GetElementType</a> method returns a <b>Type</b> object that represents the element.</li>
<li> The  <a href="#GetInterfaces">Type.GetInterfaces</a> and  <a href="#GetInterface(System.String)">Type.GetInterface</a> methods return <b>Type</b> objects representing the interface types supported by a type.</li>
<li> The  <a href="#GetTypeArray(System.Object[])">Type.GetTypeArray</a> method returns an array of <b>Type</b> objects representing the types specified by an arbitrary set of objects. The objects are specified with an array of type <b>Object</b>.</li>
<li> The  <a><font color="#FF0000"><i>System.Type.GetTypeFromProgID</i> (not supported on the shared source CLI) </font></a> and  <a><font color="#FF0000"><i>System.Type.GetTypeFromCLSID</i> (not supported on the shared source CLI) </font></a> methods are provided for COM interoperability. They return a <b>Type</b> object that represents the type specified by a <b>ProgID</b><font color="#FF0000"> (COM interop is not supported in the shared source CLI)</font> or <b>CLSID</b><font color="#FF0000"> (COM interop is not supported in the shared source CLI)</font>.</li>
<li> The  <a href="#GetTypeFromHandle(System.RuntimeTypeHandle)">Type.GetTypeFromHandle</a> method is provided for interoperability. It returns a <b>Type</b> object that represents the type specified by a class handle.</li>
<li> The C# or C++ <b>typeof</b> operator obtains the <b>Type</b> object for a type.</li>
</UL><br><br><b>Note </b><b>on Security:</b> A derived class can access protected members of the calling code's base classes. Also, access is allowed to assembly members of the calling code's assembly. As a rule, if you are allowed access in early bound code, then you are also allowed access in late bound code.<br><br><b>Note </b><b>on Reflection over Interfaces:</b> Interfaces that extend other interfaces do not inherit the methods defined in the extended interfaces.</dd>
</dl><b>See also: </b><dl>
<dd> <a href="../../System/System.html">System Namespace</a> |  <a href="../../System/types/Object.html">Object</a> |  <a href="../../System.Reflection/System.Reflection.html">System.Reflection</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a></dd>
</dl>
<h3>System.Type Member List: </h3>
<dl>
<dt><b>Public Fields</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#Delimiter">Delimiter</a></td>
<td width="55%"> Separates names in the namespace of the  <a href="../../System/types/Type.html">Type</a>. This field is read-only.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#EmptyTypes">EmptyTypes</a></td>
<td width="55%"> Represents an empty array of type  <a href="../../System/types/Type.html">Type</a>. This field is read-only.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#FilterAttribute">FilterAttribute</a></td>
<td width="55%"> Represents the member filter used on attributes. This field is read-only.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#FilterName">FilterName</a></td>
<td width="55%"> Represents the case-sensitive member filter used on names. This field is read-only.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#FilterNameIgnoreCase">FilterNameIgnoreCase</a></td>
<td width="55%"> Represents the case-insensitive member filter used on names. This field is read-only.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Missing">Missing</a></td>
<td width="55%"> Represents a missing value in the  <a href="../../System/types/Type.html">Type</a> information. This field is read-only.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Public Properties</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#Assembly">Assembly</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets the  <a href="../../System.Reflection/types/Assembly.html">Assembly</a> that the type is declared in.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#AssemblyQualifiedName">AssemblyQualifiedName</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets the fully qualified name of the  <a href="../../System/types/Type.html">Type</a>, including the name of the assembly from which the  <a href="../../System/types/Type.html">Type</a> was loaded.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Attributes">Attributes</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets the attributes associated with the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#BaseType">BaseType</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets the type from which the current  <a href="../../System/types/Type.html">Type</a> directly inherits.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#DeclaringType">DeclaringType</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Gets the class that declares this member.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#DefaultBinder">DefaultBinder</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets the default binder used by the system.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#FullName">FullName</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets the fully qualified name of the  <a href="../../System/types/Type.html">Type</a>, including the namespace of the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GUID">GUID</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets the GUID associated with the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#HasElementType">HasElementType</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the current  <a href="../../System/types/Type.html">Type</a> encompasses or refers to another type; that is, whether the current  <a href="../../System/types/Type.html">Type</a> is an array, a pointer, or is passed by reference.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsAbstract">IsAbstract</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is abstract and must be overridden.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsAnsiClass">IsAnsiClass</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the string format attribute <b>AnsiClass</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsArray">IsArray</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is an array.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsAutoClass">IsAutoClass</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the string format attribute <b>AutoClass</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsAutoLayout">IsAutoLayout</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the class layout attribute <b>AutoLayout</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsByRef">IsByRef</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is passed by reference.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsClass">IsClass</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is a class; that is, not a value type or interface.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsCOMObject">IsCOMObject</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is a COM object.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsContextful">IsContextful</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> can be hosted in a context.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsEnum">IsEnum</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the current  <a href="../../System/types/Type.html">Type</a> represents an enumeration.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsExplicitLayout">IsExplicitLayout</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the class layout attribute <b>ExplicitLayout</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsImport">IsImport</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> was imported from another class.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsInterface">IsInterface</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is an interface; that is, not a class or a value type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsLayoutSequential">IsLayoutSequential</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the class layout attribute <b>SequentialLayout</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsMarshalByRef">IsMarshalByRef</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the Type is marshaled by reference.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsNestedAssembly">IsNestedAssembly</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is nested and visible only within its own assembly.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsNestedFamANDAssem">IsNestedFamANDAssem</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is nested and visible only to classes that belong to both its own family and its own assembly.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsNestedFamily">IsNestedFamily</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is nested and visible only within its own family.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsNestedFamORAssem">IsNestedFamORAssem</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is nested and visible only to classes that belong to either its own family or to its own assembly.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsNestedPrivate">IsNestedPrivate</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is nested and declared private.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsNestedPublic">IsNestedPublic</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether a class is nested and declared public.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsNotPublic">IsNotPublic</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the top-level  <a href="../../System/types/Type.html">Type</a> is not declared public.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsPointer">IsPointer</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is a pointer.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsPrimitive">IsPrimitive</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is one of the primitive types.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsPublic">IsPublic</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the top-level  <a href="../../System/types/Type.html">Type</a> is declared public.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsSealed">IsSealed</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is declared sealed.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsSerializable">IsSerializable</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is serializable.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsSpecialName">IsSpecialName</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> has a name that requires special handling.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsUnicodeClass">IsUnicodeClass</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the string format attribute <b>UnicodeClass</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsValueType">IsValueType</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is a value type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#MemberType">MemberType</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Gets a bitmask indicating the member type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Module">Module</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets the module (the DLL) in which the current  <a href="../../System/types/Type.html">Type</a> is defined.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Name">Name</a><br>(inherited from <b>System.Reflection.MemberInfo)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System.Reflection/types/MemberInfo.html#Name">System.Reflection.MemberInfo.Name</a></font></b><br><br><br> Gets the name of this member.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Namespace">Namespace</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets the namespace of the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ReflectedType">ReflectedType</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Gets the class object that was used to obtain this member.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#TypeHandle">TypeHandle</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets the handle for the current  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#TypeInitializer">TypeInitializer</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets the initializer for the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#UnderlyingSystemType">UnderlyingSystemType</a></td>
<td width="55%"><b>Read-only</b><br><br> Indicates the type provided by the common language runtime that represents this type.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Public Methods</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#Equals(System.Object)">Equals</a></td>
<td width="55%"><b>Overloaded:</b><br><code>Equals(object o)<br><br></code><b>Overridden: </b><br> Determines if the underlying system type of the current  <a href="../../System/types/Type.html">Type</a> is the same as the underlying system type of the specified  <a href="../../System/types/Object.html">Object</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Equals(System.Type)">Equals</a></td>
<td width="55%"><b>Overloaded:</b><br><code>Equals(Type o)<br><br></code> Determines if the underlying system type of the current  <a href="../../System/types/Type.html">Type</a> is the same as the underlying system type of the specified  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#FindInterfaces(System.Reflection.TypeFilter,System.Object)">FindInterfaces</a></td>
<td width="55%"> Returns an array of  <a href="../../System/types/Type.html">Type</a> objects representing a filtered list of interfaces implemented or inherited by the current  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">FindMembers</a></td>
<td width="55%"> Returns a filtered array of  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> objects of the specified member type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetArrayRank">GetArrayRank</a></td>
<td width="55%"> Gets the number of dimensions in an  <a href="../../System/types/Array.html">Array</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetConstructor(System.Type[])">GetConstructor</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetConstructor(Type[] types)<br><br></code> Searches for a public instance constructor whose parameters match the types in the specified array.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">GetConstructor</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers)<br><br></code> Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">GetConstructor</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetConstructor(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)<br><br></code> Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetConstructors">GetConstructors</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetConstructors()<br><br></code> Returns all the public constructors defined for the current  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetConstructors(System.Reflection.BindingFlags)">GetConstructors</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetConstructors(BindingFlags bindingAttr)<br><br></code> When overridden in a derived class, searches for the constructors defined for the current  <a href="../../System/types/Type.html">Type</a>, using the specified <b>BindingFlags</b>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetCustomAttributes(System.Boolean)">GetCustomAttributes</a><br>(inherited from <b>System.Reflection.MemberInfo)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetCustomAttributes(bool inherit)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System.Reflection/types/MemberInfo.html#GetCustomAttributes(System.Boolean)">System.Reflection.MemberInfo.GetCustomAttributes</a></font></b><br><br><br> When overridden in a derived class, returns an array of all of the custom attributes.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetCustomAttributes(System.Type,System.Boolean)">GetCustomAttributes</a><br>(inherited from <b>System.Reflection.MemberInfo)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetCustomAttributes(Type attributeType, bool inherit)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System.Reflection/types/MemberInfo.html#GetCustomAttributes(System.Type,System.Boolean)">System.Reflection.MemberInfo.GetCustomAttributes</a></font></b><br><br><br> When overridden in a derived class, returns an array of custom attributes identified by  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetDefaultMembers">GetDefaultMembers</a></td>
<td width="55%"> Searches for the members defined for the current  <a href="../../System/types/Type.html">Type</a> whose  <a href="../../System.Reflection/types/DefaultMemberAttribute.html">DefaultMemberAttribute</a> is set.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetElementType">GetElementType</a></td>
<td width="55%"> When overridden in a derived class, returns the  <a href="../../System/types/Type.html">Type</a> of the object encompassed or referred to by the current array, pointer or reference type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetEvent(System.String)">GetEvent</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetEvent(string name)<br><br></code> Returns the  <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> object representing the specified event.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetEvent(System.String,System.Reflection.BindingFlags)">GetEvent</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetEvent(string name, BindingFlags bindingAttr)<br><br></code> When overridden in a derived class, returns the  <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> object representing the specified event, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetEvents">GetEvents</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetEvents()<br><br></code> Returns all the public events that are declared or inherited by the current  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetEvents(System.Reflection.BindingFlags)">GetEvents</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetEvents(BindingFlags bindingAttr)<br><br></code> When overridden in a derived class, searches for events that are declared or inherited by the current  <a href="../../System/types/Type.html">Type</a>, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetField(System.String)">GetField</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetField(string name)<br><br></code> Searches for the field with the specified name.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetField(System.String,System.Reflection.BindingFlags)">GetField</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetField(string name, BindingFlags bindingAttr)<br><br></code> Searches for the specified field, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetFields">GetFields</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetFields()<br><br></code> Returns all the public fields of the current  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetFields(System.Reflection.BindingFlags)">GetFields</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetFields(BindingFlags bindingAttr)<br><br></code> When overridden in a derived class, searches for the fields defined for the current  <a href="../../System/types/Type.html">Type</a>, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetHashCode">GetHashCode</a></td>
<td width="55%"><b>Overridden: </b><br> Returns the hash code for this instance.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetInterface(System.String)">GetInterface</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetInterface(string name)<br><br></code> Searches for the interface with the specified name.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetInterface(System.String,System.Boolean)">GetInterface</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetInterface(string name, bool ignoreCase)<br><br></code> When overridden in a derived class, searches for the specified interface, specifying whether to do a case-sensitive search.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetInterfaceMap(System.Type)">GetInterfaceMap</a></td>
<td width="55%"> Returns an interface mapping for the specified interface type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetInterfaces">GetInterfaces</a></td>
<td width="55%"> When overridden in a derived class, gets all the interfaces implemented or inherited by the current  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMember(System.String)">GetMember</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMember(string name)<br><br></code> Searches for the members with the specified name.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMember(System.String,System.Reflection.BindingFlags)">GetMember</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMember(string name, BindingFlags bindingAttr)<br><br></code> Searches for the specified members, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">GetMember</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMember(string name, MemberTypes type, BindingFlags bindingAttr)<br><br></code> Searches for the specified members of the specified member type, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMembers">GetMembers</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMembers()<br><br></code> Returns all the public members of the current  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMembers(System.Reflection.BindingFlags)">GetMembers</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMembers(BindingFlags bindingAttr)<br><br></code> When overridden in a derived class, searches for the members defined for the current  <a href="../../System/types/Type.html">Type</a>, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMethod(System.String)">GetMethod</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMethod(string name)<br><br></code> Searches for the public method with the specified name.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMethod(System.String,System.Reflection.BindingFlags)">GetMethod</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMethod(string name, BindingFlags bindingAttr)<br><br></code> Searches for the specified method, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMethod(System.String,System.Type[])">GetMethod</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMethod(string name, Type[] types)<br><br></code> Searches for the specified public method whose parameters match the specified argument types.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">GetMethod</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMethod(string name, Type[] types, ParameterModifier[] modifiers)<br><br></code> Searches for the specified public method whose parameters match the specified argument types and modifiers.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">GetMethod</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers)<br><br></code> Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">GetMethod</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)<br><br></code> Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMethods">GetMethods</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMethods()<br><br></code> Returns all the public methods of the current  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMethods(System.Reflection.BindingFlags)">GetMethods</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMethods(BindingFlags bindingAttr)<br><br></code> When overridden in a derived class, searches for the methods defined for the current  <a href="../../System/types/Type.html">Type</a>, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetNestedType(System.String)">GetNestedType</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetNestedType(string name)<br><br></code> Searches for the nested type with the specified name.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetNestedType(System.String,System.Reflection.BindingFlags)">GetNestedType</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetNestedType(string name, BindingFlags bindingAttr)<br><br></code> When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetNestedTypes">GetNestedTypes</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetNestedTypes()<br><br></code> Returns all the types nested within the current  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetNestedTypes(System.Reflection.BindingFlags)">GetNestedTypes</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetNestedTypes(BindingFlags bindingAttr)<br><br></code> When overridden in a derived class, searches for the types nested within the current  <a href="../../System/types/Type.html">Type</a>, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetProperties">GetProperties</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetProperties()<br><br></code> Returns all the public properties of the current  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetProperties(System.Reflection.BindingFlags)">GetProperties</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetProperties(BindingFlags bindingAttr)<br><br></code> When overridden in a derived class, searches for the properties of the current  <a href="../../System/types/Type.html">Type</a>, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetProperty(System.String)">GetProperty</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetProperty(string name)<br><br></code> Searches for the public property with the specified name.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetProperty(System.String,System.Reflection.BindingFlags)">GetProperty</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetProperty(string name, BindingFlags bindingAttr)<br><br></code> Searches for the specified property, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetProperty(System.String,System.Type)">GetProperty</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetProperty(string name, Type returnType)<br><br></code> Searches for the public property with the specified name and return type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetProperty(System.String,System.Type[])">GetProperty</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetProperty(string name, Type[] types)<br><br></code> Searches for the specified public property whose parameters match the specified argument types.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetProperty(System.String,System.Type,System.Type[])">GetProperty</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetProperty(string name, Type returnType, Type[] types)<br><br></code> Searches for the specified public property whose parameters match the specified argument types.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">GetProperty</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetProperty(string name, Type returnType, Type[] types, ParameterModifier[] modifiers)<br><br></code> Searches for the specified public property whose parameters match the specified argument types and modifiers.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">GetProperty</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)<br><br></code> Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetType">GetType</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetType()<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#GetType">System.Object.GetType</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetType(System.String)">GetType</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetType(string typeName)<br><br></code> Gets the  <a href="../../System/types/Type.html">Type</a> with the specified name, performing a case-sensitive search.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetType(System.String,System.Boolean)">GetType</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetType(string typeName, bool throwOnError)<br><br></code> Gets the  <a href="../../System/types/Type.html">Type</a> with the specified name, performing a case-sensitive search and specifying whether to throw an exception if an error occurs while loading the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetType(System.String,System.Boolean,System.Boolean)">GetType</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetType(string typeName, bool throwOnError, bool ignoreCase)<br><br></code> Gets the  <a href="../../System/types/Type.html">Type</a> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if an error occurs while loading the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetTypeArray(System.Object[])">GetTypeArray</a></td>
<td width="55%"> Gets the types of the objects in the specified array.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetTypeCode(System.Type)">GetTypeCode</a></td>
<td width="55%"> Gets the underlying type code of the specified  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetTypeFromHandle(System.RuntimeTypeHandle)">GetTypeFromHandle</a></td>
<td width="55%"> Gets the  <a href="../../System/types/Type.html">Type</a> referenced by the specified type handle.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetTypeHandle(System.Object)">GetTypeHandle</a></td>
<td width="55%"> Gets the handle for the  <a href="../../System/types/Type.html">Type</a> of a specified object.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">InvokeMember</a></td>
<td width="55%"><b>Overloaded:</b><br><code>InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args)<br><br></code> Invokes the specified member, using the specified binding constraints and matching the specified argument list.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">InvokeMember</a></td>
<td width="55%"><b>Overloaded:</b><br><code>InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, CultureInfo culture)<br><br></code> Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">InvokeMember</a></td>
<td width="55%"><b>Overloaded:</b><br><code>InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters)<br><br></code> When overridden in a derived class, invokes the specified member, using the specified binding constraints and matching the specified argument list, modifiers and culture.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsAssignableFrom(System.Type)">IsAssignableFrom</a></td>
<td width="55%"> Determines whether an instance of the current  <a href="../../System/types/Type.html">Type</a> can be assigned from an instance of the specified <b>Type</b>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsDefined(System.Type,System.Boolean)">IsDefined</a><br>(inherited from <b>System.Reflection.MemberInfo)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System.Reflection/types/MemberInfo.html#IsDefined(System.Type,System.Boolean)">System.Reflection.MemberInfo.IsDefined</a></font></b><br><br><br> When overridden in a derived class, indicates whether one or more instance of <i>attributeType</i> is defined on this member.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsInstanceOfType(System.Object)">IsInstanceOfType</a></td>
<td width="55%"> Determines whether the specified object is an instance of the current  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsSubclassOf(System.Type)">IsSubclassOf</a></td>
<td width="55%"> Determines whether the current  <a href="../../System/types/Type.html">Type</a> derives from the specified <b>Type</b>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ToString">ToString</a></td>
<td width="55%"><b>Overridden: </b><br> Returns a <b>String</b> representing the name of the current <b>Type</b>.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Protected Constructors</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#ctor1">ctor #1</a></td>
<td width="55%">Default constructor. This constructor is called by derived class constructors to initialize state in this type.<br> Initializes a new instance of the  <a href="../../System/types/Type.html">Type</a> class.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Protected Methods</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#Finalize">Finalize</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#Finalize">System.Object.Finalize</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetAttributeFlagsImpl">GetAttributeFlagsImpl</a></td>
<td width="55%"> When overridden in a derived class, implements the  <a href="#Attributes">Type.Attributes</a> property and gets a bitmask indicating the attributes associated with the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">GetConstructorImpl</a></td>
<td width="55%"> When overridden in a derived class, searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">GetMethodImpl</a></td>
<td width="55%"> When overridden in a derived class, searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">GetPropertyImpl</a></td>
<td width="55%"> When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#HasElementTypeImpl">HasElementTypeImpl</a></td>
<td width="55%"> When overridden in a derived class, implements the  <a href="#HasElementType">Type.HasElementType</a> property and determines whether the current  <a href="../../System/types/Type.html">Type</a> encompasses or refers to another type; that is, whether the current  <a href="../../System/types/Type.html">Type</a> is an array, a pointer, or is passed by reference.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsArrayImpl">IsArrayImpl</a></td>
<td width="55%"> When overridden in a derived class, implements the  <a href="#IsArray">Type.IsArray</a> property and determines whether the  <a href="../../System/types/Type.html">Type</a> is an array.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsByRefImpl">IsByRefImpl</a></td>
<td width="55%"> When overridden in a derived class, implements the  <a href="#IsByRef">Type.IsByRef</a> property and determines whether the  <a href="../../System/types/Type.html">Type</a> is passed by reference.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsCOMObjectImpl">IsCOMObjectImpl</a></td>
<td width="55%"> When overridden in a derived class, implements the  <a href="#IsCOMObject">Type.IsCOMObject</a> property and determines whether the  <a href="../../System/types/Type.html">Type</a> is a COM object.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsContextfulImpl">IsContextfulImpl</a></td>
<td width="55%"> Implements the  <a href="#IsContextful">Type.IsContextful</a> property and determines whether the  <a href="../../System/types/Type.html">Type</a> can be hosted in a context.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsMarshalByRefImpl">IsMarshalByRefImpl</a></td>
<td width="55%"> Implements the  <a href="#IsMarshalByRef">Type.IsMarshalByRef</a> property and determines whether the  <a href="../../System/types/Type.html">Type</a> is marshalled by reference.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsPointerImpl">IsPointerImpl</a></td>
<td width="55%"> When overridden in a derived class, implements the  <a href="#IsPointer">Type.IsPointer</a> property and determines whether the  <a href="../../System/types/Type.html">Type</a> is a pointer.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsPrimitiveImpl">IsPrimitiveImpl</a></td>
<td width="55%"> When overridden in a derived class, implements the  <a href="#IsPrimitive">Type.IsPrimitive</a> property and determines whether the  <a href="../../System/types/Type.html">Type</a> is one of the primitive types.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsValueTypeImpl">IsValueTypeImpl</a></td>
<td width="55%"> Implements the  <a href="#IsValueType">Type.IsValueType</a> property and determines whether the  <a href="../../System/types/Type.html">Type</a> is a value type; that is, not a class or an interface.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#MemberwiseClone">MemberwiseClone</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#MemberwiseClone">System.Object.MemberwiseClone</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
</table>
</dd>
</dl>
<p><b>Hierarchy:</b><ul class="none">
<li><a href="../../System/types/Object.html">System.Object</a></li>
<ul class="none">
<li><a href="../../System.Reflection/types/MemberInfo.html">System.Reflection.MemberInfo</a></li>
<ul class="none">
<li><b>System.Type</b><ul class="none">
<li><a href="../../System.Reflection.Emit/types/EnumBuilder.html">System.Reflection.Emit.EnumBuilder</a></li>
<li><a href="../../System.Reflection.Emit/types/TypeBuilder.html">System.Reflection.Emit.TypeBuilder</a></li>
<li><a href="../../System.Reflection/types/TypeDelegator.html">System.Reflection.TypeDelegator</a></li>
</ul>
</li>
</ul>
</ul>
</ul>
</p>
<hr>
<h3>System.Type Member Details</h3><b><i><a name=".ctorTopic1"></a><a name="ctor1">ctor #1</a></i></b><b><i></i></b><dl>
<dt><b>Summary</b></dt>
<dd> Initializes a new instance of the  <a href="../../System/types/Type.html">Type</a> class.</dd>
</dl><br><dl>
<dd>Default constructor. This constructor is called by derived class constructors to initialize state in this type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected Type();</b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This constructor is invoked by derived classes during the construction of type objects.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Field: <i><a name="DelimiterTopic1"></a><a name="Delimiter">Delimiter</a></i></b><b><i></i></b><dl>
<dt><b>Summary</b></dt>
<dd> Separates names in the namespace of the  <a href="../../System/types/Type.html">Type</a>. This field is read-only.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public static readonly <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfmemberstopic.asp">char</a> Delimiter;
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd> The following code example shows the <b>Delimiter</b> field used in a resource name.<pre>
typeNameSpace + Type.Delimiter + baseName + '.' + cultureName [+ '-' + subCultureName] + '.resources'

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Field: <i><a name="EmptyTypesTopic1"></a><a name="EmptyTypes">EmptyTypes</a></i></b><b><i></i></b><dl>
<dt><b>Summary</b></dt>
<dd> Represents an empty array of type  <a href="../../System/types/Type.html">Type</a>. This field is read-only.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public static readonly <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfmemberstopic.asp">Type[]</a> EmptyTypes;
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd> The following code example shows the <b>EmptyTypes</b> field used in one of the <b>GetConstructor</b> methods to get a constructor that takes no parameters.<pre>
cInfo = type.GetConstructor (BindingFlags.ExactBinding, null, 
         Type.EmptyTypes, null);

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Field: <i><a name="FilterAttributeTopic1"></a><a name="FilterAttribute">FilterAttribute</a></i></b><b><i></i></b><dl>
<dt><b>Summary</b></dt>
<dd> Represents the member filter used on attributes. This field is read-only.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public static readonly <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfmemberstopic.asp">MemberFilter</a> FilterAttribute;
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This field holds a reference to the delegate used by the  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a> method. The method encapsulated by this delegate takes two parameters: the first is a  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> object and the second is an <b>Object</b>. The method determines whether the <b>MemberInfo</b> object matches the criteria specified by the <b>Object</b>. The <b>Object</b> may be assigned the value of any one of the fields on the classes  <a href="../../System.Reflection/types/FieldAttributes.html">FieldAttributes</a>,  <a href="../../System.Reflection/types/MethodAttributes.html">MethodAttributes</a>, or  <a href="../../System.Reflection/types/MethodImplAttributes.html">MethodImplAttributes</a>.<p> For example, the <b>Object</b> can be assigned the value of a field from <b>FieldAttributes</b> such as Public. In that case, when the <b>FilterAttribute</b> delegate is invoked, it will return <b>true</b> only if the method represented by the <b>MemberInfo</b> object is decorated with the public field attribute in metadata.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
using System;
using System.Reflection;
using System.Security;

public class MyFilterAttributeSample
{
   public static void Main()
   {
      try
      {

         MemberFilter myFilter = Type.FilterAttribute;
         Type myType = typeof(System.String);
         MemberInfo[] myMemberInfoArray = myType.FindMembers(MemberTypes.Constructor
            |MemberTypes.Method, BindingFlags.Public | BindingFlags.Static |
            BindingFlags.Instance, myFilter, MethodAttributes.SpecialName);
         foreach (MemberInfo myMemberinfo in myMemberInfoArray) 
         { 
            Console.Write ("\n" + myMemberinfo.Name);
            Console.Write (" is a " + myMemberinfo.MemberType.ToString()); 
         }
  
      }
      catch(ArgumentNullException e)
      {
         Console.Write("ArgumentNullException : " + e.Message); 
      }   
      catch(SecurityException e)
      {
         Console.Write("SecurityException : " + e.Message); 
      }   
      catch(Exception e)
      {
         Console.Write("Exception :" + e.Message); 
      } 
   }	
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a> |  <a href="../../System.Reflection/types/MemberFilter.html">MemberFilter</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Field: <i><a name="FilterNameTopic1"></a><a name="FilterName">FilterName</a></i></b><b><i></i></b><dl>
<dt><b>Summary</b></dt>
<dd> Represents the case-sensitive member filter used on names. This field is read-only.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public static readonly <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfmemberstopic.asp">MemberFilter</a> FilterName;
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This field holds a reference to the delegate used by the  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a> method. The method encapsulated by this delegate takes two parameters: the first is a  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> object and the second is an <b>Object</b>. The method determines whether the <b>MemberInfo</b> object matches the criteria specified by the <b>Object</b>. The <b>Object</b> is assigned a string value, which may include a trailing "*" wildcard character. Only wildcard end string matching is supported.<p> For example, the <b>Object</b> may be assigned the value "Byte*". In that case, when the <b>FilterName</b> delegate is invoked, it will return <b>true</b> only if the method represented by the <b>MemberInfo</b> object has a name that begins with "Byte".</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following code example gets the set of methods associated with the user-defined <b>Application</b> type.<pre>
 // Get the set of methods associated with the type
 MemberInfo[] mi = typeof(Application).FindMembers(MemberTypes.Constructor | 
     MemberTypes.Method, 
     BindingFlags.Public | BindingFlags.Static | BindingFlags.NonPublic |
     BindingFlags.Instance | BindingFlags.DeclaredOnly,
     Type.FilterName, "*");
   Console.WriteLine("Number of methods (includes constructors): " + mi.Length);

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a> |  <a href="../../System.Reflection/types/MemberFilter.html">MemberFilter</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Field: <i><a name="FilterNameIgnoreCaseTopic1"></a><a name="FilterNameIgnoreCase">FilterNameIgnoreCase</a></i></b><b><i></i></b><dl>
<dt><b>Summary</b></dt>
<dd> Represents the case-insensitive member filter used on names. This field is read-only.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public static readonly <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfmemberstopic.asp">MemberFilter</a> FilterNameIgnoreCase;
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This field holds a reference to the delegate used by the  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a> method. The method encapsulated by this delegate takes two parameters: the first is a  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> object and the second is an <b>Object</b>. The method determines whether the <b>MemberInfo</b> object matches the criteria specified by the <b>Object</b>. The <b>Object</b> is assigned a string value, which may include a trailing "*" wildcard character. Only wildcard end string matching is supported.<p> For example, the <b>Object</b> may be assigned the value "ByTe*". In that case, when the <b>FilterName</b> delegate is invoked, it will return true only if the method represented by the <b>MemberInfo</b> object has a name that begins with "byte", ignoring case.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
using System;
using System.Reflection;
using System.Security;
public class MyFilterNameIgnoreCaseSample
{
   public static void Main()
   {
      try
      {		

         MemberFilter myFilter = Type.FilterNameIgnoreCase;
         Type myType = typeof(System.String);
         MemberInfo[] myMemberinfo1 = myType.FindMembers(MemberTypes.Constructor
            |MemberTypes.Method, BindingFlags.Public | BindingFlags.Static |
            BindingFlags.Instance, myFilter, "C*");
		   foreach (MemberInfo myMemberinfo2 in myMemberinfo1) 
         { 
		      Console.Write("\n" + myMemberinfo2.Name);
            MemberTypes Mymembertypes = myMemberinfo2.MemberType; 
            Console.WriteLine(" is a " + Mymembertypes.ToString()); 
         }
   
      }
      catch(ArgumentNullException e)
      {
         Console.Write("ArgumentNullException : " + e.Message); 
      }   
      catch(SecurityException e)
      {
         Console.Write("SecurityException : " + e.Message); 
      }   
      catch(Exception e)
      {
         Console.Write("Exception : " + e.Message); 
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a> |  <a href="../../System.Reflection/types/MemberFilter.html">MemberFilter</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Field: <i><a name="MissingTopic1"></a><a name="Missing">Missing</a></i></b><b><i></i></b><dl>
<dt><b>Summary</b></dt>
<dd> Represents a missing value in the  <a href="../../System/types/Type.html">Type</a> information. This field is read-only.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public static readonly <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfmemberstopic.asp">object</a> Missing;
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Use the <b>Missing</b> field for invocation through reflection to obtain the default value of a parameter. If the <b>Missing</b> field is passed in for a parameter value and there is no default value for that parameter, an  <a href="../../System/types/ArgumentException.html">ArgumentException</a> is thrown.</dd>
</dl><b>Example</b><dl>
<dd> The following code example shows the use of the <b>Missing</b> field to invoke a method with its default arguments.<p> This code produces the following output: </p>
<p> a = 10 b = 55.3 c = 12 </p>
<p> a = 10 b = 1.3 c = 1 </p>
<p> a = 10 b = 1.2 c = 1 </p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/Missing.html">Missing</a> | <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconaccessingdefaultargumentvalues.asp">MSDN: accessingdefaultargumentvalues</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="AssemblyTopic1"></a><a name="Assembly">Assembly</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the  <a href="../../System.Reflection/types/Assembly.html">Assembly</a> that the type is declared in.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System.Reflection/types/Assembly.html">Assembly</a> Assembly {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This property is read-only.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
using System;
using System.Reflection;

class MyAssemblyClass
{

    public static void Main()
    {
         Type objType = typeof(System.Array);
                    
        // Print the assembly Fullname.
        Console.WriteLine ("Assembly Fullname -\t" + objType.Assembly.FullName.ToString() + "\n" ); 

        // Print the assembly Qualified Name.
        Console.WriteLine ("Assembly Qualified name -\t" + objType.AssemblyQualifiedName.ToString()); 
    }
}

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="AssemblyQualifiedNameTopic1"></a><a name="AssemblyQualifiedName">AssemblyQualifiedName</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the fully qualified name of the  <a href="../../System/types/Type.html">Type</a>, including the name of the assembly from which the  <a href="../../System/types/Type.html">Type</a> was loaded.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/String.html">string</a> AssemblyQualifiedName {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.<br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Delimiter
                </TH>
<TH>
                  Meaning
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Backslash (\)
                </TD>
<TD>
                  Escape character.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Comma (,)
                </TD>
<TD>
                  Precedes the Assembly name.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Plus sign (+)
                </TD>
<TD>
                  Precedes a nested class.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Period (.)
                </TD>
<TD>
                  Denotes namespace identifiers.
                </TD>
</TR>
</table>
<p> For example, the fully qualified name for a class might look like this: </p>
<p> TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly </p>
<p> If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\) to prevent it from being interpreted as a nesting separator. Reflection emits this string as follows: </p>
<p> TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly </p>
<p> A "++" becomes "\+\+", and a "\" becomes "\\".</p>
<p> This qualified name can be persisted and later used to load the  <a href="../../System/types/Type.html">Type</a>. To search for and load a  <a href="../../System/types/Type.html">Type</a>, use  <a href="#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> either with the type name only or with the assembly qualified type name. <a href="#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> with the type name only will look for the  <a href="../../System/types/Type.html">Type</a> in the caller's assembly and then in the System assembly. <a href="#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> with the assembly qualified type name will look for the  <a href="../../System/types/Type.html">Type</a> in any assembly.</p>
<p> Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type. To retrieve the type name without these trailing characters, use <code>
                t.GetElementType().ToString()
              </code>, where <i>t</i> is the type.</p>
<p> Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
using System;
using System.Reflection;

class MyAssemblyClass
{

    public static void Main()
    {
         Type objType = typeof(System.Array);
                    
        // Print the assembly Fullname.
        Console.WriteLine ("Assembly Fullname -\t" + objType.Assembly.FullName.ToString() + "\n" ); 

        // Print the assembly Qualified Name.
        Console.WriteLine ("Assembly Qualified name -\t" + objType.AssemblyQualifiedName.ToString()); 
    }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/String.html">String</a> |  <a href="#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> |  <a href="#FullName">Type.FullName</a> |  <a href="#Namespace">Type.Namespace</a> | <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconSpecifyingFullyQualifiedTypeNames.asp">MSDN: specifyingfullyqualifiedtypenames</a> |  <a href="../../System.Reflection/types/AssemblyName.html">AssemblyName</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="AttributesTopic1"></a><a name="Attributes">Attributes</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the attributes associated with the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> Attributes {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd></dd>
</dl><b>See also: 
			</b><br> <a href="#GetAttributeFlagsImpl">Type.GetAttributeFlagsImpl</a> |  <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="BaseTypeTopic1"></a><a name="BaseType">BaseType</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the type from which the current  <a href="../../System/types/Type.html">Type</a> directly inherits.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/Type.html">Type</a> BaseType {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The base type is the type from which the current type directly inherits. <a href="../../System/types/Object.html">Object</a> is the only type that does not have a base type, therefore <b>null</b> is returned as the base type of  <a href="../../System/types/Object.html">Object</a>.<p> Interfaces inherit from  <a href="../../System/types/Object.html">Object</a> and from zero or more base interfaces; therefore, the base type of an interface is considered to be  <a href="../../System/types/Object.html">Object</a>. The base interfaces can be determined with  <a href="#GetInterfaces">Type.GetInterfaces</a> or  <a href="#FindInterfaces(System.Reflection.TypeFilter,System.Object)">Type.FindInterfaces</a>.</p>
<p> This property is read-only.</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following example demonstrates using the <b>BaseType</b> property.<pre>
using System;
class TestType 
{
   public static void Main() 
   {
   Type t = typeof(int);
   Console.WriteLine("{0} inherits from {1}", t,t.BaseType);
   }
}

    </pre>
<p> This code produces the following output: </p><code>
              System.Int32 inherits from System.ValueType
            </code></dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/Object.html">Object</a> |  <a href="#GetInterfaces">Type.GetInterfaces</a> |  <a href="#FindInterfaces(System.Reflection.TypeFilter,System.Object)">Type.FindInterfaces</a> |  <a href="#UnderlyingSystemType">Type.UnderlyingSystemType</a> |  <a href="#IsSubclassOf(System.Type)">Type.IsSubclassOf</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="DeclaringTypeTopic1"></a><a name="DeclaringType">DeclaringType</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the class that declares this member.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Type.html">Type</a> DeclaringType {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This property implements the abstract property inherited from  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a>.</dd>
</dl><b>Example</b><dl>
<dd> This example displays the declaring type of a method in a derived class.<pre>
 using System;
 using System.Reflection;
 
 public abstract class dtype {
    
    public abstract class MyClassA {
       public abstract int m(); 
    }
    
    public abstract class MyClassB : MyClassA {
    }
  
    public static void Main(string[] args) { 
       Console.WriteLine("Declaring type of m is {0}",
          typeof(MyClassB).GetMethod("m").DeclaringType);
    }
 }
 

    </pre>
<p> This code produces the following output: </p>
<p> Declaring type of m is dtype+MyClassA </p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> |  <a href="#ReflectedType">Type.ReflectedType</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="DefaultBinderTopic1"></a><a name="DefaultBinder">DefaultBinder</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the default binder used by the system.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public static <a href="../../System.Reflection/types/Binder.html">Binder</a> DefaultBinder {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Reflection models the accessibility rules of the common type system. For example, if the caller is in the same assembly, the caller does not need special permissions for internal members. Otherwise, the caller needs  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a>. This is consistent with lookup of members that are protected, private, and so on.<p> The general principle is that  <a href="../../System.Reflection/types/Binder.html#ChangeType(System.Object,System.Type,System.Globalization.CultureInfo)">Binder.ChangeType</a> should perform only widening coercions, which never lose data. An example of a widening coercion is coercing a value that is a 32-bit signed integer to a value that is a 64-bit signed integer. This is distinguished from a narrowing coercion, which may lose data. An example of a narrowing coercion is coercing a 64-bit signed integer to a 32-bit signed integer.</p>
<p> The following table lists the coercions performed by the default <b>ChangeType</b>.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Source Type
                </TH>
<TH>
                  Target Type
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Any type
                </TD>
<TD>
                  Its base type.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Any type
                </TD>
<TD>
                  The interface it implements.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Char
                </TD>
<TD>
                  Unt16, UInt32, Int32, UInt64, Int64, Single, Double
                </TD>
</TR>
<TR valign="top">
<TD>
                  Byte
                </TD>
<TD>
                  Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double
                </TD>
</TR>
<TR valign="top">
<TD>
                  SByte
                </TD>
<TD>
                  Int16, Int32, Int64, Single, Double
                </TD>
</TR>
<TR valign="top">
<TD>
                  UInt16
                </TD>
<TD>
                  UInt32, Int32, UInt64, Int64, Single, Double
                </TD>
</TR>
<TR valign="top">
<TD>
                  Int16
                </TD>
<TD>
                  Int32, Int64, Single, Double
                </TD>
</TR>
<TR valign="top">
<TD>
                  UInt32
                </TD>
<TD>
                  UInt64, Int64, Single, Double
                </TD>
</TR>
<TR valign="top">
<TD>
                  Int32
                </TD>
<TD>
                  Int64, Single, Double
                </TD>
</TR>
<TR valign="top">
<TD>
                  UInt64
                </TD>
<TD>
                  Single, Double
                </TD>
</TR>
<TR valign="top">
<TD>
                  Int64
                </TD>
<TD>
                  Single, Double
                </TD>
</TR>
<TR valign="top">
<TD>
                  Single
                </TD>
<TD>
                  Double
                </TD>
</TR>
<TR valign="top">
<TD>
                  Non-reference
                </TD>
<TD>
                  By-reference.
                </TD>
</TR>
</table>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
using System;
using System.Reflection;
public class MyDefaultBinderSample
{
   public static void Main()
	{

      try
      {
         Binder defaultBinder = Type.DefaultBinder;
         MyClass myClass = new MyClass();
         // Invoke HelloWorld method of Myclass.
         myClass.GetType().InvokeMember("HelloWorld", BindingFlags.InvokeMethod,
         defaultBinder, myClass, new object [] {});
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception :" + e.Message);
      }
	}	

   class MyClass
	{
	   public void HelloWorld()
		{
		   Console.WriteLine("Hello World");
		}	
	}
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/Binder.html">Binder</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="FullNameTopic1"></a><a name="FullName">FullName</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the fully qualified name of the  <a href="../../System/types/Type.html">Type</a>, including the namespace of the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/String.html">string</a> FullName {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> For example, the fully qualified name of the C# string type is System.String.<p> This property is read-only.</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following example demonstrates using the <b>FullName</b> property.<pre>
using System;
class TestFullName 
{
public static void Main() 
   {
   Type t = typeof(Array);
   Console.WriteLine("Full name of Array type is {0}",t.FullName);
   }
} 

    </pre>
<p> This code produces the following output: </p>
<p><code>
                Full name of Array type is
                System.Array
              </code></p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/String.html">String</a> |  <a href="#Namespace">Type.Namespace</a> |  <a href="#AssemblyQualifiedName">Type.AssemblyQualifiedName</a> | <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconSpecifyingFullyQualifiedTypeNames.asp">MSDN: specifyingfullyqualifiedtypenames</a> |  <a href="../../System.Reflection/types/AssemblyName.html">AssemblyName</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="GUIDTopic1"></a><a name="GUID">GUID</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the GUID associated with the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/Guid.html">Guid</a> GUID {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
      // Get the type corresponding to the class 'MyClass'.
      Type myType = typeof(MyClass1);
      // Get the object of the 'Guid'.
      Guid myGuid =(Guid) myType.GUID;
      Console.WriteLine("The Name of the Class is :"+myType.ToString());
      Console.WriteLine("The ClassId of the 'MyClass' is :"+myType.GUID);				

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/Guid.html">Guid</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="HasElementTypeTopic1"></a><a name="HasElementType">HasElementType</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the current  <a href="../../System/types/Type.html">Type</a> encompasses or refers to another type; that is, whether the current  <a href="../../System/types/Type.html">Type</a> is an array, a pointer, or is passed by reference.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> HasElementType {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> For example, Type.GetType("Int32[]").HasElementType returns <b>true</b>, but Type.GetType("Int32").HasElementType returns <b>false</b>. HasElementType also returns <b>true</b> for "Int32*" and "Int32&amp;".</dd>
</dl><b>Example</b><dl>
<dd>
<pre>

public class MyClass 
{
}

public class Type_HasElementType
{
   public static void Main()
   {
      try
      {
         // An non array or pointer or reference element. 
         MyClass myObject1 = new MyClass();
         Object myObject2 = myObject1 ; 

         // An object of array type. 
         MyClass[] myObject3 = new MyClass[5];
         Object myObject4 = myObject3 ; 

         Object[] myObjects = new Object[] { myObject1, myObject2, myObject3, myObject4 };
         
         Console.WriteLine("\nCheck whether the object refers to array or pointer or reference type.\n");                     
         for(int i = 0; i &lt; myObjects.Length; i++)
         {
            if(myObjects[i].GetType().HasElementType)
               Console.WriteLine("'myObject{0}' refers to an array or pointer or reference", i);
            else
               Console.WriteLine("'myObject{0}' does not refer to an array or pointer or reference", i);
         }
      }
      catch( Exception e )
      {
         Console.WriteLine( "Exception: {0} \n", e.Message ) ; 
      }	
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#HasElementTypeImpl">Type.HasElementTypeImpl</a> |  <a href="#IsArray">Type.IsArray</a> |  <a href="#IsPointer">Type.IsPointer</a> |  <a href="#IsByRef">Type.IsByRef</a> |  <a href="#GetElementType">Type.GetElementType</a> |  <a href="#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsAbstractTopic1"></a><a name="IsAbstract">IsAbstract</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is abstract and must be overridden.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsAbstract {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>

public abstract class MyAbstractClass 
{
}

public class MyClass
{
}

public class Type_IsAbstract
{
   public static void Main()
   {
      try
      {
         Console.WriteLine("\nChecking whether the type is abstract\n"); 

         // Check whether the return Type is abstract or not.
         Console.WriteLine("'MyAbstractClass' is {0}", 
            (typeof(MyAbstractClass).IsAbstract) ? 
            "an abstract class" :
            "not an abstract class" );

         // Check whether the return Type is abstract or not.
         Console.WriteLine("'MyClass' is {0}",
            (typeof(MyClass).IsAbstract) ?
            "an abstract class" : 
            "not an abstract class" );
			
      }
      catch( Exception e )
      {
         Console.WriteLine( "Exception: {0} \n", e.Message ); 
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsAnsiClassTopic1"></a><a name="IsAnsiClass">IsAnsiClass</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the string format attribute <b>AnsiClass</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsAnsiClass {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#StringFormatMask">TypeAttributes.StringFormatMask</a> selects the string format attributes. The string format attributes enhance interoperability by defining how strings should be interpreted.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
public class MyClass
{
   protected string myField = "A sample protected field" ;
}

public class MyType_IsAnsiClass
{
   public static void Main()
   {
      try
      {
         MyClass myObject = new MyClass();
       
         // Get the type of the 'MyClass'.
         Type myType = typeof(MyClass);

         // Get the field information and the attributes associated with 'MyClass'.
         FieldInfo myFieldInfo = myType.GetField("myField",
            BindingFlags.NonPublic|BindingFlags.Instance);
    
         Console.WriteLine( "\nChecking for AnsiClass attribute for a field\n"); 
         // Get and display the name, field, and the AnsiClass attribute.
         Console.WriteLine("Name of Class: {0} \nValue of Field: {1} \nIsAnsiClass = {2}",
            myType.FullName, myFieldInfo.GetValue(myObject),
            myType.IsAnsiClass);
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception : {0}",e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsUnicodeClass">Type.IsUnicodeClass</a> |  <a href="#IsAutoClass">Type.IsAutoClass</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsArrayTopic1"></a><a name="IsArray">IsArray</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is an array.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsArray {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System/types/Array.html">Array</a> class returns <b>false</b> because it is not an array.<p> This property is read-only.</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following example demonstrates using the <b>IsArray</b> property.<pre>
using System;
class TestIsArray 
{
   public static void Main() 
   {
   int [] array = {1,2,3,4};
   Type at = typeof(Array);
   Type t = array.GetType();
   Console.WriteLine("Type is {0}. IsArray? {1}", at, at.IsArray);
   Console.WriteLine("Type is {0}. IsArray? {1}", t, t.IsArray);
   }
}

    </pre>
<p> This code produces the following output: </p>
<pre>
              				Type is System.Array. IsArray? False
              				Type is System.Int32[]. IsArray? True
              			
            </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#IsArrayImpl">Type.IsArrayImpl</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsAutoClassTopic1"></a><a name="IsAutoClass">IsAutoClass</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the string format attribute <b>AutoClass</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsAutoClass {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#StringFormatMask">TypeAttributes.StringFormatMask</a> selects the string format attributes. The string format attributes enhance interoperability by defining how strings should be interpreted.</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsAnsiClass">Type.IsAnsiClass</a> |  <a href="#IsUnicodeClass">Type.IsUnicodeClass</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsAutoLayoutTopic1"></a><a name="IsAutoLayout">IsAutoLayout</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the class layout attribute <b>AutoLayout</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsAutoLayout {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#LayoutMask">TypeAttributes.LayoutMask</a> is used to select the class layout attributes. The class layout attributes (<b>AutoLayout</b><i>,</i><b>SequentialLayout</b> and <b>ExplicitLayout</b>) define how the fields of the class instance are laid out in memory.<p> Use the <b>AutoLayout</b> attribute to let the runtime engine decide the best way to layout the objects of the class. Classes marked with the <b>AutoLayout</b> attribute indicate that the loader will choose the appropriate way to lay out the class; any layout information that may have been specified is ignored.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
// The MyDemoAttribute class is selected as AutoLayout.
[StructLayoutAttribute(LayoutKind.Auto)]
public class MyDemoAttribute
{
}

public class MyTypeClass
{
   public static void Main(string[] args)
   { 
      MyAutoLayoutMethod("MyDemoAttribute");    
   }

    public static void MyAutoLayoutMethod(string typeName)
   {
      try
      {
         // Create an object of 'Type' class using the 'GetType' method.
         Type  myType=Type.GetType(typeName);
         // Get and display the 'IsAutoLayout' property of the 
         // 'MyDemoAttribute' instance.
         Console.WriteLine("\n The 'Autolayout' property for the 'MyDemoAttribute' is: {0}.",myType.IsAutoLayout); 
      }
      catch(Exception e)
      {
         Console.WriteLine("\nThe following exception is raised: {0}." ,e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsLayoutSequential">Type.IsLayoutSequential</a> |  <a href="#IsExplicitLayout">Type.IsExplicitLayout</a> | <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconmetadataoverview.asp">MSDN: metadataoverview</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsByRefTopic1"></a><a name="IsByRef">IsByRef</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is passed by reference.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsByRef {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>See also: 
			</b><br> <a href="#IsByRefImpl">Type.IsByRefImpl</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsClassTopic1"></a><a name="IsClass">IsClass</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is a class; that is, not a value type or interface.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsClass {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This property returns <b>true</b> for <b>Type</b> instances representing  <a href="../../System/types/Enum.html">Enum</a> and  <a href="../../System/types/ValueType.html">ValueType</a>.<p> The  <a href="../../System.Reflection/types/TypeAttributes.html#ClassSemanticsMask">TypeAttributes.ClassSemanticsMask</a> distinguishes a type declaration as class, interface, or value type.</p>
<p> This property is read-only.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
public  class MyDemoClass
{
   
}

public class MyTypeClass
{
   public static void Main(string[] args)
   {
      try
      {
         Type  myType=Type.GetType("MyDemoClass");
         // Get and display the 'IsClass' property of the 'MyDemoClass' instance.
         Console.WriteLine("\n'MyDemoClass' is of type 'Class': {0}.", myType.IsClass); 
      }
      catch(Exception e)
      {
         Console.WriteLine("\nThe following exception is raised: {0}." ,e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsInterface">Type.IsInterface</a> |  <a href="#IsValueType">Type.IsValueType</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsCOMObjectTopic1"></a><a name="IsCOMObject">IsCOMObject</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is a COM object.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsCOMObject {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This method returns <b>false</b> for COM interfaces because they are not objects. COM interfaces can be implemented by Microsoft .NET Framework objects.<p> You can also load a COM class and get a <b>Type</b> object for that COM class by using the  tool.</p>
</dd>
</dl><b>See also: 
			</b><br> <a href="#IsCOMObjectImpl">Type.IsCOMObjectImpl</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsContextfulTopic1"></a><a name="IsContextful">IsContextful</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> can be hosted in a context.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsContextful {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> A context intercepts calls to the class members and enforces policies that are applied to the class, such as synchronization. For more detailed information on remoting contexts, see  <a href="../../System.Runtime.Remoting.Contexts/types/Context.html">Context</a>.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>

public class MyContextBoundClass: ContextBoundObject
{
   public string myString = "This class demonstrates the isContextful and isMarshalByRef properties.";
}

public class MyTypeDemoClass
{
   public static void Main()
   {
      try
      {
         // Check if the types can be hosted in a Context.
         Console.WriteLine ("The Contextful property for the '{0}' type is: {1}", typeof(MyTypeDemoClass).Name, typeof(MyTypeDemoClass).IsContextful);
         Console.WriteLine ("The Contextful property for the '{0}' type is: {1}", typeof(MyContextBoundClass).Name, typeof(MyContextBoundClass).IsContextful);

         // Check if the types are marshalled by reference.
         Console.WriteLine ("The MarshalByRef property of '{0}' is: {1} ", typeof(MyTypeDemoClass).Name, typeof(MyTypeDemoClass).IsMarshalByRef);
         Console.WriteLine ("The MarshalByRef property of '{0}' is: {1} ", typeof(MyContextBoundClass).Name, typeof(MyContextBoundClass).IsMarshalByRef);
         // Check if the types are primitive datatypes.
         Console.WriteLine ("'{0}' is a primitive datatype : {1} ", typeof(int).Name, typeof(int).IsPrimitive);
         Console.WriteLine ("'{0}' is a primitive datatype : {1} ", typeof(string).Name, typeof(string).IsPrimitive);
      } 
      catch (Exception e)
      {
         Console.WriteLine("The following exception is raised : " + e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#IsContextfulImpl">Type.IsContextfulImpl</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsEnumTopic1"></a><a name="IsEnum">IsEnum</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the current  <a href="../../System/types/Type.html">Type</a> represents an enumeration.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsEnum {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This property returns <b>true</b> for an enumeration, but not for the  <a href="../../System/types/Enum.html">Enum</a> type itself, which is a class.<p> This property is read-only.</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following example demonstrates using the <b>IsEnum</b> property.<pre>
using System;
public enum Color 
{
Red, Blue, Green
}
class TestIsEnum 
{
   public static void Main() 
   {
   Type colorType = typeof(Color);
   Type enumType = typeof(Enum);
   Console.WriteLine("Color is enum? {0}", colorType.IsEnum);
   Console.WriteLine("Color is valueType? {0}", colorType.IsValueType);
   Console.WriteLine("Enum is enum Type? {0}", enumType.IsEnum);
   Console.WriteLine("Enum is value? {0}", enumType.IsValueType);
   }
}

    </pre>
<p> This code produces the following output: </p>
<pre>
              				Color is enum? True
              				Color is valueType? True
              				Enum is enum Type? False
              				Enum is value? False
              			
            </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsExplicitLayoutTopic1"></a><a name="IsExplicitLayout">IsExplicitLayout</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the class layout attribute <b>ExplicitLayout</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsExplicitLayout {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#LayoutMask">TypeAttributes.LayoutMask</a> is used to select the class layout attributes. The class layout attributes (<b>AutoLayout</b><i>,</i><b>SequentialLayout</b> and <b>ExplicitLayout</b>) define how the fields of the class instance are laid out in memory.<p> Classes marked with the <b>ExplicitLayout</b> attribute cause the loader to ignore field sequence and to use the explicit layout rules provided, in the form of field offsets, overall class size and alignment, or all of these.</p>
<p> Use the <b>ExplicitLayout</b> attribute to specify the offsets at which each field starts, or to specify the overall size and, optionally, the packing size of the objects of the class. The packing size is the empty memory space between fields and must be 1, 2, 4, 8 or 16 bytes.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
//The class is selected for the ExplicitLayout.
[StructLayoutAttribute(LayoutKind.Explicit)]
public class MyDemoAttribute
{
}

public class MyTypeClass
{
   public static void Main(string[] args)
   {
      MyIsExplicitLayoutMethod("MyDemoAttribute");     
   }
   public static void MyIsExplicitLayoutMethod(string typeName)
   {
     try
      {
         // Create an object of 'Type' class using the 'GetType' method.
         Type  myType=Type.GetType(typeName);
         // Get and display the 'IsExplicitLayout' property.
         Console.WriteLine("\n'MyDemoAttribute' instance's 'IsExplicitLayout' property is: {0}.",myType.IsExplicitLayout); 
      }
      catch(Exception e)
      {
         Console.WriteLine("\nThe following exception is raised: {0}." ,e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsAutoLayout">Type.IsAutoLayout</a> |  <a href="#IsLayoutSequential">Type.IsLayoutSequential</a> | <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconmetadataoverview.asp">MSDN: metadataoverview</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsImportTopic1"></a><a name="IsImport">IsImport</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> was imported from another class.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsImport {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsInterfaceTopic1"></a><a name="IsInterface">IsInterface</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is an interface; that is, not a class or a value type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsInterface {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#ClassSemanticsMask">TypeAttributes.ClassSemanticsMask</a> distinguishes a type declaration as class, interface or value type.<p> This property is read-only.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
// Interface declaration.
interface myIFace
{

}

class MyIsInterface 
{
   public static void Main(string []args)
   {
      try
      {
         // Get the attribute IsInterface for myIFace.
         bool myBool1 = typeof(myIFace).IsInterface;    
         //Display the IsInterface attribute for myIFace.
         Console.WriteLine("The type mentioned is an interface: {0}",myBool1);
         // Get the attribute IsInterface for MyIsInterface.
         bool myBool2 = typeof(MyIsInterface).IsInterface;    
         //Display the IsInterface attribute for MyIsInterface.
         Console.WriteLine("The type mentioned is an interface: {0}",myBool2);         
      }
      catch(Exception e)
      {
         Console.WriteLine("\nThe following exception is raised : {0}",e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsClass">Type.IsClass</a> |  <a href="#IsValueType">Type.IsValueType</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsLayoutSequentialTopic1"></a><a name="IsLayoutSequential">IsLayoutSequential</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the class layout attribute <b>SequentialLayout</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsLayoutSequential {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#LayoutMask">TypeAttributes.LayoutMask</a> is used to select the class layout attributes. The class layout attributes (<b>AutoLayout</b><i>,</i><b>SequentialLayout</b> and <b>ExplicitLayout</b>) define how the fields of the class instance are laid out in memory.<p> Classes marked with the <b>SequentialLayout</b> attribute guides the loader to preserve field order as emitted, but otherwise the specific offsets are calculated based on the common language runtime type of the field; these may be shifted by explicit offset, padding, or alignment information.</p>
<p> Use the <b>SequentialLayout</b> attribute to layout the objects of the class sequentially and to specify the packing size between adjacent fields. The packing size is the empty memory space between fields and must be 1, 2, 4, 8 or 16 bytes. A field will be aligned to its natural size or to the packing size, whichever results in a smaller offset.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
// MyTypeSequential1 class declaration.
class MyTypeSequential1
{
}

[StructLayoutAttribute(LayoutKind.Sequential)]
class MyTypeSequential2
{
   public static void Main(string []args)
   {
      try
      {
         // Create an instance of 'myTypeSeq1' class.
         MyTypeSequential1 myObj1 = new MyTypeSequential1();
         Type myTypeObj1 = myObj1.GetType();
         // Check and displays the attribute 'SequentialLayout'.
         Console.WriteLine("\nThe object myObj1 has 'IsLayoutSequential': {0}", myObj1.GetType().IsLayoutSequential);
         // Create an instance of 'myTypeSeq2' class.
         MyTypeSequential2 myObj2 = new MyTypeSequential2();
         Type myTypeObj2 = myObj2.GetType();
         // Check and displays the attribute 'SequentialLayout'.
         Console.WriteLine("\nThe object myObj2 has 'IsLayoutSequential': {0}", myObj2.GetType().IsLayoutSequential);
      }
      catch(Exception e)
      {
         Console.WriteLine("\nThe following exception is raised: {0}",e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsAutoLayout">Type.IsAutoLayout</a> |  <a href="#IsExplicitLayout">Type.IsExplicitLayout</a> | <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconmetadataoverview.asp">MSDN: metadataoverview</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsMarshalByRefTopic1"></a><a name="IsMarshalByRef">IsMarshalByRef</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the Type is marshaled by reference.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsMarshalByRef {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>

public class MyContextBoundClass: ContextBoundObject
{
   public string myString = "This class demonstrates the isContextful and isMarshalByRef properties.";
}

public class MyTypeDemoClass
{
   public static void Main()
   {
      try
      {
         // Check if the types can be hosted in a Context.
         Console.WriteLine ("The Contextful property for the '{0}' type is: {1}", typeof(MyTypeDemoClass).Name, typeof(MyTypeDemoClass).IsContextful);
         Console.WriteLine ("The Contextful property for the '{0}' type is: {1}", typeof(MyContextBoundClass).Name, typeof(MyContextBoundClass).IsContextful);

         // Check if the types are marshalled by reference.
         Console.WriteLine ("The MarshalByRef property of '{0}' is: {1} ", typeof(MyTypeDemoClass).Name, typeof(MyTypeDemoClass).IsMarshalByRef);
         Console.WriteLine ("The MarshalByRef property of '{0}' is: {1} ", typeof(MyContextBoundClass).Name, typeof(MyContextBoundClass).IsMarshalByRef);
         // Check if the types are primitive datatypes.
         Console.WriteLine ("'{0}' is a primitive datatype : {1} ", typeof(int).Name, typeof(int).IsPrimitive);
         Console.WriteLine ("'{0}' is a primitive datatype : {1} ", typeof(string).Name, typeof(string).IsPrimitive);
      } 
      catch (Exception e)
      {
         Console.WriteLine("The following exception is raised : " + e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#IsMarshalByRefImpl">Type.IsMarshalByRefImpl</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsNestedAssemblyTopic1"></a><a name="IsNestedAssembly">IsNestedAssembly</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is nested and visible only within its own assembly.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsNestedAssembly {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#VisibilityMask">TypeAttributes.VisibilityMask</a> selects the visibility attributes.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
// Enclose a class.
class MyClassA
{
   // Internal nested class.
   internal class MyClassB
   {
   }
}
class MyTestClass
{
   public static void Main(string[] args)
   {  
      // Get the Type of the nested class.
      Type myTypeB = typeof(MyClassA.MyClassB);
      // Get the 'IsNestedAssembly' property  of the nested class
      // 'Type'.
      Console.WriteLine("\nThe nested class has the property 'IsNestedAssembly' value: "+ 
                         myTypeB.IsNestedAssembly.ToString());
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsNestedFamANDAssemTopic1"></a><a name="IsNestedFamANDAssem">IsNestedFamANDAssem</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is nested and visible only to classes that belong to both its own family and its own assembly.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsNestedFamANDAssem {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#VisibilityMask">TypeAttributes.VisibilityMask</a> selects the visibility attributes.<p> A  <a href="../../System/types/Type.html">Type</a> object's family is defined as all objects of the exact same  <a href="../../System/types/Type.html">Type</a> and of its subtypes.</p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsNestedFamilyTopic1"></a><a name="IsNestedFamily">IsNestedFamily</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is nested and visible only within its own family.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsNestedFamily {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#VisibilityMask">TypeAttributes.VisibilityMask</a> selects the visibility attributes.<p> A  <a href="../../System/types/Type.html">Type</a> object's family is defined as all objects of the exact same  <a href="../../System/types/Type.html">Type</a> and of its subtypes.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
// Enclose a class.
class MyClassA
{
   // Protected nested class.
   protected class MyClassB
   {
   }   
}
class MyTestClass : MyClassA
{
   public static void Main(string[] args)
   {  
      // Get the Type of the nested class.
      Type myTypeB = typeof(MyClassA.MyClassB);
      // Get the 'IsNestedFamily' property the of the nested class
      // 'Type'.
      Console.WriteLine("\nThe nested class has the property 'IsNestedFamily' value: "+
                        myTypeB.IsNestedFamily.ToString());      
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsNestedFamORAssemTopic1"></a><a name="IsNestedFamORAssem">IsNestedFamORAssem</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is nested and visible only to classes that belong to either its own family or to its own assembly.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsNestedFamORAssem {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#VisibilityMask">TypeAttributes.VisibilityMask</a> selects the visibility attributes.<p> A  <a href="../../System/types/Type.html">Type</a> object's family is defined as all objects of the exact same  <a href="../../System/types/Type.html">Type</a> and of its subtypes.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
// Enclose a class.
class MyClassA
{
   // Protected internal nested class.
   protected internal class MyClassB
   {
   }
}
class MyTestClass 
{
   public static void Main(string[] args)
   {        
      // Get the Type of the nested class.
      Type myTypeB = typeof(MyClassA.MyClassB);
      // Get the 'IsNestedFamORAssem' property of the nested class 
      // 'Type'.
      Console.WriteLine("\nThe nested class has the property 'IsNestedFamORAssem' value: "+
                        myTypeB.IsNestedFamORAssem.ToString()); 
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsNestedPrivateTopic1"></a><a name="IsNestedPrivate">IsNestedPrivate</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is nested and declared private.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsNestedPrivate {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#VisibilityMask">TypeAttributes.VisibilityMask</a> selects the visibility attributes.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
// Outer class.
public class MyClassA
{
   // Private nested class.
   private class MyClassB
   {
   }
   public static void Main(string[] args)
   {	
      // Get the Type of the nested class.
      Type myTypeB = typeof(MyClassA.MyClassB);
      // Get the 'IsNestedPrivate' property of the nested class 'Type'.
      Console.WriteLine("\nThe nested class has the property 'IsNestedPrivate'value: "+
                        myTypeB.IsNestedPrivate.ToString());	
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsNestedPublicTopic1"></a><a name="IsNestedPublic">IsNestedPublic</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether a class is nested and declared public.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsNestedPublic {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#VisibilityMask">TypeAttributes.VisibilityMask</a> selects the visibility attributes.</dd>
</dl><b>Example</b><dl>
<dd> The following example demonstrates the <b>IsNestedPublic</b> property. A nested class MyClassB is declared as public and the <b>IsNestedPublic</b> property value is displayed.<pre>

using System;

// Enclose a class.
public class MyClassA
{
   // Public nested class.
   public class MyClassB
   {
   }
   public static void Main(string[] args)
   {	
      // Get the Type of the nested class.
      Type myTypeB = typeof(MyClassA.MyClassB);
      // Get the 'IsNestedPublic' property of the nested class
      // 'Type'.
      Console.WriteLine("\nThe nested class has the property 'IsNestedPublic' value: "+
                        myTypeB.IsNestedPublic.ToString());			
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsNotPublicTopic1"></a><a name="IsNotPublic">IsNotPublic</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the top-level  <a href="../../System/types/Type.html">Type</a> is not declared public.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsNotPublic {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd><b>IsPublic</b> and <b>IsNotPublic</b> get the visibility of the top-level type only.<p> <a href="../../System.Reflection/types/TypeAttributes.html#VisibilityMask">TypeAttributes.VisibilityMask</a> selects the visibility attributes.</p>
</dd>
</dl><b>Example</b><dl>
<dd> This example shows the use of <b>IsNotPublic</b> to get the visibility of the top-level type.<pre>
 using System;
 using System.IO;
 using System.Reflection;
 
 class MyMemberInfo { 
 
   public static void Main(string[] args) { 
 
    Console.WriteLine ("\nReflection.MemberInfo");
 
    //Get the Type and MemberInfo 
 
    Type MyType =Type.GetType("System.IO.File");
 
    MemberInfo[] Mymemberinfoarray = MyType.GetMembers();
 
    //Get and display the DeclaringType method
 
    Console.WriteLine("\nThere are {0} members in {1}.",
       Mymemberinfoarray.Length, MyType.FullName);
 
    Console.WriteLine("Is {0} public? {1}", MyType.FullName,
       MyType.IsPublic.ToString());
   }
 }

    </pre>
<p> This code produces the following output: </p>
<p> There are 27 members in System.IO.File.</p>
<p> Is System.IO.File public? False </p>
<p> The following code example demonstrates why you cannot use <b>IsPublic</b> and <b>IsNotPublic</b> for nested classes.</p>
<pre>
public class A {
   public class B { }
   private class C { }
}

    </pre>
<p> For nested classes, ignore the results of <b>IsPublic</b> and <b>IsNotPublic</b> and pay attention only to the results of <b>IsNestedPublic</b> and <b>IsNestedPrivate</b>. The reflection output for this code fragment would be as follows: </p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Class
                </TH>
<TH>
                  IsNotPublic
                </TH>
<TH>
                  IsPublic
                </TH>
<TH>
                  IsNestedPublic
                </TH>
<TH>
                  IsNestedPrivate
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  A
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  TRUE
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  FALSE
                </TD>
</TR>
<TR valign="top">
<TD>
                  B
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  TRUE
                </TD>
<TD>
                  FALSE
                </TD>
</TR>
<TR valign="top">
<TD>
                  C
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  TRUE
                </TD>
</TR>
</table>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsPointerTopic1"></a><a name="IsPointer">IsPointer</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is a pointer.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsPointer {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This property is read-only.</dd>
</dl><b>See also: 
			</b><br> <a href="#IsPointerImpl">Type.IsPointerImpl</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsPrimitiveTopic1"></a><a name="IsPrimitive">IsPrimitive</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is one of the primitive types.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsPrimitive {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The primitive types are  <a href="../../System/types/Boolean.html">Boolean</a>,  <a href="../../System/types/Byte.html">Byte</a>,  <a href="../../System/types/SByte.html">SByte</a>,  <a href="../../System/types/Int16.html">Int16</a>,  <a href="../../System/types/UInt16.html">UInt16</a>,  <a href="../../System/types/Int32.html">Int32</a>,  <a href="../../System/types/UInt32.html">UInt32</a>,  <a href="../../System/types/Int64.html">Int64</a>,  <a href="../../System/types/UInt64.html">UInt64</a>,  <a href="../../System/types/Char.html">Char</a>,  <a href="../../System/types/Double.html">Double</a>, and  <a href="../../System/types/Single.html">Single</a>.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
         // Check if the types are primitive datatypes.
         Console.WriteLine ("'{0}' is a primitive datatype : {1} ", typeof(int).Name, typeof(int).IsPrimitive);
         Console.WriteLine ("'{0}' is a primitive datatype : {1} ", typeof(string).Name, typeof(string).IsPrimitive);

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/Boolean.html">Boolean</a> |  <a href="../../System/types/Byte.html">Byte</a> |  <a href="../../System/types/SByte.html">SByte</a> |  <a href="../../System/types/Int16.html">Int16</a> |  <a href="../../System/types/UInt16.html">UInt16</a> |  <a href="../../System/types/Int32.html">Int32</a> |  <a href="../../System/types/UInt32.html">UInt32</a> |  <a href="../../System/types/Int64.html">Int64</a> |  <a href="../../System/types/UInt64.html">UInt64</a> |  <a href="../../System/types/Char.html">Char</a> |  <a href="../../System/types/Double.html">Double</a> |  <a href="../../System/types/Single.html">Single</a> |  <a href="#IsPrimitiveImpl">Type.IsPrimitiveImpl</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsPublicTopic1"></a><a name="IsPublic">IsPublic</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the top-level  <a href="../../System/types/Type.html">Type</a> is declared public.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsPublic {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd><b>IsPublic</b> and <b>IsNotPublic</b> get the visibility of the top-level type only.<p> <a href="../../System.Reflection/types/TypeAttributes.html#VisibilityMask">TypeAttributes.VisibilityMask</a> selects the visibility attributes.</p>
</dd>
</dl><b>Example</b><dl>
<dd> This example shows the use of <b>IsPublic</b> to get the visibility of the top-level type.<pre>
 using System;
 using System.IO;
 using System.Reflection;
 
 class MyMemberInfo { 
 
   public static void Main(string[] args) { 
 
    Console.WriteLine ("\nReflection.MemberInfo");
 
    //Get the Type and MemberInfo 
 
    Type MyType =Type.GetType("System.IO.File");
 
    MemberInfo[] Mymemberinfoarray = MyType.GetMembers();
 
    //Get and display the DeclaringType method
 
    Console.WriteLine("\nThere are {0} members in {1}.",
       Mymemberinfoarray.Length, MyType.FullName);
 
    Console.WriteLine("Is {0} public? {1}", MyType.FullName,
       MyType.IsPublic.ToString());
   }
 }

    </pre>
<p> This code produces the following output: </p>
<p> There are 27 members in System.IO.File.</p>
<p> Is System.IO.File public? True </p>
<p> The following code example demonstrates why you cannot use <b>IsPublic</b> and <b>IsNotPublic</b> for nested classes.</p>
<pre>
public class A {
   public class B { }
   private class C { }
}

    </pre>
<p> For nested classes, ignore the results of <b>IsPublic</b> and <b>IsNotPublic</b> and pay attention only to the results of <b>IsNestedPublic</b> and <b>IsNestedPrivate</b>. The reflection output for this code fragment would be as follows: </p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Class
                </TH>
<TH>
                  IsNotPublic
                </TH>
<TH>
                  IsPublic
                </TH>
<TH>
                  IsNestedPublic
                </TH>
<TH>
                  IsNestedPrivate
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  A
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  TRUE
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  FALSE
                </TD>
</TR>
<TR valign="top">
<TD>
                  B
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  TRUE
                </TD>
<TD>
                  FALSE
                </TD>
</TR>
<TR valign="top">
<TD>
                  C
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  TRUE
                </TD>
</TR>
</table>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsSealedTopic1"></a><a name="IsSealed">IsSealed</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is declared sealed.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsSealed {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
      // Declare class 'MyTestClass' as sealed.
      sealed public class MyTestClass
      {
      }
      public static void Main(string []args)
      {
         try
         {
            bool myBool = false;
            MyTestClass myTestClassInstance = new MyTestClass();
            // Get Type of 'myTestClassInstance'.
            Type   myType = myTestClassInstance.GetType();
            // Get the 'IsSealed' property of the 'MyTestClass' instance.
            myBool = myType.IsSealed;
            Console.WriteLine("\n{0} class is Sealed: {1}.",myType.FullName,myBool.ToString ());
         }
         catch (Exception e)
         {
            Console.WriteLine("\nThe following exception is raised: {0}",e.Message);
         }
      }

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsSerializableTopic1"></a><a name="IsSerializable">IsSerializable</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is serializable.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsSerializable {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
      // Declare a class as public with [Serializable] attribute.
      [Serializable] public class MyTestClass 
      {
      }
      public static void Main(string []args)
      {
         try
         {
            bool myBool = false;
            MyTestClass myTestClassInstance = new MyTestClass();
            // Get Type of 'myTestClassInstance'.
            Type myType = myTestClassInstance.GetType();
            // Get the 'IsSerializable' property of the 'MyTestClass' instance.
            myBool = myType.IsSerializable;
            Console.WriteLine("\n{0} class is Serializable: {1}.",myType.FullName,myBool.ToString ());
         }
         catch (Exception e)
         {
            Console.WriteLine("\nThe following exception is raised: {0}",e.Message);
         }
      }

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="../../System.Runtime.Serialization/types/ISerializable.html">ISerializable</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsSpecialNameTopic1"></a><a name="IsSpecialName">IsSpecialName</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> has a name that requires special handling.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsSpecialName {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of types that might require special treatment by some compilers.</dd>
</dl><b>Example</b><dl>
<dd> This example shows a use of <b>IsSpecialName</b> to filter internal or private members out of a list.<pre>
private void DumpMethods(Type aType)
 {
 if (!ShowMethods)
 return;
 MethodInfo[] mInfo = aType.GetMethods();
 myWriter.WriteLine("Methods"); 
 bool found = false;            
 
   if (mInfo.Length != 0)
   {
    for ( int i=0; i &lt; mInfo.Length; i++ )
    {
    // Only display methods declared in this type. Also 
    // filter out any methods with special names, because these
    // cannot be generally called by the user. That is, their 
    // functionality is usually exposed in other ways, for example,
    // property get/set methods are exposed as properties.
             
     if (mInfo[i].DeclaringType == aType &amp;&amp; !mInfo[i].IsSpecialName)
     {        
      found = true;
      StringBuilder modifiers = new StringBuilder();
      if (mInfo[i].IsStatic)   {modifiers.Append("static ");}     
      if (mInfo[i].IsPublic)   {modifiers.Append("public ");}     
      if (mInfo[i].IsFamily)   {modifiers.Append("protected ");}     
      if (mInfo[i].IsAssembly) {modifiers.Append("internal ");}     
      if (mInfo[i].IsPrivate)  {modifiers.Append("private ");}     
    myWriter.WriteLine("{0} {1}", modifiers, mInfo[i]);
      }
    }                      
  }                    
      if (!found)
      {
       myWriter.WriteLine("(none)");
      }
 }

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsUnicodeClassTopic1"></a><a name="IsUnicodeClass">IsUnicodeClass</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the string format attribute <b>UnicodeClass</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsUnicodeClass {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#StringFormatMask">TypeAttributes.StringFormatMask</a> is used to select the string format attributes. The string format attributes enhance interoperability by defining how strings should be interpreted.</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsAnsiClass">Type.IsAnsiClass</a> |  <a href="#IsAutoClass">Type.IsAutoClass</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsValueTypeTopic1"></a><a name="IsValueType">IsValueType</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is a value type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsValueType {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Value types are those that are represented as sequences of bits; value types are not classes or interfaces. These are referred to as "structs" in some programming languages. Enums are a special case of value types.<p> This property returns true for enumerations, but not for the  <a href="../../System/types/Enum.html">Enum</a> type itself, which is a class. For an example that demonstrates this behavior, see  <a href="#IsEnum">Type.IsEnum</a>.</p>
<p> This property is read-only.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
      // Declare enum type.
      enum MyEnum
      {
         One,
         Two
      }
      public static void Main(string []args)
      {
         try
         {
            bool myBool = false;
            MyEnum myTestEnum = MyEnum.One;
            // Get Type of 'myTestEnum'.
            Type   myType = myTestEnum.GetType();
            // Get the 'IsValueType' property of the 'MyTestEnum' 
            // of variable.
            myBool = myType.IsValueType;
            Console.WriteLine("\n {0} is value type: {1}.",myType.FullName,myBool.ToString());
         }
         catch (Exception e)
         {
            Console.WriteLine("\nThe following exception is raised: {0}",e.Message);
         }
      }

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsClass">Type.IsClass</a> |  <a href="#IsInterface">Type.IsInterface</a> |  <a href="../../System/types/ValueType.html">ValueType</a> |  <a href="#IsValueTypeImpl">Type.IsValueTypeImpl</a> |  <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsClass">Type.IsClass</a> |  <a href="#IsInterface">Type.IsInterface</a> |  <a href="../../System/types/ValueType.html">ValueType</a> |  <a href="#IsValueTypeImpl">Type.IsValueTypeImpl</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="MemberTypeTopic1"></a><a name="MemberType">MemberType</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a bitmask indicating the member type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Reflection/types/MemberTypes.html">MemberTypes</a> MemberType {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd> The following code example shows the <b>MemberType</b> field as a parameter to the <b>GetMember</b> method: <pre>
MemberInfo[] others = t.GetMember(mi.Name, mi.MemberType, BindingFlags.Public |
BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Instance);

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MemberTypes.html">MemberTypes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="ModuleTopic1"></a><a name="Module">Module</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the module (the DLL) in which the current  <a href="../../System/types/Type.html">Type</a> is defined.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System.Reflection/types/Module.html">Module</a> Module {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/Module.html">Module</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="NameTopic1"></a><a name="Name">Name</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System.Reflection/types/MemberInfo.html#Name">System.Reflection.MemberInfo.Name</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the name of this member.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/String.html">string</a> Name {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Only the simple name is returned, not the fully qualified name. For example, for a member System.Reflection.MemberTypes.Field, the Name property would be Field.<p> To get the Name property, get the class  <a href="../../System/types/Type.html">Type</a>. From the <b>Type</b>, get the  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> array. From a <b>MemberInfo</b> element of the array, obtain the <b>Name</b> property.</p>
</dd>
</dl><b>Example</b><dl>
<dd> This example lists the <b>Name</b> and <b>DeclaringType</b> property of each member of the <b>System.Empty</b> class.<pre>
using System;
using System.Reflection;
 
class Mymemberinfo
 {
    public static int Main()
    {
       Console.WriteLine ("\nReflection.MemberInfo");
       
       //Get the Type and MemberInfo.
       Type MyType = Type.GetType("System.Empty");
       MemberInfo[] Mymemberinfoarray = MyType.GetMembers();
  
       //Get and display the DeclaringType method.
       Console.Write("\nThere are {0} members in ",
          Mymemberinfoarray.GetLength(0));
       Console.Write("{0}.", MyType.FullName);
  
       foreach (MemberInfo Mymemberinfo in Mymemberinfoarray)
       {
          Console.Write("\n" + Mymemberinfo.Name
             + " declaring type - " +
              Mymemberinfo.DeclaringType);
       }
  
       return 0;
    }
 }
 /*
 This code produces the following output:

Reflection.MemberInfo

There are 6 members in System.Empty.
Value declaring type - System.Empty
GetObjectData declaring type - System.Empty
GetHashCode declaring type - System.Object
Equals declaring type - System.Object
ToString declaring type - System.Empty
GetType declaring type - System.Object
 */

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="NamespaceTopic1"></a><a name="Namespace">Namespace</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the namespace of the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/String.html">string</a> Namespace {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> A namespace is a logical design-time naming convenience, used mainly to define scope in an application and organize classes and other types in a single hierarchical structure. From the viewpoint of the runtime, there are no namespaces.</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/String.html">String</a> |  <a href="#FullName">Type.FullName</a> |  <a href="#AssemblyQualifiedName">Type.AssemblyQualifiedName</a> | <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconSpecifyingFullyQualifiedTypeNames.asp">MSDN: specifyingfullyqualifiedtypenames</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="ReflectedTypeTopic1"></a><a name="ReflectedType">ReflectedType</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the class object that was used to obtain this member.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Type.html">Type</a> ReflectedType {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This property implements the abstract property inherited from  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a>.</dd>
</dl><b>Example</b><dl>
<dd> This example displays the reflected type of a method in a derived class. Although the method <b>m</b> is declared in <b>MyClassA</b>, its reflected type is obtained from <b>MyClassB</b>.<pre>
using System;
using System.Reflection;
 
public abstract class rtype {
    public abstract class MyClassA {
        public abstract int m(); 
    }

    public abstract class MyClassB : MyClassA {
    }

    public static void Main(string[] args) { 
        Console.WriteLine("Reflected type of m is {0}",
            typeof(MyClassB).GetMethod("m").ReflectedType);
    }
}

    </pre>
<p> This code produces the following output: </p>
<p> Reflected type of m is rtype+MyClassB </p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> |  <a href="#DeclaringType">Type.DeclaringType</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="TypeHandleTopic1"></a><a name="TypeHandle">TypeHandle</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the handle for the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/RuntimeTypeHandle.html">RuntimeTypeHandle</a> TypeHandle {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd><b>TypeHandle</b> encapsulates a pointer to an internal data structure that represents the type. This handle is unique during the process lifetime. The handle is valid only in the application domain in which it was obtained.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
class MyClass
{
   public int myField = 10;
}

class Type_TypeHandle
{
   public static void Main()
   {
      try
      {
         MyClass myClass = new MyClass();

         // Get the Type of 'MyClass'.
         Type myClassType = myClass.GetType();

         // Get the runtimehandle of 'MyClass'.
         RuntimeTypeHandle myClassHandle = myClassType.TypeHandle;
         
         DisplayTypeHandle(myClassHandle);
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception : {0} " , e.Message );
      }
   }

   public static void DisplayTypeHandle(RuntimeTypeHandle myTypeHandle)
   {
      // Get the type from the handle.
      Type myType = Type.GetTypeFromHandle(myTypeHandle);      
      // Display the type.
      Console.WriteLine("\nDisplaying the type from the handle.\n");
      Console.WriteLine("The type is : '{0}' ", myType.ToString());
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/RuntimeTypeHandle.html">RuntimeTypeHandle</a> |  <a href="#GetTypeHandle(System.Object)">Type.GetTypeHandle</a> |  <a href="#GetTypeFromHandle(System.RuntimeTypeHandle)">Type.GetTypeFromHandle</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="TypeInitializerTopic1"></a><a name="TypeInitializer">TypeInitializer</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the initializer for the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> TypeInitializer {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Class initializers are available through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>, and  <a href="#GetConstructors">Type.GetConstructors</a>.</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="UnderlyingSystemTypeTopic1"></a><a name="UnderlyingSystemType">UnderlyingSystemType</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Indicates the type provided by the common language runtime that represents this type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/Type.html">Type</a> UnderlyingSystemType {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#UnderlyingSystemType">IReflect.UnderlyingSystemType</a></dd>
</dl><b>See also: 
			</b><br> <a href="#BaseType">Type.BaseType</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="EqualsTopic1"></a><a name="Equals(System.Object)">Equals</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>o</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Determines if the underlying system type of the current  <a href="../../System/types/Type.html">Type</a> is the same as the underlying system type of the specified  <a href="../../System/types/Object.html">Object</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Boolean.html">bool</a> Equals(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>o</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>o</i><br><dl>
<dd>
<param> The  <a href="../../System/types/Object.html">Object</a> whose underlying system type is to be compared with the underlying system type of the current  <a href="../../System/types/Type.html">Type</a>.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the underlying system type of <i>o</i> is the same as the underlying system type of the current  <a href="../../System/types/Type.html">Type</a>; otherwise, <b>false</b>. This method also returns <b>false</b> if the object specified by the <i>o</i> parameter is not a <b>Type</b>.</dd>
</dl><b>Remarks</b><dl>
<dd> This method overrides  <a href="../../System/types/Object.html#Equals(System.Object)">Object.Equals</a>.</dd>
</dl><b>Example</b><dl>
<dd> The following example uses <b>Equals</b> to compare two <b>Object</b> instances.<pre>
using System;
 using System.Reflection;
 
 class EqType
 {
   public static void Main(String[] args)
   {
    Type a = typeof(EqType);
    Type b = typeof(Type);
    Console.WriteLine("{0}", a.Equals(b).ToString());
    b = (new EqType()).GetType();
    Console.WriteLine("{0}", a.Equals(b).ToString());
   }
 }
 
 //This code produces the following output:
 //False
 //True

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#UnderlyingSystemType">Type.UnderlyingSystemType</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="EqualsTopic2"></a><a name="Equals(System.Type)">Equals</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>o</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Determines if the underlying system type of the current  <a href="../../System/types/Type.html">Type</a> is the same as the underlying system type of the specified  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> Equals(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>o</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>o</i><br><dl>
<dd>
<param> The  <a href="../../System/types/Type.html">Type</a> whose underlying system type is to be compared with the underlying system type of the current  <a href="../../System/types/Type.html">Type</a>.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the underlying system type of <i>o</i> is the same as the underlying system type of the current  <a href="../../System/types/Type.html">Type</a>; otherwise, <b>false</b>.</dd>
</dl><b>Example</b><dl>
<dd> The following example uses <b>Equals</b> to compare two types.<pre>
 using System;
 using System.Reflection;
 
 class EqType
 {
   public static void Main(String[] args)
   {
    int a = 1;
    float b = 1;
    Console.WriteLine("{0}", a.Equals(b).ToString());
    b=a;
    Console.WriteLine("{0}", a.Equals(b).ToString());
   }
 }
 
 //This code produces the following output:
 //False
 //False

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#UnderlyingSystemType">Type.UnderlyingSystemType</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="FinalizeTopic1"></a><a name="Finalize">Finalize</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#Finalize">System.Object.Finalize</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            ~Type();</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="FindInterfacesTopic1"></a><a name="FindInterfaces(System.Reflection.TypeFilter,System.Object)">FindInterfaces</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/TypeFilter.html">TypeFilter</a> <i>filter</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>filterCriteria</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns an array of  <a href="../../System/types/Type.html">Type</a> objects representing a filtered list of interfaces implemented or inherited by the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/Type.html">Type[]</a> FindInterfaces(<br>   <font color="#008080"><a href="../../System.Reflection/types/TypeFilter.html">TypeFilter</a> <i>filter</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>filterCriteria</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>filter</i><br><dl>
<dd>
<param> The  <a href="../../System.Reflection/types/TypeFilter.html">TypeFilter</a> delegate that compares the interfaces against <i>filterCriteria</i>. The  <a href="../../System.Reflection/types/TypeFilter.html">TypeFilter</a> delegate that compares the interfaces against <i>filterCriteria</i>.</dd>
</dl>
</p>
</dd>
<dd>
<p><i>filterCriteria</i><br><dl>
<dd>
<param> The search criteria that determines whether an interface should be included in the returned array.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System/types/Type.html">Type</a> objects representing a filtered list of the interfaces implemented or inherited by the current  <a href="../../System/types/Type.html">Type</a>.<p> -or- </p>
<p> An empty array of type  <a href="../../System/types/Type.html">Type</a>, if no interfaces matching the filter are implemented or inherited by the current  <a href="../../System/types/Type.html">Type</a>.</p>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>filter</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/TargetInvocationException.html">TargetInvocationException</a></td>
<td> A static initializer is invoked and throws an exception.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This method can be overridden by a derived class.<p> The  <a href="../../System.Reflection/types/Module.html#FilterTypeName">Module.FilterTypeName</a> and  <a href="../../System.Reflection/types/Module.html#FilterTypeNameIgnoreCase">Module.FilterTypeNameIgnoreCase</a> delegates supplied by the  <a href="../../System.Reflection/types/Module.html">Module</a> class may also be used, in lieu of the  <a href="../../System.Reflection/types/TypeFilter.html">TypeFilter</a> delegate.</p>
<p> All of the interfaces implemented by this class are considered during the search, whether declared by a base class or this class itself.</p>
<p> This method searches the base class hierarchy, returning each of the matching interfaces each class implements as well as all the matching interfaces each of those interfaces implements (that is, the transitive closure of the matching interfaces is returned). No duplicate interfaces are returned.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
using System;
using System.Xml;
using System.Reflection;

public class MyFindInterfacesSample 
{
   public static void Main()
   {
      try
      {
         XmlDocument myXMLDoc = new XmlDocument();
         myXMLDoc.LoadXml("&lt;book genre='novel' ISBN='1-861001-57-5'&gt;" +
            "&lt;title&gt;Pride And Prejudice&lt;/title&gt;" + "&lt;/book&gt;");
         Type myType = myXMLDoc.GetType();

         // Specify the TypeFilter delegate that compares the interfaces against filter criteria.
         TypeFilter myFilter = new TypeFilter(MyInterfaceFilter);
         String[] myInterfaceList = new String[2] {"System.Collections.IEnumerable",
             "System.Collections.ICollection"};

         for(int index=0; index &lt; myInterfaceList.Length; index++)
         {
            Type[] myInterfaces = myType.FindInterfaces(myFilter, myInterfaceList[index]);
				
            if (myInterfaces.Length &gt; 0) 
            {
               Console.WriteLine("\nThe {0} implements the interface {1}", myType, myInterfaceList[index]);	
               for(int j =0;j &lt; myInterfaces.Length;j++)
                  Console.WriteLine("Interfaces supported #{0} : {1}",j,myInterfaces[j].ToString());
            }
            else
               Console.WriteLine("\nThe {0} does not implement the interface {1}",myType,myInterfaceList[index]);	
         }
      }
      catch(ArgumentNullException e)
      {
         Console.WriteLine("ArgumentNullException : " + e.Message);
      }
      catch(TargetInvocationException e)
      {
         Console.WriteLine("TargetInvocationException : " + e.Message);
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception : " + e.Message);
      }
   }
      
	public static bool MyInterfaceFilter(Type typeObj,Object criteriaObj)
	{
		if(typeObj.ToString() == criteriaObj.ToString())
		   return true;
		else
		   return false;
	}
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/Module.html">Module</a> |  <a href="../../System.Reflection/types/TypeFilter.html">TypeFilter</a> |  <a href="#GetInterface(System.String)">Type.GetInterface</a> |  <a href="#GetInterfaces">Type.GetInterfaces</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="FindMembersTopic1"></a><a name="FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">FindMembers</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/MemberTypes.html">MemberTypes</a> <i>memberType</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/MemberFilter.html">MemberFilter</a> <i>filter</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>filterCriteria</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns a filtered array of  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> objects of the specified member type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo[]</a> FindMembers(<br>   <font color="#008080"><a href="../../System.Reflection/types/MemberTypes.html">MemberTypes</a> <i>memberType</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/MemberFilter.html">MemberFilter</a> <i>filter</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>filterCriteria</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>memberType</i><br><dl>
<dd>
<param> A <b>MemberTypes</b> object indicating the type of member to search for.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>filter</i><br><dl>
<dd>
<param> The delegate that does the comparisons, returning <b>true</b> if the member currently being inspected matches the <i>filterCriteria</i> and <b>false</b> otherwise. You can use the <b>FilterAttribute</b>, <b>FilterName</b>, and <b>FilterNameIgnoreCase</b> delegates supplied by this class. The first uses the fields of <b>FieldAttributes</b>, <b>MethodAttributes</b>, and <b>MethodImplAttributes</b> as search criteria, and the other two delegates use <b>String</b> objects as the search criteria.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>filterCriteria</i><br><dl>
<dd>
<param> The search criteria that determines whether a member is returned in the array of <b>MemberInfo</b> objects.<p> The fields of <b>FieldAttributes</b>, <b>MethodAttributes</b>, and <b>MethodImplAttributes</b> can be used in conjunction with the <b>FilterAttribute</b> delegate supplied by this class.</p> The search criteria that determines whether a member is returned in the array of <b>MemberInfo</b> objects.<p> The fields of <b>FieldAttributes</b>, <b>MethodAttributes</b>, and <b>MethodImplAttributes</b> can be used in conjunction with the <b>FilterAttribute</b> delegate supplied by this class.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A filtered array of  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> objects of the specified member type.<p> -or- </p>
<p> An empty array of type  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a>, if the current  <a href="../../System/types/Type.html">Type</a> does not have members of type <i>memberType</i> that match the filter criteria.</p>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>filter</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This method can be overridden by a derived class.<p> Members include properties, methods, fields, events, and so on. If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which members to include in the search: </p>
<UL>
<li><i>Instance</i> to include instance members in the search.</li>
<li><i>Static</i> to include static members in the search.</li>
<li><i>Public</i> to include public members in the search.</li>
<li><i>NonPublic</i> to include non-public members (that is, private and protected members) in the search.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><i>DeclaredOnly</i> to search only the members declared on the  <a href="../../System/types/Type.html">Type</a>, not members that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> Valid values for MemberType are defined in MemberInfo. If no such members are found, an empty array is returned.</p>
<p> Class initializers are available through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>, and  <a href="#GetConstructors">Type.GetConstructors</a>.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre></pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMember(System.String)">Type.GetMember</a> |  <a href="#GetMembers">Type.GetMembers</a> |  <a href="#GetDefaultMembers">Type.GetDefaultMembers</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetArrayRankTopic1"></a><a name="GetArrayRank">GetArrayRank</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Gets the number of dimensions in an  <a href="../../System/types/Array.html">Array</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/Int32.html">int</a> GetArrayRank();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An  <a href="../../System/types/Int32.html">Int32</a> containing the number of dimensions in the current <b>Type</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> The functionality of this method is unsupported in the base class and must be implemented in a derived class instead.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td> The current <b>Type</b> is not an array.</td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
using System;

class MyArrayRankSample
{
   public static void Main()
   {
      try
      {
         int[,,] myArray = new int[,,] {{{12,2,35},{300,78,33}},{{92,42,135},{30,7,3}}};
         Type myType = myArray.GetType();

         Console.WriteLine("Contents of myArray: {{{12,2,35},{300,78,33}},{{92,42,135},{30,7,3}}}");
         Console.WriteLine("The rank for myArray is: {0}", myType.GetArrayRank());
      }
      catch(NotSupportedException e)
      {
         Console.WriteLine("NotSupportedException raised.");
         Console.WriteLine("Source: " + e.Source);
         Console.WriteLine("Message: " + e.Message);
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception raised.");
         Console.WriteLine("Source: " + e.Source);
         Console.WriteLine("Message: " + e.Message);
      }      
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/Array.html">Array</a> |  <a href="../../System/types/Array.html#Rank">Array.Rank</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetAttributeFlagsImplTopic1"></a><a name="GetAttributeFlagsImpl">GetAttributeFlagsImpl</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, implements the  <a href="#Attributes">Type.Attributes</a> property and gets a bitmask indicating the attributes associated with the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected abstract <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> GetAttributeFlagsImpl();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> object representing the attribute set of the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl><b>See also: 
			</b><br> <a href="#Attributes">Type.Attributes</a> |  <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetConstructorTopic1"></a><a name="GetConstructor(System.Type[])">GetConstructor</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Searches for a public instance constructor whose parameters match the types in the specified array.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> GetConstructor(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the constructor to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> to get a constructor that takes no parameters.</p>
<p> -or- </p>
<p> <a href="#EmptyTypes">Type.EmptyTypes</a>.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the constructor to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> to get a constructor that takes no parameters.</p>
<p> -or- </p>
<p> <a href="#EmptyTypes">Type.EmptyTypes</a>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> object representing the public instance constructor whose parameters match the types in the parameter type array, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>types</i> is <b>null</b>.<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> <a href="#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetConstructor</a> looks for public instance constructors and cannot be used to obtain a class initializer. Class initializers are available through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>,  <a href="#GetConstructors">Type.GetConstructors</a>, and  <a href="#TypeInitializer">Type.TypeInitializer</a>.<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p><br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>

using System;
using System.Reflection;
using System.Security;

public class MyClass1
{
   public MyClass1(){}
   public MyClass1(int i){}

   public static void Main()
   {
      try
      {
         Type myType = typeof(MyClass1);
         Type[] types = new Type[1];
         types[0] = typeof(int);
         // Get the constructor that takes an integer as a parameter.
         ConstructorInfo constructorInfoObj = myType.GetConstructor(types);
         if (constructorInfoObj != null)
         {
            Console.WriteLine("The constructor of the class MyClass1 that takes an " + 
               "integer as a parameter is: "); 
            Console.WriteLine(constructorInfoObj.ToString());
         }
         else
         {
            Console.WriteLine("The constructor of the class MyClass1 that takes an integer " +
               "as a parameter is not available."); 
         }
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception caught.");
         Console.WriteLine("Source: " + e.Source);
         Console.WriteLine("Message: " + e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetConstructorImpl</a> |  <a href="#GetConstructors">Type.GetConstructors</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetConstructorTopic2"></a><a name="GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">GetConstructor</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> GetConstructor(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the constructor to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</p>
<p> -or- </p>
<p> <a href="#EmptyTypes">Type.EmptyTypes</a>.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the constructor to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</p>
<p> -or- </p>
<p> <a href="#EmptyTypes">Type.EmptyTypes</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the parameter type array. The default binder does not process this parameter.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> object representing the constructor that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>types</i> is <b>null</b>.<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.<p> -or- </p>
<p><i>modifiers</i> is multidimensional.</p>
<p> -or- </p>
<p><i>types</i> and <i>modifiers</i> do not have the same length.</p>
</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The <i>types</i> array and the <i>modifiers</i> array have the same length. A parameter specified in the <i>types</i> array can have the following attributes, which are specified in the <i>modifiers</i> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.<p> If an exact match does not exist, the <i>binder</i> will attempt to coerce the parameter types specified in the <i>types</i> array in order to select a match. If the <i>binder</i> is unable to select a match, then <b>null</b> is returned.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which constructors to include in the search: </p>
<UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public constructors in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public constructors (that is, private and protected constructors) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static members up the hierarchy.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p> <a href="#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetConstructor</a> cannot be used to obtain a class initializer. Class initializers are available through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>,  <a href="#GetConstructors">Type.GetConstructors</a>, and  <a href="#TypeInitializer">Type.TypeInitializer</a>.<br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
using System;
using System.Reflection;
using System.Security;


public class MyClass1
{
   public MyClass1(int i){}

   public static void Main()
   {
      try
      {
         Type myType = typeof(MyClass1);
         Type[] types = new Type[1];
         types[0] = typeof(int);
         // Get the constructor that is public and takes an integer parameter.
         ConstructorInfo constructorInfoObj = myType.GetConstructor(
            BindingFlags.Instance | BindingFlags.Public, null, types, null);
         if (constructorInfoObj != null )
         {
            Console.WriteLine("The constructor of the MyClass1 class that is public " +
               "and takes an integer as a parameter is:");
            Console.WriteLine(constructorInfoObj.ToString());
         }
         else
         {
            Console.WriteLine("The constructor of the MyClass1 class that is public " +
               "and takes an integer as a parameter is not available.");
         }
      }
      catch(ArgumentNullException e)
      {
         Console.WriteLine("ArgumentNullException: " + e.Message);
      }
      catch(ArgumentException e)
      {
         Console.WriteLine("ArgumentException: " + e.Message);
      }
      catch(SecurityException e)
      {
         Console.WriteLine("SecurityException: " + e.Message);
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception: " + e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="../../System.Reflection/types/Binder.html">Binder</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetConstructorImpl</a> |  <a href="#GetConstructors">Type.GetConstructors</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetConstructorTopic3"></a><a name="GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">GetConstructor</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> GetConstructor(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>callConvention</i><br><dl>
<dd>
<param> The  <a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the constructor to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the constructor to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <i>types</i> array. The default binder does not process this parameter.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> object representing the constructor that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>types</i> is <b>null</b>.<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.<p> -or- </p>
<p><i>modifiers</i> is multidimensional.</p>
<p> -or- </p>
<p><i>types</i> and <i>modifiers</i> do not have the same length.</p>
</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Although the default binder does not process  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> (the <i>modifiers</i> parameter), you can use the abstract  <a href="../../System.Reflection/types/Binder.html">Binder</a> class to write a custom binder that does process <i>modifiers</i>.<b>ParameterModifier</b> is only used when calling through COM interop, and only parameters that are passed by reference are handled.<p> The <i>types</i> array and the <i>modifiers</i> array have the same length. A parameter specified in the <i>types</i> array can have the following attributes, which are specified in the <i>modifiers</i> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.</p>
<p> If an exact match does not exist, the <i>binder</i> will attempt to coerce the parameter types specified in the <i>types</i> array in order to select a match. If the <i>binder</i> is unable to select a match, then <b>null</b> is returned.</p>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which constructors to include in the search: </p>
<UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public constructors in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public constructors (that is, private and protected constructors) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static members up the hierarchy.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> <a href="#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetConstructor</a> cannot be used to obtain a class initializer. Class initializers are available through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>,  <a href="#GetConstructors">Type.GetConstructors</a>, and  <a href="#TypeInitializer">Type.TypeInitializer</a>.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
<p> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL><br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
using System;
using System.Reflection;
using System.Security;


public class MyClass1
{
   public MyClass1(int i){}

   public static void Main()
   {
      try
      {
         Type  myType = typeof(MyClass1);
         Type[] types = new Type[1];
         types[0] = typeof(int);
         // Get the constructor that is public, instance method and takes an integer parameter.
         ConstructorInfo constructorInfoObj = myType.GetConstructor(
            BindingFlags.Instance | BindingFlags.Public, null,
            CallingConventions.HasThis, types, null);
         if(constructorInfoObj != null)
         {
            Console.WriteLine("The constructor of the class MyClass1 that is a public " +
               "instance method and takes an integer as a parameter is: ");
            Console.WriteLine(constructorInfoObj.ToString());
         }
         else
         {
            Console.WriteLine("The Constructor of the class 'MyClass1' that is a public instance " +
               "method and takes an integer as a parameter is not available.");
         }
      }
      catch(ArgumentNullException e)
      {
         Console.WriteLine("ArgumentNullException: " + e.Message);
      }
      catch(ArgumentException e)
      {
         Console.WriteLine("ArgumentException: " + e.Message);
      }
      catch(SecurityException e)
      {
         Console.WriteLine("SecurityException: " + e.Message);
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception: " + e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="../../System.Reflection/types/Binder.html">Binder</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetConstructorImpl</a> |  <a href="#GetConstructors">Type.GetConstructors</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetConstructorImplTopic1"></a><a name="GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">GetConstructorImpl</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected abstract <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> GetConstructorImpl(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>callConvention</i><br><dl>
<dd>
<param> The  <a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the constructor to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the constructor to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <i>types</i> array. The default binder does not process this parameter.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> object representing the constructor that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>types</i> is <b>null</b>.<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.<p> -or- </p>
<p><i>modifiers</i> is multidimensional.</p>
<p> -or- </p>
<p><i>types</i> and <i>modifiers</i> do not have the same length.</p>
</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Although the default binder does not process  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> (the <i>modifiers</i> parameter), you can use the abstract  <a href="../../System.Reflection/types/Binder.html">Binder</a> class to write a custom binder that does process <i>modifiers</i>.<b>ParameterModifier</b> is only used when calling through COM interop, and only parameters that are passed by reference are handled.<p> The <i>types</i> array and the <i>modifiers</i> array have the same length. A parameter specified in the <i>types</i> array can have the following attributes, which are specified in the <i>modifiers</i> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and are used for interoperability.</p>
<p> If an exact match does not exist, the <i>binder</i> will attempt to coerce the parameter types specified in the <i>types</i> array in order to select a match. If the <i>binder</i> is unable to select a match, then <b>null</b> is returned.</p>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which constructors to include in the search: </p>
<UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public constructors in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public constructors (that is, private and protected constructors) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static members up the hierarchy.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> This method implements  <a href="#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetConstructor</a>.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
<p> <a href="#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetConstructor</a> and  <a href="#GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetConstructorImpl</a> cannot be used to obtain a class initializer. Class initializers are available only through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>, and  <a href="#GetConstructors">Type.GetConstructors</a>.</p>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="../../System.Reflection/types/Binder.html">Binder</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetConstructor</a> |  <a href="#GetConstructors">Type.GetConstructors</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetConstructorsTopic1"></a><a name="GetConstructors">GetConstructors</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns all the public constructors defined for the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo[]</a> GetConstructors();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> objects representing all the public constructors defined for the current  <a href="../../System/types/Type.html">Type</a>, including the type initializer if it is defined.<p> -or- </p>
<p> An empty array of type  <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a>, if no public constructors are defined for the current  <a href="../../System/types/Type.html">Type</a>.</p>
</dd>
</dl><b>Remarks</b><dl>
<dd> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.<br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
<p> This method calls <a href="../../System/types/Type.html#getconstructorstopic2">GetConstructors</a>. It will not find static constructors unless you explicitly pass <b>BindingFlags.Static</b>, as shown in the examples.</p>
<p> Class initializers are available through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>, and  <a href="#GetConstructors">Type.GetConstructors</a>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> This example shows the output of <b>GetConstructors()</b> from a class that has two instance constructors and one static constructor.<pre>
 using System;
 using System.Reflection;
 
 public class t {
     public t() {}
     static t() {}
     public t(int i) {}
 
     public static void Main() {
         ConstructorInfo[] p = typeof(t).GetConstructors();
         Console.WriteLine(p.Length);
 
         for (int i=0;i&lt;p.Length;i++) {
             Console.WriteLine(p[i].IsStatic);
         }
     }
 }

    </pre>
<p> The output of this code is: </p>
<p> 2 </p>
<p> False </p>
<p> False </p>
<p> Because <b>GetConstructors</b> () only calls the Public and Instance <b>BindingFlags</b>, the static constructor is neither counted by the <b>for</b> expression nor evaluated by <b>IsStatic</b>.</p>
<p> Use <b>GetConstructors</b> (BindingFlags) and pass it <b>BindingFlags.Public</b> | <b>BindingFlags.Static</b> | <b>BindingFlags.NonPublic</b> | <b>BindingFlags.Instance</b> to find static constructors, as follows: </p>
<pre>
 using System;
 using System.Reflection;
  
 public class t {
     public t() {}
     static t() {}
     public t(int i) {}
 
     public static void Main() {
         ConstructorInfo[] p = typeof(t).GetConstructors(
            BindingFlags.Public | BindingFlags.Static |
            BindingFlags.NonPublic | BindingFlags.Instance);
         Console.WriteLine(p.Length);
 
         for (int i=0;i&lt;p.Length;i++) {
             Console.WriteLine(p[i].IsStatic);
         }
     }
 }

    </pre>
<p> Now the output is: </p>
<p> 3 </p>
<p> False </p>
<p> True </p>
<p> False </p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> |  <a href="#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetConstructor</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetConstructorsTopic2"></a><a name="GetConstructors(System.Reflection.BindingFlags)">GetConstructors</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, searches for the constructors defined for the current  <a href="../../System/types/Type.html">Type</a>, using the specified <b>BindingFlags</b>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo[]</a> GetConstructors(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> objects representing all constructors defined for the current  <a href="../../System/types/Type.html">Type</a> that match the specified binding constraints, including the type initializer if it is defined.<p> -or- </p>
<p> An empty array of type  <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a>, if no constructors are defined for the current  <a href="../../System/types/Type.html">Type</a>, or if none of the defined constructors match the binding constraints.</p>
</dd>
</dl><b>Remarks</b><dl>
<dd><i>bindingAttr</i> can be used to specify whether to return only public constructors or both public and non-public constructors.<p> If an exact match does not exist, the <i>binder</i> will attempt to coerce the parameter types specified in the <i>types</i> array in order to select a match. If the <i>binder</i> is unable to select a match, then <b>null</b> is returned.</p>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which constructors to include in the search: </p>
<UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public constructors in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public constructors (that is, private and protected constructors) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static members up the hierarchy.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
<p> Class initializers are available through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>, and  <a href="#GetConstructors">Type.GetConstructors</a>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> This example shows the output of <b>GetConstructors()</b> from a class that has two instance constructors and one static constructor.<pre>
 using System;
 using System.Reflection;
 
 public class t {
     public t() {}
     static t() {}
     public t(int i) {}
 
     public static void Main() {
         ConstructorInfo[] p = typeof(t).GetConstructors();
         Console.WriteLine(p.Length);
 
         for (int i=0;i&lt;p.Length;i++) {
             Console.WriteLine(p[i].IsStatic);
         }
     }
 }

    </pre>
<p> The output of this code is: </p>
<p> 2 </p>
<p> False </p>
<p> False </p>
<p> Because <b>GetConstructors()</b> only calls the <b>Public</b> and <b>Instance</b> <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a>, the static constructor is neither counted by the <b>for</b> expression nor evaluated by <b>IsStatic</b>.</p>
<p> Use <b>GetConstructors</b> (BindingFlags) and pass it <b>BindingFlags.Public</b> | <b>BindingFlags.Static</b> | <b>BindingFlags.NonPublic</b> | <b>BindingFlags.Instance</b> to find static constructors, as follows: </p>
<pre>
 using System;
 using System.Reflection;
  
 public class t {
     public t() {}
     static t() {}
     public t(int i) {}
 
     public static void Main() {
         ConstructorInfo[] p = typeof(t).GetConstructors(
            BindingFlags.Public | BindingFlags.Static |
            BindingFlags.NonPublic | BindingFlags.Instance);
         Console.WriteLine(p.Length);
 
         for (int i=0;i&lt;p.Length;i++) {
             Console.WriteLine(p[i].IsStatic);
         }
     }
 }

    </pre>
<p> Now the output is: </p>
<p> 3 </p>
<p> False </p>
<p> True </p>
<p> False </p>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetConstructor</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetCustomAttributesTopic1"></a><a name="GetCustomAttributes(System.Boolean)">GetCustomAttributes</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>inherit</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System.Reflection/types/MemberInfo.html#GetCustomAttributes(System.Boolean)">System.Reflection.MemberInfo.GetCustomAttributes</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, returns an array of all of the custom attributes.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/Object.html">object[]</a> GetCustomAttributes(<br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>inherit</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>inherit</i><br><dl>
<dd>
<param> Specifies whether to search this member's inheritance chain to find the attributes.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of all the custom attributes, or an array with zero elements if no attributes are defined.</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/ICustomAttributeProvider.html#GetCustomAttributes(System.Boolean)">ICustomAttributeProvider.GetCustomAttributes</a></dd>
</dl><b>Example</b><dl>
<dd>
<pre>

using System;
using System.Reflection;

// Define a custom attribute with one named parameter.
[AttributeUsage(AttributeTargets.All)]
public class MyAttribute : Attribute
{
   private string myName;
   public MyAttribute(string name)
   {
      myName = name;
   }
   public string Name
   {
      get
      {
         return myName;
      }
   }
}

// Define a class which has the custom attribute associated with one of its members.
public class MyClass1
{
   [MyAttribute("This is an example attribute")]
   public void MyMethod(int i)
   {
      return;
   }
}

public class MemberInfo_GetCustomAttributes
{
   public static void Main()
   {
      try
      {
         // Get the type of the class 'MyClass1'.
         Type myType = typeof(MyClass1);
         // Get the members associated with the class 'MyClass1'.
         MemberInfo[] myMembers = myType.GetMembers();

         // Display the attributes for each of the members of the class 'MyClass1'.
         for(int i = 0; i &lt; myMembers.Length; i++)
         {
            Object[] myAttributes = myMembers[i].GetCustomAttributes(false);
            if(myAttributes.Length &gt; 0)
            {
               Console.WriteLine("\nThe attributes for the member {0} are : \n", myMembers[i]);
               for(int j = 0; j &lt; myAttributes.Length; j++)
                  Console.WriteLine("The type of the attribute is : {0}", myAttributes[j]);
            }
         }
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception Caught! "+e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/Object.html">Object</a> |  <a href="../../System.Reflection.Emit/types/CustomAttributeBuilder.html">CustomAttributeBuilder</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetCustomAttributesTopic2"></a><a name="GetCustomAttributes(System.Type,System.Boolean)">GetCustomAttributes</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>attributeType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>inherit</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System.Reflection/types/MemberInfo.html#GetCustomAttributes(System.Type,System.Boolean)">System.Reflection.MemberInfo.GetCustomAttributes</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, returns an array of custom attributes identified by  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/Object.html">object[]</a> GetCustomAttributes(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>attributeType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>inherit</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>attributeType</i><br><dl>
<dd>
<param> The type of attribute to search for. Only attributes that are assignable to this type are returned.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>inherit</i><br><dl>
<dd>
<param> Specifies whether to search this member's inheritance chain to find the attributes.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of custom attributes defined on this reflected member, or an array with zero (0) elements if no attributes are defined.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/TypeLoadException.html">TypeLoadException</a></td>
<td> If the custom attribute type can not be loaded.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/ICustomAttributeProvider.html#GetCustomAttributes(System.Type,System.Boolean)">ICustomAttributeProvider.GetCustomAttributes</a></dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetDefaultMembersTopic1"></a><a name="GetDefaultMembers">GetDefaultMembers</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the members defined for the current  <a href="../../System/types/Type.html">Type</a> whose  <a href="../../System.Reflection/types/DefaultMemberAttribute.html">DefaultMemberAttribute</a> is set.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo[]</a> GetDefaultMembers();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> objects representing all default members of the current  <a href="../../System/types/Type.html">Type</a>.<p> -or- </p>
<p> An empty array of type  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a>, if the current  <a href="../../System/types/Type.html">Type</a> does not have default members.</p>
</dd>
</dl><b>Remarks</b><dl>
<dd> This method can be overridden by a derived class.<p> Members include properties, methods, fields, events, and so on.</p>
<p> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>

using System;
using System.Reflection;
using System.IO;

[DefaultMemberAttribute("Age")]   
public class MyClass
{
   public void Name(String s) {}
      public int Age
      {
      get
         {
	 return 20;
	 }
      }
   public static void Main()
   {
      try
      {
         Type  myType = typeof(MyClass);
         MemberInfo[] memberInfoArray = myType.GetDefaultMembers();
         if (memberInfoArray.Length &gt; 0)
         {
            Console.WriteLine("The default members of the class MyClass are:\n"); 
               foreach(MemberInfo memberInfoObj in memberInfoArray)
               {
                  Console.WriteLine("The default member name is: " + memberInfoObj.ToString());
               }
         }
         else
         {
         Console.WriteLine("No default members are available."); 
         }
      }
      catch(InvalidOperationException e)
      {
         Console.WriteLine("InvalidOperationException: " + e.Message);
      }
      catch(IOException e)
      {
         Console.WriteLine("IOException: " + e.Message);
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception: " + e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> |  <a href="../../System.Reflection/types/DefaultMemberAttribute.html">DefaultMemberAttribute</a> |  <a href="#GetMember(System.String)">Type.GetMember</a> |  <a href="#GetMembers">Type.GetMembers</a> |  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetElementTypeTopic1"></a><a name="GetElementType">GetElementType</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, returns the  <a href="../../System/types/Type.html">Type</a> of the object encompassed or referred to by the current array, pointer or reference type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/Type.html">Type</a> GetElementType();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The  <a href="../../System/types/Type.html">Type</a> of the object encompassed or referred to by the current array, pointer or reference type.<p> -or- </p>
<p><b>null</b> if the current  <a href="../../System/types/Type.html">Type</a> is not an array or a pointer, or is not passed by reference.</p>
</dd>
</dl><b>Remarks</b><dl>
<dd> For example, Type.GetType("Int32[]").GetElementType returns Int32.</dd>
</dl><b>Example</b><dl>
<dd> The following example demonstrates using the <b>GetElementType</b> method.<pre>
using System;
class TestGetElementType 
{
   public static void Main() 
   {
   int[] array = {1,2,3};
   Type t = array.GetType();
   Type t2 = t.GetElementType();
   Console.WriteLine("{0} element type is {1}",array, t2.ToString());
   TestGetElementType newMe = new TestGetElementType();
   t = newMe.GetType();
   t2 = t.GetElementType();
   Console.WriteLine("{0} element type is {1}", newMe, t2==null? "null" : t2.ToString());
   }
}

    </pre>
<p> This code produces the following output: </p>
<pre>
              				System.Int32[] element type is System.Int32
              				TestGetElementType element type is null
              			
            </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#HasElementType">Type.HasElementType</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetEventTopic1"></a><a name="GetEvent(System.String)">GetEvent</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns the  <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> object representing the specified event.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> GetEvent(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of an event which is declared or inherited by the current  <a href="../../System/types/Type.html">Type</a>.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The  <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> object representing the specified event which is declared or inherited by the current  <a href="../../System/types/Type.html">Type</a>, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
<p> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
			Type myType = typeof(System.Windows.Forms.Button);
         EventInfo myEvent = myType.GetEvent("Click");
         if(myEvent != null)
         {
            Console.WriteLine("Looking for Click event in Button class.");
            Console.WriteLine(myEvent.ToString());
         }
         else
            Console.WriteLine("The Click event is not available with Button class");

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="#GetEvents">Type.GetEvents</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetEventTopic2"></a><a name="GetEvent(System.String,System.Reflection.BindingFlags)">GetEvent</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, returns the  <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> object representing the specified event, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> GetEvent(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of an event which is declared or inherited by the current  <a href="../../System/types/Type.html">Type</a>.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The  <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> object representing the specified event which is declared or inherited by the current  <a href="../../System/types/Type.html">Type</a>, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which events to include in the search: <UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public events in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public events (that is, private and protected events) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static members up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.IgnoreCase</b> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <b>IgnoreCase</b> flag.</li>
<li><b>BindingFlags.DeclaredOnly</b> to search only the events declared on the  <a href="../../System/types/Type.html">Type</a>, not events that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
         // Creates a bitmask comprising  BindingFlags.
         BindingFlags myBindingFlags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;
         Type myTypeBindingFlags = typeof(System.Windows.Forms.Button);
         EventInfo myEventBindingFlags = myTypeBindingFlags.GetEvent("Click", myBindingFlags);
         if(myEventBindingFlags != null)
         {
            Console.WriteLine("Looking for Click event in Button class with specified BindingFlags.");
            Console.WriteLine(myEventBindingFlags.ToString());
         }
         else
            Console.WriteLine("The Click event is not available with Button class");

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetEvents">Type.GetEvents</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetEventsTopic1"></a><a name="GetEvents">GetEvents</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns all the public events that are declared or inherited by the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System.Reflection/types/EventInfo.html">EventInfo[]</a> GetEvents();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> objects representing all the public events which are declared or inherited by the current  <a href="../../System/types/Type.html">Type</a>.<p> -or- </p>
<p> An empty array of type  <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a>, if the current  <a href="../../System/types/Type.html">Type</a> does not have public events.</p>
</dd>
</dl><b>Remarks</b><dl>
<dd> This method can be overridden by a derived class.<p> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
         Type myType = typeof(System.Windows.Forms.Button);
         EventInfo[] myEvents = myType.GetEvents();
         Console.WriteLine("The events on Button class are : ");
         for (int index = 0; index &lt; myEvents.Length; index++)
         {
            Console.WriteLine(myEvents[index].ToString());
         }

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> |  <a href="#GetEvent(System.String)">Type.GetEvent</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetEventsTopic2"></a><a name="GetEvents(System.Reflection.BindingFlags)">GetEvents</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, searches for events that are declared or inherited by the current  <a href="../../System/types/Type.html">Type</a>, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System.Reflection/types/EventInfo.html">EventInfo[]</a> GetEvents(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> objects representing all events which are declared or inherited by the current  <a href="../../System/types/Type.html">Type</a> that match the specified binding constraints.<p> -or- </p> An empty array of type  <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a>, if the current  <a href="../../System/types/Type.html">Type</a> does not have events, or if none of the events match the binding constraints.</dd>
</dl><b>Remarks</b><dl>
<dd> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which events to include in the search: <UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public events in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public events (that is, private and protected events) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static members up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.DeclaredOnly</b> to search only the events declared on the  <a href="../../System/types/Type.html">Type</a>, not events that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
         // Creates a bitmask comprising  BindingFlags.
         BindingFlags myBindingFlags = BindingFlags.Instance | BindingFlags.Public;  
         Type myTypeEvent = typeof(System.Windows.Forms.Button);
         EventInfo[] myEventsBindingFlags = myTypeEvent.GetEvents(myBindingFlags);
         Console.WriteLine("\nThe events on Button class with specified BindingFlags are : ");
         for (int index = 0; index &lt; myEventsBindingFlags.Length; index++)
         {
            Console.WriteLine(myEventsBindingFlags[index].ToString());
         }

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetEvent(System.String)">Type.GetEvent</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetFieldTopic1"></a><a name="GetField(System.String)">GetField</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the field with the specified name.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo</a> GetField(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the data field to get.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo</a> object representing the field with the specified name, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
public class MyFieldClassA
{
	public string field = "A Field";
	public string Field
	{
		get
		{
			return field;
		}
		set
		{
			if(field!=value)
			{
				field=value;
         }
		}
	}
}
public class MyFieldClassB
{
	public string field = "B Field";
	public string Field 
	{
		get
		{
			return field;
		}
		set
		{
			if(field!=value)
			{
				field=value;
			}
		}
	}
}

public class MyFieldInfoClass
{
	public static void Main()
	{
		try
		{
			MyFieldClassB myFieldObjectB = new MyFieldClassB();
			MyFieldClassA myFieldObjectA = new MyFieldClassA();

			Type myTypeA = Type.GetType("MyFieldClassA");
			FieldInfo myFieldInfo = myTypeA.GetField("field");
		
			Type myTypeB = Type.GetType("MyFieldClassB");
			FieldInfo myFieldInfo1 = myTypeB.GetField("field", BindingFlags.Public | BindingFlags.Instance);

			Console.WriteLine("The value of the field is : {0} ", myFieldInfo.GetValue(myFieldObjectA));
			Console.WriteLine("The value of the field is : {0} ", myFieldInfo1.GetValue(myFieldObjectB));
		}
		catch(SecurityException e)
		{
			Console.WriteLine("Exception Raised !");
			Console.WriteLine("Message :"+e.Message);
		}
		catch(ArgumentNullException e)
		{
			Console.WriteLine("Exception Raised !");
			Console.WriteLine("Message :"+e.Message);
		}
		catch(Exception e)
		{
			Console.WriteLine("Exception Raised !");
			Console.WriteLine("Message :"+e.Message);
		}
	}
}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetFields">Type.GetFields</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetFieldTopic2"></a><a name="GetField(System.String,System.Reflection.BindingFlags)">GetField</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified field, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo</a> GetField(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the data field to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo</a> object representing the field that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#GetField(System.String,System.Reflection.BindingFlags)">IReflect.GetField</a></dd>
</dl><b>Remarks</b><dl>
<dd> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.<br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which fields to include in the search: </p>
<UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public fields in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public fields (that is, private and protected fields) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static members up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.IgnoreCase</b> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <b>IgnoreCase</b> flag.</li>
<li><b>BindingFlags.DeclaredOnly</b> to search only the fields declared on the  <a href="../../System/types/Type.html">Type</a>, not fields that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
public class MyFieldClassA
{
	public string field = "A Field";
	public string Field
	{
		get
		{
			return field;
		}
		set
		{
			if(field!=value)
			{
				field=value;
         }
		}
	}
}
public class MyFieldClassB
{
	public string field = "B Field";
	public string Field 
	{
		get
		{
			return field;
		}
		set
		{
			if(field!=value)
			{
				field=value;
			}
		}
	}
}

public class MyFieldInfoClass
{
	public static void Main()
	{
		try
		{
			MyFieldClassB myFieldObjectB = new MyFieldClassB();
			MyFieldClassA myFieldObjectA = new MyFieldClassA();

			Type myTypeA = Type.GetType("MyFieldClassA");
			FieldInfo myFieldInfo = myTypeA.GetField("field");
		
			Type myTypeB = Type.GetType("MyFieldClassB");
			FieldInfo myFieldInfo1 = myTypeB.GetField("field", BindingFlags.Public | BindingFlags.Instance);

			Console.WriteLine("The value of the field is : {0} ", myFieldInfo.GetValue(myFieldObjectA));
			Console.WriteLine("The value of the field is : {0} ", myFieldInfo1.GetValue(myFieldObjectB));
		}
		catch(SecurityException e)
		{
			Console.WriteLine("Exception Raised !");
			Console.WriteLine("Message :"+e.Message);
		}
		catch(ArgumentNullException e)
		{
			Console.WriteLine("Exception Raised !");
			Console.WriteLine("Message :"+e.Message);
		}
		catch(Exception e)
		{
			Console.WriteLine("Exception Raised !");
			Console.WriteLine("Message :"+e.Message);
		}
	}
}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetFields">Type.GetFields</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetFieldsTopic1"></a><a name="GetFields">GetFields</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns all the public fields of the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo[]</a> GetFields();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo</a> objects representing all the public fields defined for the current  <a href="../../System/types/Type.html">Type</a>.<p> -or- </p>
<p> An empty array of type  <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo</a>, if no public fields are defined for the current  <a href="../../System/types/Type.html">Type</a>.</p>
</dd>
</dl><b>Remarks</b><dl>
<dd> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.<br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
			Console.WriteLine("HashCode of the System.Windows.Forms.Button type is  : {0}",
            typeof(System.Windows.Forms.Button).GetHashCode());

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo</a> |  <a href="#GetField(System.String,System.Reflection.BindingFlags)">Type.GetField</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetFieldsTopic2"></a><a name="GetFields(System.Reflection.BindingFlags)">GetFields</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, searches for the fields defined for the current  <a href="../../System/types/Type.html">Type</a>, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo[]</a> GetFields(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo</a> objects representing all fields defined for the current  <a href="../../System/types/Type.html">Type</a> that match the specified binding constraints.<p> -or- </p>
<p> An empty array of type  <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo</a>, if no fields are defined for the current  <a href="../../System/types/Type.html">Type</a>, or if none of the defined fields match the binding constraints.</p>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#GetFields(System.Reflection.BindingFlags)">IReflect.GetFields</a></dd>
</dl><b>Remarks</b><dl>
<dd> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which fields to include in the search: <UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public fields in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public fields (that is, private and protected fields) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static members up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.DeclaredOnly</b> to search only the fields declared on the  <a href="../../System/types/Type.html">Type</a>, not fields that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
			Console.WriteLine("HashCode of the System.Windows.Forms.Button type is  : {0}",
            typeof(System.Windows.Forms.Button).GetHashCode());

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetField(System.String,System.Reflection.BindingFlags)">Type.GetField</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="GetHashCodeTopic1"></a><a name="GetHashCode">GetHashCode</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns the hash code for this instance.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Int32.html">int</a> GetHashCode();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An  <a href="../../System/types/Int32.html">Int32</a> containing the hash code for this instance.</dd>
</dl><b>Remarks</b><dl>
<dd> This method overrides  <a href="../../System/types/Object.html#GetHashCode">Object.GetHashCode</a>.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
			Console.WriteLine("HashCode of the System.Windows.Forms.Button type is  : {0}",
            typeof(System.Windows.Forms.Button).GetHashCode());

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetInterfaceTopic1"></a><a name="GetInterface(System.String)">GetInterface</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the interface with the specified name.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Type.html">Type</a> GetInterface(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the interface to get.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System/types/Type.html">Type</a> object representing the interface with the specified name, implemented or inherited by the current  <a href="../../System/types/Type.html">Type</a>, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/TargetInvocationException.html">TargetInvocationException</a></td>
<td> A static initializer is invoked and throws an exception.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
    public static void Main()
    {
        Hashtable hashtableObj = new Hashtable();
        Type objType = hashtableObj.GetType();
        MemberInfo[] arrayMemberInfo;
        MethodInfo[] arrayMethodInfo;
        try
        {   
            // Get the methods implemented in 'IDeserializationCallback' interface.
            arrayMethodInfo =objType.GetInterface("IDeserializationCallback").GetMethods();
            Console.WriteLine ("\nMethods of 'IDeserializationCallback' Interface :");
            for(int index=0;index &lt; arrayMethodInfo.Length ;index++)
                Console.WriteLine (arrayMethodInfo[index].ToString() ); 

            // Get FullName for interface by using Ignore case search.
            Console.WriteLine ("\nMethods of 'IEnumerable' Interface");
            arrayMethodInfo = objType.GetInterface("ienumerable",true).GetMethods();
            for(int index=0;index &lt; arrayMethodInfo.Length ;index++)
               Console.WriteLine (arrayMethodInfo[index].ToString()); 
           
            //Get the Interface methods for 'IDictionary' interface
            InterfaceMapping interfaceMappingObj;
            interfaceMappingObj = objType.GetInterfaceMap(typeof(IDictionary));
            arrayMemberInfo = interfaceMappingObj.InterfaceMethods;
            Console.WriteLine ("\nHashtable class Implements the following IDictionary Interface methods :");
            for(int index=0; index &lt; arrayMemberInfo.Length; index++)
                Console.WriteLine (arrayMemberInfo[index].ToString() ); 
        }
        catch (Exception e)
        {
            Console.WriteLine ("Exception : " + e.ToString());            
        }                 
    }

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/String.html">String</a> |  <a href="#GetInterfaces">Type.GetInterfaces</a> |  <a href="#FindInterfaces(System.Reflection.TypeFilter,System.Object)">Type.FindInterfaces</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetInterfaceTopic2"></a><a name="GetInterface(System.String,System.Boolean)">GetInterface</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>ignoreCase</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, searches for the specified interface, specifying whether to do a case-sensitive search.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/Type.html">Type</a> GetInterface(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>ignoreCase</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the interface to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>ignoreCase</i><br><dl>
<dd>
<param><b>true</b> to perform a case-insensitive search for <i>name</i>.<p> -or- </p>
<p><b>false</b> to perform a case-sensitive search for <i>name</i>.</p><b>true</b> to perform a case-insensitive search for <i>name</i>.<p> -or- </p>
<p><b>false</b> to perform a case-sensitive search for <i>name</i>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System/types/Type.html">Type</a> object representing the interface with the specified name, implemented or inherited by the current  <a href="../../System/types/Type.html">Type</a>, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/TargetInvocationException.html">TargetInvocationException</a></td>
<td> A static initializer is invoked and throws an exception.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Arrays or COM types are not searched for unless they have been previously loaded into the table of available classes.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
    public static void Main()
    {
        Hashtable hashtableObj = new Hashtable();
        Type objType = hashtableObj.GetType();
        MemberInfo[] arrayMemberInfo;
        MethodInfo[] arrayMethodInfo;
        try
        {   
            // Get the methods implemented in 'IDeserializationCallback' interface.
            arrayMethodInfo =objType.GetInterface("IDeserializationCallback").GetMethods();
            Console.WriteLine ("\nMethods of 'IDeserializationCallback' Interface :");
            for(int index=0;index &lt; arrayMethodInfo.Length ;index++)
                Console.WriteLine (arrayMethodInfo[index].ToString() ); 

            // Get FullName for interface by using Ignore case search.
            Console.WriteLine ("\nMethods of 'IEnumerable' Interface");
            arrayMethodInfo = objType.GetInterface("ienumerable",true).GetMethods();
            for(int index=0;index &lt; arrayMethodInfo.Length ;index++)
               Console.WriteLine (arrayMethodInfo[index].ToString()); 
           
            //Get the Interface methods for 'IDictionary' interface
            InterfaceMapping interfaceMappingObj;
            interfaceMappingObj = objType.GetInterfaceMap(typeof(IDictionary));
            arrayMemberInfo = interfaceMappingObj.InterfaceMethods;
            Console.WriteLine ("\nHashtable class Implements the following IDictionary Interface methods :");
            for(int index=0; index &lt; arrayMemberInfo.Length; index++)
                Console.WriteLine (arrayMemberInfo[index].ToString() ); 
        }
        catch (Exception e)
        {
            Console.WriteLine ("Exception : " + e.ToString());            
        }                 
    }

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/String.html">String</a> |  <a href="#GetInterfaces">Type.GetInterfaces</a> |  <a href="#FindInterfaces(System.Reflection.TypeFilter,System.Object)">Type.FindInterfaces</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetInterfaceMapTopic1"></a><a name="GetInterfaceMap(System.Type)">GetInterfaceMap</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>interfaceType</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns an interface mapping for the specified interface type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System.Reflection/types/InterfaceMapping.html">InterfaceMapping</a> GetInterfaceMap(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>interfaceType</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>interfaceType</i><br><dl>
<dd>
<param> The  <a href="../../System/types/Type.html">Type</a> of the interface of which to retrieve a mapping.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An  <a href="../../System.Reflection/types/InterfaceMapping.html">InterfaceMapping</a> object representing the interface mapping for <i>interfaceType</i>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td> The <i>interfaceType</i> parameter does not refer to an interface.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>interfaceType</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The interface map denotes how an interface is mapped into the actual methods on a class that implements that interface.</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/InterfaceMapping.html">InterfaceMapping</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetInterfacesTopic1"></a><a name="GetInterfaces">GetInterfaces</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, gets all the interfaces implemented or inherited by the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/Type.html">Type[]</a> GetInterfaces();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System/types/Type.html">Type</a> objects representing all the interfaces implemented or inherited by the current  <a href="../../System/types/Type.html">Type</a>.<p> -or- </p>
<p> An empty array of type  <a href="../../System/types/Type.html">Type</a>, if no interfaces are implemented or inherited by the current  <a href="../../System/types/Type.html">Type</a>.</p>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/TargetInvocationException.html">TargetInvocationException</a></td>
<td> A static initializer is invoked and throws an exception.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd>
<pre>
	public class MyTemplate : Control, INamingContainer 
    {
        private String _message = null;
        public String Message 
		  {
				get 
				{
					return _message;
				}
				set 
				{
					_message = value;
				}
			}	
	}
	public class MyInterfacesSample
	{
		public static void Main()
		{
			try
			{
				Type[] myObjectArray= typeof(MyTemplate).GetInterfaces();
				Console.WriteLine("The Interfaces inherited by the MyTemplate class are :\n");
				for (int index = 0; index &lt; myObjectArray.Length; index++)
				{	
					Console.WriteLine(myObjectArray[index]);
				}
			}
			catch (Exception e)
			{
				Console.WriteLine("Exception Raised !");
				Console.WriteLine("Message : " + e.Message);
			}
		}
	}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#GetInterface(System.String)">Type.GetInterface</a> |  <a href="#FindInterfaces(System.Reflection.TypeFilter,System.Object)">Type.FindInterfaces</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMemberTopic1"></a><a name="GetMember(System.String)">GetMember</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the members with the specified name.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo[]</a> GetMember(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the public members to get.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> objects representing the public members with the specified name, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.<p> Members include properties, methods, fields, events, and so on.</p>
<p> This method searches the current classes and its base classes. Only public methods can be found using this method. If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
<p> Class initializers are available through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>, and  <a href="#GetConstructors">Type.GetConstructors</a>.</p>
<p> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
	public void GetMemberInfo()
	{
		String myString = "GetMember_String";

		Type myType = myString.GetType();
		// Get the members for myString starting with 'C',using searchCriteria 'C*'.
		MemberInfo[] myMembers = myType.GetMember("C*");
      if(myMembers.Length &gt; 0)
      {
         Console.WriteLine("\nThe Member(s) starting with 'C' for type {0} :", myType);
         for(int index=0; index &lt; myMembers.Length; index++)
            Console.WriteLine("Member {0} : {1}", index + 1, myMembers[index].ToString());
      }
      else
            Console.WriteLine("No Members match the Search Criteria.");    
	}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMembers">Type.GetMembers</a> |  <a href="#GetDefaultMembers">Type.GetDefaultMembers</a> |  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMemberTopic2"></a><a name="GetMember(System.String,System.Reflection.BindingFlags)">GetMember</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified members, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo[]</a> GetMember(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the members to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> objects representing the public members with the specified name, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#GetMember(System.String,System.Reflection.BindingFlags)">IReflect.GetMember</a></dd>
</dl><b>Remarks</b><dl>
<dd> This method can be overridden by a derived class.<p> Members include properties, methods, fields, events, and so on.</p>
<p> This method searches the current classes and its base classes. If the requested member is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which members to include in the search: </p>
<UL>
<li><i>Instance</i> to include instance members in the search.</li>
<li><i>Static</i> to include static members in the search.</li>
<li><i>Public</i> to include public members in the search.</li>
<li><i>NonPublic</i> to include non-public members (that is, private and protected members) in the search.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><i>IgnoreCase</i> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <i>IgnoreCase</i> flag.</li>
<li><i>DeclaredOnly</i> to search only the members declared on the  <a href="../../System/types/Type.html">Type</a>, not members that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> Class initializers are available through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>, and  <a href="#GetConstructors">Type.GetConstructors</a>.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
	public void GetPublicStaticMemberInfo()
	{
		String myString = "GetMember_String_BindingFlag";

		Type myType = myString.GetType();
      // Get the Public Static members for the class myString starting with 'C'.
		MemberInfo[] myMembers = myType.GetMember("C*",
                                 BindingFlags.Public |BindingFlags.Static);

      if(myMembers.Length &gt; 0)
      {
         Console.WriteLine("\nThe Public Static Member(s)  starting with 'C' for type {0} :",myType);
         for(int index=0; index &lt; myMembers.Length; index++)
            Console.WriteLine("Member {0} : {1}", index + 1, myMembers[index].ToString());
      }
      else
         Console.WriteLine("No Members match the Search Criteria.");    
	}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMembers">Type.GetMembers</a> |  <a href="#GetDefaultMembers">Type.GetDefaultMembers</a> |  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMemberTopic3"></a><a name="GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">GetMember</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/MemberTypes.html">MemberTypes</a> <i>type</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified members of the specified member type, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo[]</a> GetMember(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/MemberTypes.html">MemberTypes</a> <i>type</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the members to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>type</i><br><dl>
<dd>
<param> The  <a href="#MemberType">Type.MemberType</a> to search for.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> objects representing the public members with the specified name, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> A derived class must provide an implementation.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Members include properties, methods, fields, events, and so on.<p> This method searches the current classes and its base classes. If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which members to include in the search: </p>
<UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public members in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public members (that is, private and protected members) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static members up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.IgnoreCase</b> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <b>IgnoreCase</b> flag.</li>
<li><b>BindingFlags.DeclaredOnly</b> to search only the members declared on the  <a href="../../System/types/Type.html">Type</a>, not members that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> Class initializers are available through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>, and  <a href="#GetConstructors">Type.GetConstructors</a>.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
	public void GetPublicInstanceMethodMemberInfo()
	{
		String myString = "GetMember_String_MemberType_BindingFlag";

		Type myType = myString.GetType();
      // Get the Public Instance methods for myString starting with 'C'.
		MemberInfo[] myMembers = myType.GetMember("C*", MemberTypes.Method, 
							  BindingFlags.Public | BindingFlags.Instance);
      if(myMembers.Length &gt; 0)
      {
         Console.WriteLine("\nThe Public Instance Method(s) starting with 'C' for type {0}:", myType);
         for(int index=0; index &lt; myMembers.Length; index++)
            Console.WriteLine("Member {0} : {1}", index + 1, myMembers[index].ToString());
      }
      else
         Console.WriteLine("No Members match the Search Criteria.");    
	}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMembers">Type.GetMembers</a> |  <a href="#GetDefaultMembers">Type.GetDefaultMembers</a> |  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMembersTopic1"></a><a name="GetMembers">GetMembers</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns all the public members of the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo[]</a> GetMembers();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> objects representing all the public members of the current  <a href="../../System/types/Type.html">Type</a>.<p> -or- </p>
<p> An empty array of type  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a>, if the current  <a href="../../System/types/Type.html">Type</a> does not have public members.</p>
</dd>
</dl><b>Remarks</b><dl>
<dd> Members include properties, methods, fields, events, and so on.<p> Class initializers are available through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>, and  <a href="#GetConstructors">Type.GetConstructors</a>.</p>
<p> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
class MyClass
{
   public int myInt = 0;
   public string myString = null;

   public MyClass()
   {
   }
   public void Myfunction()
   {
   }
}

class Type_GetMembers
{
   public static void Main()
   {
      try
      {
         MyClass myObject = new MyClass();
         MemberInfo[] myMemberInfo; 

         // Get the type of 'MyClass'.
         Type myType = myObject.GetType(); 
        
         // Get the information related to all public member's of 'MyClass'. 
         myMemberInfo = myType.GetMembers();
    
         Console.WriteLine( "\nThe members of class '{0}' are :\n", myType); 
         for (int i =0 ; i &lt; myMemberInfo.Length ; i++)
         {
            // Display name and type of the concerned member.
            Console.WriteLine( "'{0}' is a {1}", myMemberInfo[i].Name, myMemberInfo[i].MemberType);
         }
      }
      catch(SecurityException e)
      {
         Console.WriteLine("Exception : " + e.Message ); 
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> |  <a href="#GetMember(System.String)">Type.GetMember</a> |  <a href="#GetDefaultMembers">Type.GetDefaultMembers</a> |  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMembersTopic2"></a><a name="GetMembers(System.Reflection.BindingFlags)">GetMembers</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, searches for the members defined for the current  <a href="../../System/types/Type.html">Type</a>, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo[]</a> GetMembers(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> objects representing all members defined for the current  <a href="../../System/types/Type.html">Type</a> that match the specified binding constraints.<p> -or- </p>
<p> An empty array of type  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a>, if no members are defined for the current  <a href="../../System/types/Type.html">Type</a>, or if none of the defined members match the binding constraints.</p>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#GetMembers(System.Reflection.BindingFlags)">IReflect.GetMembers</a></dd>
</dl><b>Remarks</b><dl>
<dd> Members include properties, methods, fields, events, and so on.<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which members to include in the search: </p>
<UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public members in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public members (that is, private and protected members) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static members up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.DeclaredOnly</b> to search only the members declared on the  <a href="../../System/types/Type.html">Type</a>, not members that were simply inherited.</li>
</UL>
<p> Calling this method with only the <b>Public</b> flag or only the <b>NonPublic</b> flag will return the specified members and does not require any other flags.</p>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> Class initializers are available through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>, and  <a href="#GetConstructors">Type.GetConstructors</a>.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>

class MyClass
{
   public int myInt = 0;
   public string myString = null;

   public MyClass()
   {
   }
   public void Myfunction()
   {
   }
}

class Type_GetMembers_BindingFlags
{
   public static void Main()
   {
      try
      {
         MyClass MyObject = new MyClass();
         MemberInfo [] myMemberInfo; 

         // Get the type of the class 'MyClass'.
         Type myType = MyObject.GetType(); 
        
         // Get the public instance members of the class 'MyClass'. 
         myMemberInfo = myType.GetMembers(BindingFlags.Public|BindingFlags.Instance);
    
         Console.WriteLine( "\nThe public instance members of class '{0}' are : \n", myType); 
         for (int i =0 ; i &lt; myMemberInfo.Length ; i++)
         {
            // Display name and type of the member of 'MyClass'.
            Console.WriteLine( "'{0}' is a {1}", myMemberInfo[i].Name, myMemberInfo[i].MemberType);
         }

      }
      catch (SecurityException e)
      {
         Console.WriteLine("SecurityException : " + e.Message ); 
      }      
   }
}


    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMember(System.String)">Type.GetMember</a> |  <a href="#GetDefaultMembers">Type.GetDefaultMembers</a> |  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMethodTopic1"></a><a name="GetMethod(System.String)">GetMethod</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the public method with the specified name.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> GetMethod(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the public method to get.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> object representing the public method with the specified name, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one method is found with the specified name.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p><br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
class MyClass
{
   public int myInt = 0;
   public string myString = null;

   public MyClass()
   {
   }
   public void Myfunction(int i)
   {
   } 
}
class Type_GetMethod
{
   public static void Main()
   {
      try
      {         
         MyClass MyObject = new MyClass();
         MethodInfo myMethodInfo; 

         // Get the type of the class 'MyClass'.
         Type myType = MyObject.GetType(); 
        
         // Get the method information for a method named 'MyFunction'. 
         myMethodInfo = myType.GetMethod("Myfunction");
         
         // Get the parameters for the method 'Myfunction'.
         ParameterInfo[] myParameters = myMethodInfo.GetParameters();
    
         Console.WriteLine( "\nThe parameters of the method 'Myfunction' of class 'MyClass' are :\n"); 
         
         // Display the position and type of the parameters.
         for(int i = 0; i &lt; myParameters.Length; i++)
            Console.WriteLine("The parameter {0} is of type {1}", 
               myParameters[i].Position + 1, myParameters[i].ParameterType);
      }
      catch (SecurityException e)
      {
         Console.WriteLine("SecurityException : " + e.Message ); 
      }
      catch (Exception e)
      {
         Console.WriteLine("Exception : " + e.Message ); 
      }      
   }
}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetMethodImpl</a> |  <a href="#GetMethods">Type.GetMethods</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMethodTopic2"></a><a name="GetMethod(System.String,System.Reflection.BindingFlags)">GetMethod</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified method, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> GetMethod(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the method to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> object representing the method that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one method is found with the specified name and matching the specified binding constraints.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#GetMethod(System.String,System.Reflection.BindingFlags)">IReflect.GetMethod</a></dd>
</dl><b>Remarks</b><dl>
<dd> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which methods to include in the search: <UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public methods in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public methods (that is, private and protected members) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static methods up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.IgnoreCase</b> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <b>IgnoreCase</b> flag.</li>
<li><b>BindingFlags.DeclaredOnly</b> to search only the methods declared on the  <a href="../../System/types/Type.html">Type</a>, not methods that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p><br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
class MyClass
{
   public void MyMethod()
   {    
   }
}

public class Type_GetMethod
{
   public static void Main()
   {
      try
      {
         // Get the type of 'MyClass'.
         Type myType = typeof(MyClass);
         
         // Get the method information of the type 'MyClass'.
         MethodInfo myMethodInfo = myType.GetMethod("MyMethod",
            BindingFlags.Public|BindingFlags.Instance );
         
         // Displays the member info to the console.
         Console.WriteLine("\nThe signature of 'MyMethod' is : {0}", myMethodInfo.ToString());
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception : {0}", e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetMethodImpl</a> |  <a href="#GetMethods">Type.GetMethods</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMethodTopic3"></a><a name="GetMethod(System.String,System.Type[])">GetMethod</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified public method whose parameters match the specified argument types.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> GetMethod(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the public method to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the method to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the method to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> object representing the public method whose parameters match the specified argument types, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one method is found with the specified name and specified parameters.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p> -or- </p>
<p><i>types</i> is <b>null</b>.</p>
<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.<p> -or- </p>
<p><i>modifiers</i> is multidimensional.</p>
<p> -or- </p>
<p><i>types</i> and <i>modifiers</i> do not have the same length.</p>
</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p><br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
            // Get a 'Type' object corresponding to 'MyClass1' class.
            Type myClassType = typeof(MyClass1);
            // Create a Type array.
            Type[] typeArray =new Type[1];
            typeArray.SetValue(typeof(int),0);
            // Find the method matching the specified argument types.
            MethodInfo myMethodInfo = 
                        myClassType.GetMethod("MyMethod",typeArray);
            Console.WriteLine("The Name of the Method :"+myMethodInfo);

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetMethodImpl</a> |  <a href="#GetMethods">Type.GetMethods</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMethodTopic4"></a><a name="GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">GetMethod</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified public method whose parameters match the specified argument types and modifiers.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> GetMethod(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the public method to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the method to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the method to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <i>types</i> array. The default binder does not process this parameter.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> object representing the public method that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one method is found with the specified name and specified parameters.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p> -or- </p>
<p><i>types</i> is <b>null</b>.</p>
<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.<p> -or- </p>
<p><i>modifiers</i> is multidimensional.</p>
<p> -or- </p>
<p><i>types</i> and <i>modifiers</i> do not have the same length.</p>
</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Although the default binder does not process  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> (the <i>modifiers</i> parameter), you can use the abstract  <a href="../../System.Reflection/types/Binder.html">Binder</a> class to write a custom binder that does process <i>modifiers</i>.<b>ParameterModifier</b> is only used when calling through COM interop, and only parameters that are passed by reference are handled.<p> The <i>types</i> array and the <i>modifiers</i> array have the same length. A parameter specified in the <i>types</i> array can have the following attributes, which are specified in the <i>modifiers</i> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and are used for interoperability.</p>
<p> The search for <i>name</i> is case-sensitive.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p><br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetMethodImpl</a> |  <a href="#GetMethods">Type.GetMethods</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMethodTopic5"></a><a name="GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">GetMethod</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> GetMethod(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the method to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the method to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the method to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <i>types</i> array. The default binder does not process this parameter.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> object representing the method that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one method is found with the specified name and matching the specified binding constraints.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p> -or- </p>
<p><i>types</i> is <b>null</b>.</p>
<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.<p> -or- </p>
<p><i>modifiers</i> is multidimensional.</p>
<p> -or- </p>
<p><i>types</i> and <i>modifiers</i> do not have the same length.</p>
</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">IReflect.GetMethod</a></dd>
</dl><b>Remarks</b><dl>
<dd> Although the default binder does not process  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> (the <i>modifiers</i> parameter), you can use the abstract  <a href="../../System.Reflection/types/Binder.html">Binder</a> class to write a custom binder that does process <i>modifiers</i>.<b>ParameterModifier</b> is only used when calling through COM interop, and only parameters that are passed by reference are handled.<p> The <i>types</i> array and the <i>modifiers</i> array have the same length. A parameter specified in the <i>types</i> array can have the following attributes, which are specified in the <i>modifiers</i> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.</p>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which methods to include in the search: </p>
<UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public methods in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public methods (that is, private and protected members) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static methods up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.IgnoreCase</b> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <b>IgnoreCase</b> flag.</li>
<li><b>BindingFlags.DeclaredOnly</b> to search only the methods declared on the  <a href="../../System/types/Type.html">Type</a>, not methods that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p><br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
public class MyClass
{
   public int i = 10;
   public string k = "My Field";
   public int MyMethod(int i)
   {
      this.i = i;
      return i;
   }
   public string MyMethod(string k)
   {
      this.k = k;
      return k;
   }
}
public class Type_GetMethod
{
   public static void Main()
   {
      try
      {
         // Get the type of the class 'MyClass'.
         Type myType = typeof(MyClass);

         // Get the attributes of the method and the metadata of the method 'MyMethod'.
         MethodInfo myMethodInfo = myType.GetMethod("MyMethod", 
            BindingFlags.Public | BindingFlags.Instance, null, 
            new Type[] {typeof(int)}, null);
         
         Console.WriteLine("\n Declaring type of the method '{0}' is : \n '{1}'", myMethodInfo,
            myMethodInfo.DeclaringType);
         
         // Get the attributes of the method and the metadata of the method 'MyMethod'.
         MethodInfo myMethodInfo1 = myType.GetMethod("MyMethod", 
            BindingFlags.Public | BindingFlags.Instance, null, 
            new Type[] {typeof(string)}, null);
         
         Console.WriteLine("\n Declaring type of the method '{0}' is : \n '{1}'", myMethodInfo1,
            myMethodInfo1.DeclaringType);
         
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception : {0}", e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="../../System.Reflection/types/Binder.html">Binder</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetMethodImpl</a> |  <a href="#GetMethods">Type.GetMethods</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMethodTopic6"></a><a name="GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">GetMethod</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> GetMethod(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the method to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>callConvention</i><br><dl>
<dd>
<param> The  <a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the method to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the method to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <i>types</i> array. The default binder does not process this parameter.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> object representing the method that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one method is found with the specified name and matching the specified binding constraints.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p> -or- </p>
<p><i>types</i> is <b>null</b>.</p>
<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.<p> -or- </p>
<p><i>modifiers</i> is multidimensional.</p>
<p> -or- </p>
<p><i>types</i> and <i>modifiers</i> do not have the same length.</p>
</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Although the default binder does not process  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> (the <i>modifiers</i> parameter), you can use the abstract  <a href="../../System.Reflection/types/Binder.html">Binder</a> class to write a custom binder that does process <i>modifiers</i>.<b>ParameterModifier</b> is only used when calling through COM interop, and only parameters that are passed by reference are handled.<p> The following table shows what members of a base class are returned by the <b>GetXXX</b> methods when reflecting on a type.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
<p> The <i>types</i> array and the <i>modifiers</i> array have the same length. A parameter specified in the <i>types</i> array can have the following attributes, which are specified in the <i>modifiers</i> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.</p>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which methods to include in the search: </p>
<UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public methods in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public methods (that is, private and protected members) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static methods up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.IgnoreCase</b> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <b>IgnoreCase</b> flag.</li>
<li><b>BindingFlags.DeclaredOnly</b> to search only the methods declared on the  <a href="../../System/types/Type.html">Type</a>, not methods that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p><br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>

public class MyClass
{
   public int i = 10;
   public int j = 2;
   
   public int MyFunc(int i , int j)
   {
      int k;
      k = i * 10 - j;
      return k;
   }
}
public class Type_GetMethod
{
   public static void Main()
   {
      try
      {
         // Get the type of the class 'MyClass'.
         Type myType = typeof(MyClass);

         // Get the method information of 'MyFunc(int , int )'.
         MemberInfo myMemberInfo = myType.GetMethod("MyFunc", BindingFlags.Public |
                                                         BindingFlags.Instance, 
                                                         null, 
                                                         CallingConventions.Any,  
                                                         new Type[] {typeof(int),typeof(int)}, 
                                                         null);
         
         Console.WriteLine("\nDisplaying method 'MyFunc' : \n");
         
         // Print the method information to the console.
         Console.WriteLine("{0}", myMemberInfo);
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception : {0}", e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="../../System.Reflection/types/Binder.html">Binder</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetMethodImpl</a> |  <a href="#GetMethods">Type.GetMethods</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetMethodImplTopic1"></a><a name="GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">GetMethodImpl</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected abstract <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> GetMethodImpl(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the method to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>callConvention</i><br><dl>
<dd>
<param> The  <a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the method to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</p>
<p> -or- </p>
<p><b>null</b>. If <i>types</i> is <b>null</b>, arguments are not matched.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the method to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</p>
<p> -or- </p>
<p><b>null</b>. If <i>types</i> is <b>null</b>, arguments are not matched.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <i>types</i> array. The default binder does not process this parameter.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> object representing the method that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one method is found with the specified name and matching the specified binding constraints.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.<p> -or- </p>
<p><i>modifiers</i> is multidimensional.</p>
<p> -or- </p>
<p><i>types</i> and <i>modifiers</i> do not have the same length.</p>
</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Although the default binder does not process  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> (the <i>modifiers</i> parameter), you can use the abstract  <a href="../../System.Reflection/types/Binder.html">Binder</a> class to write a custom binder that does process <i>modifiers</i>.<b>ParameterModifier</b> is only used when calling through COM interop, and only parameters that are passed by reference are handled.<p> If <i>types</i> is <b>null</b>, arguments are not matched.</p>
<p> The <i>types</i> array and the <i>modifiers</i> array have the same length. A parameter specified in the <i>types</i> array can have the following attributes, which are specified in the <i>modifiers</i> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.</p>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which methods to include in the search: </p>
<UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public methods in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public methods (that is, private and protected members) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static methods up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.IgnoreCase</b> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <b>IgnoreCase</b> flag.</li>
<li><b>BindingFlags.DeclaredOnly</b> to search only the methods declared on the  <a href="../../System/types/Type.html">Type</a>, not methods that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="../../System.Reflection/types/Binder.html">Binder</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetMethod</a> |  <a href="#GetMethods">Type.GetMethods</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMethodsTopic1"></a><a name="GetMethods">GetMethods</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns all the public methods of the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo[]</a> GetMethods();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> objects representing all the public methods defined for the current  <a href="../../System/types/Type.html">Type</a>.<p> -or- </p>
<p> An empty array of type  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a>, if no public methods are defined for the current  <a href="../../System/types/Type.html">Type</a>.</p>
</dd>
</dl><b>Remarks</b><dl>
<dd> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.<br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL><br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> |  <a href="#GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetMethod</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMethodsTopic2"></a><a name="GetMethods(System.Reflection.BindingFlags)">GetMethods</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, searches for the methods defined for the current  <a href="../../System/types/Type.html">Type</a>, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo[]</a> GetMethods(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> objects representing all methods defined for the current  <a href="../../System/types/Type.html">Type</a> that match the specified binding constraints.<p> -or- </p>
<p> An empty array of type  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a>, if no methods are defined for the current  <a href="../../System/types/Type.html">Type</a>, or if none of the defined methods match the binding constraints.</p>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#GetMethods(System.Reflection.BindingFlags)">IReflect.GetMethods</a></dd>
</dl><b>Remarks</b><dl>
<dd> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which methods to include in the search: <UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public methods in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public methods (that is, private and protected members) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static methods up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.DeclaredOnly</b> to search only the methods declared on the  <a href="../../System/types/Type.html">Type</a>, not methods that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p><br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
			public static void Main() 
			{

				Type myType =(typeof(MyTypeClass));
				// Get the methods with the Access-Specifier as public.
				MethodInfo[] myArrayMethodInfo = myType.GetMethods(BindingFlags.Public|BindingFlags.Instance|BindingFlags.DeclaredOnly);
				Console.WriteLine("\nThe Number of Public Methods are :"+myArrayMethodInfo.Length);
				Console.WriteLine("The Names of the Public Methods are :");
				// Display all the methods.
				DisplayMethodInfo(myArrayMethodInfo);
				// Get the methods information of all 'NonPublic'.
				MethodInfo[] myArrayMethodInfo1 = myType.GetMethods(BindingFlags.NonPublic|BindingFlags.Instance|BindingFlags.DeclaredOnly);
				Console.WriteLine("\nThe Number of Protected Methods are :"+myArrayMethodInfo1.Length);
				Console.WriteLine("The Names of the Protected methods are :");
				// Display all the methods information.
				DisplayMethodInfo(myArrayMethodInfo1);		
			}
			public static void DisplayMethodInfo(MethodInfo[] myArrayMethodInfo)
			{
				// Display  the information of all the Methods.
				for(int i=0;i&lt;myArrayMethodInfo.Length;i++)
				{
					MethodInfo myMethodInfo = (MethodInfo)myArrayMethodInfo[i];
					Console.WriteLine("\nName of the Method is :"+myMethodInfo.Name);
				}
			}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetMethod</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetNestedTypeTopic1"></a><a name="GetNestedType(System.String)">GetNestedType</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the nested type with the specified name.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Type.html">Type</a> GetNestedType(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the nested type to get.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System/types/Type.html">Type</a> object representing the nested type with the specified name, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.<p> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="#GetNestedTypes">Type.GetNestedTypes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetNestedTypeTopic2"></a><a name="GetNestedType(System.String,System.Reflection.BindingFlags)">GetNestedType</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/Type.html">Type</a> GetNestedType(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the nested type to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System/types/Type.html">Type</a> object representing the nested type that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which nested types to include in the search: <UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public nested types in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public nested types (that is, private and protected members) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static nested types up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.IgnoreCase</b> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <b>IgnoreCase</b> flag.</li>
<li><b>BindingFlags.DeclaredOnly</b> to search only the nested types declared on the  <a href="../../System/types/Type.html">Type</a>, not nested types that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting methods that are not public. Associated enumerations:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#MemberAccess">ReflectionPermissionFlag.MemberAccess</a>,  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="#GetNestedTypes">Type.GetNestedTypes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetNestedTypesTopic1"></a><a name="GetNestedTypes">GetNestedTypes</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns all the types nested within the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Type.html">Type[]</a> GetNestedTypes();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System/types/Type.html">Type</a> objects representing all the types nested within the current  <a href="../../System/types/Type.html">Type</a>.<p> -or- </p> An empty array of type  <a href="../../System/types/Type.html">Type</a>, if no types are nested within the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl><b>Remarks</b><dl>
<dd> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.<br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
                  // Get Type Object corresponding to MyClass.
                  Type myType=typeof(MyClass);
                  // Get array of nested type objects which are in 'MyClass'.                 
                  Type[] nestType=myType.GetNestedTypes();
                  Console.WriteLine("Number of nested types are {0}",nestType.Length);
                  foreach(Type t in nestType)
                     Console.WriteLine("Nested type is {0}",t.ToString());

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#GetNestedType(System.String)">Type.GetNestedType</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetNestedTypesTopic2"></a><a name="GetNestedTypes(System.Reflection.BindingFlags)">GetNestedTypes</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, searches for the types nested within the current  <a href="../../System/types/Type.html">Type</a>, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/Type.html">Type[]</a> GetNestedTypes(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System/types/Type.html">Type</a> objects representing all the types nested within the current  <a href="../../System/types/Type.html">Type</a> that match the specified binding constraints.<p> -or- </p>
<p> An empty array of type  <a href="../../System/types/Type.html">Type</a>, if no types are nested within the current  <a href="../../System/types/Type.html">Type</a>, or if none of the nested types match the binding constraints.</p>
</dd>
</dl><b>Remarks</b><dl>
<dd> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which nested types to include in the search: <UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public nested types in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public nested types (that is, private and protected members) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static nested types up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.DeclaredOnly</b> to search only the nested types declared on the  <a href="../../System/types/Type.html">Type</a>, not nested types that were simply inherited.</li>
</UL>
<p> Calling this method with only the <i>Public</i> flag or only the <i>NonPublic</i> flag will return the specified nested types and does not require any other flags.</p>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
			public static void Main() 
			{

				Type myType =(typeof(MyTypeClass));
				// Get the Nested classes with the Access-Specifier as public.
				Type[] myTypeArray = myType.GetNestedTypes(BindingFlags.Public|BindingFlags.Instance);
				Console.WriteLine("\nThe Public Classes are :"+myTypeArray.Length);
				Console.WriteLine("\nThe Names of the Public Classes are :");
				// Display all the Nested classes.
				DisplayTypeInfo(myTypeArray);
				// Get the Nested classes information of all 'NonPublic'.
				Type[] myTypeArray1 = myType.GetNestedTypes(BindingFlags.NonPublic|BindingFlags.Instance);
				Console.WriteLine("\nThe Number of Protected Classes are :"+myTypeArray1.Length);
				Console.WriteLine("\nThe Names of the Protected Classes are :");
				// Display  the information of all the Nested classes.
				DisplayTypeInfo(myTypeArray1);		
			}
			public static void DisplayTypeInfo(Type[] myArrayType)
			{
				// Display  the information of all the Nested classes.
				for(int i=0;i&lt;myArrayType.Length;i++)
				{
					Type myType = (Type)myArrayType[i];
					Console.WriteLine("\nName of the Nested class is :"+myType.ToString());
				}
			}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting methods that are not public. Associated enumerations:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#MemberAccess">ReflectionPermissionFlag.MemberAccess</a>,  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="#GetNestedType(System.String)">Type.GetNestedType</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetPropertiesTopic1"></a><a name="GetProperties">GetProperties</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns all the public properties of the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo[]</a> GetProperties();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> objects representing all public properties of the current  <a href="../../System/types/Type.html">Type</a>.<p> -or- </p>
<p> An empty array of type  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a>, if the current  <a href="../../System/types/Type.html">Type</a> does not have public properties.</p>
</dd>
</dl><b>Remarks</b><dl>
<dd> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.<br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
				PropertyInfo[] myPropertyInfo;
				// Get the properties of 'Type' class object.
				myPropertyInfo = Type.GetType("System.Type").GetProperties();
				Console.WriteLine("Properties of System.Type are:");
            for (int i = 0; i &lt; myPropertyInfo.Length; i++)
				{
					Console.WriteLine(myPropertyInfo[i].ToString());
				}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> |  <a href="#GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">Type.GetProperty</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetPropertiesTopic2"></a><a name="GetProperties(System.Reflection.BindingFlags)">GetProperties</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, searches for the properties of the current  <a href="../../System/types/Type.html">Type</a>, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo[]</a> GetProperties(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> objects representing all properties of the current  <a href="../../System/types/Type.html">Type</a> that match the specified binding constraints.<p> -or- </p>
<p> An empty array of type  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a>, if the current  <a href="../../System/types/Type.html">Type</a> does not have properties, or if none of the properties match the binding constraints.</p>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#GetProperties(System.Reflection.BindingFlags)">IReflect.GetProperties</a></dd>
</dl><b>Remarks</b><dl>
<dd> A property is considered public to reflection if it has at least one accessor that is public. That is, you can call type.GetProperty("propertyname", BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static) to get it.<p> Otherwise, the property is private and you must use type.GetProperty("propertyname", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static) to get it.</p>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which nested types to include in the search: </p>
<UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public properties in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public properties (that is, private and protected members) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static properties up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.DeclaredOnly</b> to search only the properties declared on the  <a href="../../System/types/Type.html">Type</a>, not properties that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
				public static void Main() 
				{
					Type myType =(typeof(MyTypeClass));
					// Get the properties having  the Access-Specifier as public.
					PropertyInfo[] myPropertyInfo = myType.GetProperties(BindingFlags.Public|BindingFlags.Instance);
					Console.WriteLine("\nThe Number of Public Properties are :"+myPropertyInfo.Length);
					Console.WriteLine("\nThe Names of the Public properties are :");
					// Display all the properties.
					DisplayPropertyInfo(myPropertyInfo);
					// Get the properties information of all 'NonPublic'.
					PropertyInfo[] myPropertyInfo1 = myType.GetProperties(BindingFlags.NonPublic|BindingFlags.Instance);
					Console.WriteLine("\nThe Number of Protected Properties are :"+myPropertyInfo1.Length);
					Console.WriteLine("\nThe Names of the Protected properties are :");
					// Display all the properties information.
					DisplayPropertyInfo(myPropertyInfo1);		
				}

				public static void DisplayPropertyInfo(PropertyInfo[] myPropertyInfo)
				{
					// Display  the information of all the properties .
					for(int i=0;i&lt;myPropertyInfo.Length;i++)
					{
						PropertyInfo myPropInfo = (PropertyInfo)myPropertyInfo[i];
						Console.WriteLine("\nName of the property is :"+myPropInfo.Name);
						Console.WriteLine("Type of the property is :"+myPropInfo.PropertyType);
					}
				}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="#GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">Type.GetProperty</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetPropertyTopic1"></a><a name="GetProperty(System.String)">GetProperty</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the public property with the specified name.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> GetProperty(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the public property to get.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> object representing the public property with the specified name, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one property is found with the specified name.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> Different languages use different syntax to specify default or parameterized properties.<pre>
            // Get Type Object corresponding to MyClass.
            Type myType=typeof(MyClass);       
            // Get PropertyInfo object by passing property name.
            PropertyInfo myPropInfo = myType.GetProperty("MyProperty");
            // Display Name propety to console.
            Console.WriteLine("The Property {0} exists",myPropInfo.Name);
            }

    </pre>
<p> Internally, this property is referred to by the name "Item" in the metadata. Therefore, any attempt to get <b>PropertyInfo</b> using reflection must specify this internal name in order for the <b>PropertyInfo</b> to be returned correctly.</p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">Type.GetPropertyImpl</a> |  <a href="#GetProperties(System.Reflection.BindingFlags)">Type.GetProperties</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetPropertyTopic2"></a><a name="GetProperty(System.String,System.Reflection.BindingFlags)">GetProperty</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified property, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> GetProperty(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the property to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> object representing the property that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one property is found with the specified name and matching the specified binding constraints.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#GetProperty(System.String,System.Reflection.BindingFlags)">IReflect.GetProperty</a></dd>
</dl><b>Remarks</b><dl>
<dd> The <i>types</i> array and the <i>modifiers</i> array have the same length. A parameter specified in the <i>types</i> array can have the following attributes, which are specified in the <i>modifiers</i> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which properties to include in the search: </p>
<UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public properties in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public properties (that is, private and protected properties ) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static properties up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.IgnoreCase</b> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <b>IgnoreCase</b> flag.</li>
<li><b>BindingFlags.DeclaredOnly</b> to search only the properties declared on the  <a href="../../System/types/Type.html">Type</a>, not properties that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> Different languages use different syntax to specify default or parameterized properties.<pre>
            // Get Type Object corresponding to MyClass.
            Type myType=typeof(MyClass);       
            // Get PropertyInfo object by passing property name and specifying BindingFlags.
            PropertyInfo myPropInfo = myType.GetProperty("MyProperty",
                                                   BindingFlags.Public|
                                                   BindingFlags.Instance);
            // Display Name propety to console.
            Console.WriteLine("{0} is a Property of 'MyClass'.",myPropInfo.Name);
            }

    </pre>
<p> Internally, this property is referred to by the name "Item" in the metadata. Therefore, any attempt to get <b>PropertyInfo</b> using reflection must specify this internal name in order for the <b>PropertyInfo</b> to be returned correctly.</p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">Type.GetPropertyImpl</a> |  <a href="#GetProperties(System.Reflection.BindingFlags)">Type.GetProperties</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetPropertyTopic3"></a><a name="GetProperty(System.String,System.Type)">GetProperty</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the public property with the specified name and return type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> GetProperty(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the public property to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>returnType</i><br><dl>
<dd>
<param> The return type of the property.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> object representing the public property with the specified name, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one property is found with the specified name.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> Different languages use different syntax to specify default or parameterized properties.<pre>
			Type myType = typeof(MyClass1);
		
			// Get the 'PropertyInfo' object representing 'MyProperty1' property. 
			PropertyInfo myStringProperties1 = myType.GetProperty("MyProperty1",
				typeof(string));
			Console.WriteLine("The Name of the first Property of MyClass1 :"+myStringProperties1.Name);
			Console.WriteLine("The Type of first Property of MyClass1 :"+myStringProperties1.PropertyType);

			// Get a 'Type' array  corresponding to the indexed  property.
			Type[] myTypeArr = new Type[2];
			myTypeArr.SetValue(typeof(int),0);            
			myTypeArr.SetValue(typeof(int),1);

			// Get the 'PropertyInfo' object representing 'MyProperty2' property. 
			PropertyInfo myStringProperties2 =myType.GetProperty("Item",typeof(int),myTypeArr);
			Console.WriteLine("{0} property exists in MyClass1.",myStringProperties2.ToString());
			Console.WriteLine("The Name of the second Property of MyClass1 :"+myStringProperties2.Name);
			Console.WriteLine("The Type of second Property of MyClass1 :"+myStringProperties2.PropertyType);

    </pre>
<p> Internally, this property is referred to by the name "Item" in the metadata. Therefore, any attempt to get <b>PropertyInfo</b> using reflection must specify this internal name in order for the <b>PropertyInfo</b> to be returned correctly.</p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">Type.GetPropertyImpl</a> |  <a href="#GetProperties(System.Reflection.BindingFlags)">Type.GetProperties</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetPropertyTopic4"></a><a name="GetProperty(System.String,System.Type[])">GetProperty</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified public property whose parameters match the specified argument types.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> GetProperty(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the public property to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> object representing the public property whose parameters match the specified argument types, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one property is found with the specified name and matching the specified argument types.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p> -or- </p>
<p><i>types</i> is <b>null</b>.</p>
<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> Different languages use different syntax to specify default or parameterized properties.<pre>
				// Get Type Object.
				Type myType=typeof(MyClass1);       
				Type[] myTypeArr = new Type[2];
				// Initialize Type array.
				myTypeArr.SetValue(typeof(int),0);            
				myTypeArr.SetValue(typeof(int),1);
				// Get PropertyInfo object for indexed property 'Item' which has two integer parameters. 
				PropertyInfo myPropInfo = myType.GetProperty("Item",myTypeArr);
				// Dispaly propety to console.
				Console.WriteLine("{0} property exists in MyClass1.",myPropInfo.ToString());

    </pre>
<p> Internally, this property is referred to by the name "Item" in the metadata. Therefore, any attempt to get <b>PropertyInfo</b> using reflection must specify this internal name in order for the <b>PropertyInfo</b> to be returned correctly.</p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">Type.GetPropertyImpl</a> |  <a href="#GetProperties(System.Reflection.BindingFlags)">Type.GetProperties</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetPropertyTopic5"></a><a name="GetProperty(System.String,System.Type,System.Type[])">GetProperty</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified public property whose parameters match the specified argument types.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> GetProperty(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the public property to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>returnType</i><br><dl>
<dd>
<param> The return type of the property.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> object representing the public property whose parameters match the specified argument types, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one property is found with the specified name and matching the specified argument types.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p> -or- </p>
<p><i>types</i> is <b>null</b>.</p>
<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">Type.GetPropertyImpl</a> |  <a href="#GetProperties(System.Reflection.BindingFlags)">Type.GetProperties</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetPropertyTopic6"></a><a name="GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">GetProperty</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified public property whose parameters match the specified argument types and modifiers.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> GetProperty(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the public property to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>returnType</i><br><dl>
<dd>
<param> The return type of the property.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <i>types</i> array. The default binder does not process this parameter.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> object representing the public property that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one property is found with the specified name and matching the specified argument types and modifiers.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p> -or- </p>
<p><i>types</i> is <b>null</b>.</p>
<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.<p> -or- </p>
<p><i>modifiers</i> is multidimensional.</p>
<p> -or- </p>
<p><i>types</i> and <i>modifiers</i> do not have the same length.</p>
</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Although the default binder does not process  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> (the <i>modifiers</i> parameter), you can use the abstract  <a href="../../System.Reflection/types/Binder.html">Binder</a> class to write a custom binder that does process <i>modifiers</i>.<b>ParameterModifier</b> is only used when calling through COM interop, and only parameters that are passed by reference are handled.<p> The <i>types</i> array and the <i>modifiers</i> array have the same length. A parameter specified in the <i>types</i> array can have the following attributes, which are specified in the <i>modifiers</i> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.</p>
<p> The search for <i>name</i> is case-sensitive.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> Different languages use different syntax to specify default or parameterized properties.<pre>
// MyPropAA - ReadOnly
protected short m_prvPropAA = -1;
public short m_PropAA = -2;
public short this [Boolean nonPublic]
{
    //get accessor for property {short MyPropAA}
    get {
        return ((nonPublic) ? m_prvPropAA: m_PropAA);
    }
}

    </pre>
<p> Internally, this property is referred to by the name "Item" in the metadata. Therefore, any attempt to get <b>PropertyInfo</b> using reflection must specify this internal name in order for the <b>PropertyInfo</b> to be returned correctly.</p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">Type.GetPropertyImpl</a> |  <a href="#GetProperties(System.Reflection.BindingFlags)">Type.GetProperties</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetPropertyTopic7"></a><a name="GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">GetProperty</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> GetProperty(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the property to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>returnType</i><br><dl>
<dd>
<param> The return type of the property.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <i>types</i> array. The default binder does not process this parameter.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> object representing the property that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one property is found with the specified name and matching the specified binding constraints.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p> -or- </p>
<p><i>types</i> is <b>null</b>.</p>
<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.<p> -or- </p>
<p><i>modifiers</i> is multidimensional.</p>
<p> -or- </p>
<p><i>types</i> and <i>modifiers</i> do not have the same length.</p>
</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">IReflect.GetProperty</a></dd>
</dl><b>Remarks</b><dl>
<dd> Although the default binder does not process  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> (the <i>modifiers</i> parameter), you can use the abstract  <a href="../../System.Reflection/types/Binder.html">Binder</a> class to write a custom binder that does process <i>modifiers</i>.<b>ParameterModifier</b> is only used when calling through COM interop, and only parameters that are passed by reference are handled.<p> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
<p> The <i>types</i> array and the <i>modifiers</i> array have the same length. A parameter specified in the <i>types</i> array can have the following attributes, which are specified in the <i>modifiers</i> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.</p>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which properties to include in the search: </p>
<UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public properties in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public properties (that is, private and protected properties ) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static properties up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.IgnoreCase</b> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <b>IgnoreCase</b> flag.</li>
<li><b>BindingFlags.DeclaredOnly</b> to search only the properties declared on the  <a href="../../System/types/Type.html">Type</a>, not properties that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> Different languages use different syntax to specify default or parameterized properties.<p></p>
<p> Internally, this property is referred to by the name "Item" in the metadata. Therefore, any attempt to get <b>PropertyInfo</b> using reflection must specify this internal name in order for the <b>PropertyInfo</b> to be returned correctly.</p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="../../System.Reflection/types/Binder.html">Binder</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">Type.GetPropertyImpl</a> |  <a href="#GetProperties(System.Reflection.BindingFlags)">Type.GetProperties</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetPropertyImplTopic1"></a><a name="GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">GetPropertyImpl</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected abstract <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> GetPropertyImpl(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the property to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>returnType</i><br><dl>
<dd>
<param> The return type of the property.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <i>types</i> array. The default binder does not process this parameter.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> object representing the property that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one property is found with the specified name and matching the specified binding constraints.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p> -or- </p>
<p><i>types</i> is <b>null</b>.</p>
<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.<p> -or- </p>
<p><i>modifiers</i> is multidimensional.</p>
<p> -or- </p>
<p><i>types</i> and <i>modifiers</i> do not have the same length.</p>
</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Although the default binder does not process  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> (the <i>modifiers</i> parameter), you can use the abstract  <a href="../../System.Reflection/types/Binder.html">Binder</a> class to write a custom binder that does process <i>modifiers</i>.<b>ParameterModifier</b> is only used when calling through COM interop, and only parameters that are passed by reference are handled.<p> The <i>types</i> array and the <i>modifiers</i> array have the same length. A parameter specified in the <i>types</i> array can have the following attributes, which are specified in the <i>modifiers</i> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and are used for interoperability.</p>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which properties to include in the search: </p>
<UL>
<li><i>Instance</i> to include instance properties in the search.</li>
<li><i>Static</i> to include static properties in the search.</li>
<li><i>Public</i> to include public properties in the search.</li>
<li><i>NonPublic</i> to include non-public properties (that is, private and protected properties) in the search.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><i>IgnoreCase</i> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <i>IgnoreCase</i> flag.</li>
<li><i>DeclaredOnly</i> to search only the properties declared on the  <a href="../../System/types/Type.html">Type</a>, not properties that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="../../System.Reflection/types/Binder.html">Binder</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">Type.GetProperty</a> |  <a href="#GetProperties(System.Reflection.BindingFlags)">Type.GetProperties</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetTypeTopic1"></a><a name="GetType">GetType</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#GetType">System.Object.GetType</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Type.html">Type</a> GetType();</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetTypeTopic2"></a><a name="GetType(System.String)">GetType</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>typeName</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Gets the  <a href="../../System/types/Type.html">Type</a> with the specified name, performing a case-sensitive search.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public static <a href="../../System/types/Type.html">Type</a> GetType(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>typeName</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>typeName</i><br><dl>
<dd>
<param> The name of the  <a href="../../System/types/Type.html">Type</a> to get.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The  <a href="../../System/types/Type.html">Type</a> with the specified name, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>typeName</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/TargetInvocationException.html">TargetInvocationException</a></td>
<td> A class initializer is invoked and throws an exception.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd><b>GetType</b> only works on assemblies loaded from disk. If you call <b>GetType</b> to look up a type defined in a dynamic assembly defined using the  <a href="../../System.Reflection.Emit/System.Reflection.Emit.html">System.Reflection.Emit</a> services, you might get inconsistent behavior. The behavior depends on whether the dynamic assembly is persistent, that is, created using the <b>RunAndSave</b> or <b>Save</b> access modes of the  <a href="../../System.Reflection.Emit/types/AssemblyBuilderAccess.html">AssemblyBuilderAccess</a> enumeration. If the dynamic assembly is persistent and has been written to disk before <b>GetType</b> is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly. If the assembly has not been saved to disk when <b>GetType</b> is called, the method returns <b>null</b>.<b>GetType</b> does not understand transient dynamic assemblies; therefore, calling <b>GetType</b> to retrieve a type in a transient dynamic assembly returns <b>null</b>.<p> To use <b>GetType</b> on a dynamic module, subscribe to the  <a href="../../System/types/AppDomain.html#AssemblyResolve">AppDomain.AssemblyResolve</a> event and call <b>GetType</b> before saving. Otherwise, you will get two copies of the assembly in memory.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
<p> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the inheritance is the
                  same as that of the methods that implement the property. Reflection treats
                  properties as hide-by-name-and-signature. See note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual) can be hide-by-name or
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the inheritance is the
                  same as that of the methods that implement the property. Reflection treats
                  properties as hide-by-name-and-signature. See note 2
                  below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
<p> Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</p>
<p><i>typeName</i> can be a simple type name, a type name that includes a namespace, or a complex name that includes an assembly name specification.</p>
<p> If <i>typeName</i> includes only the name of the  <a href="../../System/types/Type.html">Type</a>, this method searches in the calling object's assembly, then in the mscorlib.dll assembly. If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</p>
<p> <a href="#AssemblyQualifiedName">Type.AssemblyQualifiedName</a> can return a fully qualified type name including nested types and the assembly name. All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Delimiter
                </TH>
<TH>
                  Meaning
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Backslash (\)
                </TD>
<TD>
                  Escape character.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Comma (,)
                </TD>
<TD>
                  Precedes the Assembly name.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Plus sign (+)
                </TD>
<TD>
                  Precedes a nested class.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Period (.)
                </TD>
<TD>
                  Denotes namespace identifiers.
                </TD>
</TR>
</table>
<p> For example, the fully qualified name for a class might look like this: </p>
<p><code>
                TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly
              </code></p>
<p> If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\) to prevent it from being interpreted as a nesting separator. Reflection emits this string as follows: </p>
<p><code>
                TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly
              </code></p>
<p> A "++" becomes "\+\+", and a "\" becomes "\\".</p>
<p> This qualified name can be persisted and later used to load the  <a href="../../System/types/Type.html">Type</a>. To search for and load a  <a href="../../System/types/Type.html">Type</a>, use  <a href="#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> either with the type name only or with the assembly qualified type name. <a href="#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> with the type name only will look for the  <a href="../../System/types/Type.html">Type</a> in the caller's assembly and then in the System assembly. <a href="#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> with the assembly qualified type name will look for the  <a href="../../System/types/Type.html">Type</a> in any assembly.</p>
<p> Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type. To retrieve the type name without these trailing characters, use <code>
                t.GetElementType().ToString()
              </code>, where <i>t</i> is the type.</p>
<p> Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</p>
<p> The following table shows the syntax you use with <b>GetType</b> for various types.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  To Get
                </TH>
<TH>
                  Use
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  An
                  unmanaged pointer to
                  <b>MyType</b></TD>
<TD>
                    Type.GetType("MyType*")
                  </TD>
</TR>
<TR valign="top">
<TD>
                  An unmanaged pointer to a pointer to
                  <b>MyType</b></TD>
<TD>
                    Type.GetType("MyType**")
                  </TD>
</TR>
<TR valign="top">
<TD>
                  A
                  managed pointer
                  or
                  reference to
                  <b>MyType</b></TD>
<TD>
                    Type.GetType("MyType&amp;")
                  
                  . Note that unlike pointers, references are
                  limited to one level.
                </TD>
</TR>
<TR valign="top">
<TD>
                  A parent class and a nested class
                </TD>
<TD>
                    Type.GetType("MyParentClass+MyNestedClass")
                  </TD>
</TR>
<TR valign="top">
<TD>
                  A one-dimensional array with a lower bound of 0
                </TD>
<TD>
                    Type.GetType("MyArray[]")
                  </TD>
</TR>
<TR valign="top">
<TD>
                  A one-dimensional array with an unknown lower bound
                </TD>
<TD>
                    Type.GetType("MyArray[*]")
                  </TD>
</TR>
<TR valign="top">
<TD>
                  An n-dimensional array
                </TD>
<TD>
                  A comma (,) inside the brackets a total of n-1
                  times. For example,
                  
                    System.Object[,,]
                  
                  represents a three-dimensional
                  <b>Object</b>
                  array.
                </TD>
</TR>
<TR valign="top">
<TD>
                  A
                  two-dimensional array's array
                </TD>
<TD>
                    Type.GetType("MyArray[][]")
                  </TD>
</TR>
<TR valign="top">
<TD>
                  A rectangular two-dimensional array with unknown lower bounds
                </TD>
<TD>
                    Type.GetType("MyArray[*,*]")
                  
                  or
                  
                    Type.GetType("MyArray[,]")
                  </TD>
</TR>
</table>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
			try
			{
				// Create object of 'Type' class.
				Type myType1 = Type.GetType("System.Int32");
				Console.WriteLine("The 'Fullname' is  {0} ", myType1.FullName);
				// Since 'NoAssembly' assembly does not exist, 'GetType' throws 'TypeLoadException'.
				Type myType2 = Type.GetType("NoAssembly", true);
				Console.WriteLine("The 'Fullname' is  {0} ", myType2.FullName);
			}
			catch(TypeLoadException e)
			{
				Console.WriteLine(e.Message);
			}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/String.html">String</a> |  <a href="../../System/types/TypeLoadException.html">TypeLoadException</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#AssemblyQualifiedName">Type.AssemblyQualifiedName</a> |  <a href="../../System.Reflection/types/Assembly.html#GetAssembly(System.Type)">Assembly.GetAssembly</a> |  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> |  <a href="../../System.Reflection/types/AssemblyName.html">AssemblyName</a> | <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconSpecifyingFullyQualifiedTypeNames.asp">MSDN: specifyingfullyqualifiedtypenames</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetTypeTopic3"></a><a name="GetType(System.String,System.Boolean)">GetType</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>typeName</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>throwOnError</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Gets the  <a href="../../System/types/Type.html">Type</a> with the specified name, performing a case-sensitive search and specifying whether to throw an exception if an error occurs while loading the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public static <a href="../../System/types/Type.html">Type</a> GetType(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>typeName</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>throwOnError</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>typeName</i><br><dl>
<dd>
<param> The name of the  <a href="../../System/types/Type.html">Type</a> to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>throwOnError</i><br><dl>
<dd>
<param><b>true</b> to throw a  <a href="../../System/types/TypeLoadException.html">TypeLoadException</a> if an error occurs while loading the  <a href="../../System/types/Type.html">Type</a>.<p> -or- </p>
<p><b>false</b> to ignore errors while loading the  <a href="../../System/types/Type.html">Type</a>.</p><b>true</b> to throw a  <a href="../../System/types/TypeLoadException.html">TypeLoadException</a> if an error occurs while loading the  <a href="../../System/types/Type.html">Type</a>.<p> -or- </p>
<p><b>false</b> to ignore errors while loading the  <a href="../../System/types/Type.html">Type</a>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The  <a href="../../System/types/Type.html">Type</a> with the specified name, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>typeName</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/TargetInvocationException.html">TargetInvocationException</a></td>
<td> A class initializer is invoked and throws an exception.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/TypeLoadException.html">TypeLoadException</a></td>
<td><i>throwOnError</i> is <b>true</b> and an error is encountered while loading the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd><b>GetType</b> only works on assemblies loaded from disk. If you call <b>GetType</b> to look up a type defined in a dynamic assembly defined using the  <a href="../../System.Reflection.Emit/System.Reflection.Emit.html">System.Reflection.Emit</a> services, you might get inconsistent behavior. The behavior depends on whether the dynamic assembly is persistent, that is, created using the <b>RunAndSave</b> or <b>Save</b> access modes of the  <a href="../../System.Reflection.Emit/types/AssemblyBuilderAccess.html">AssemblyBuilderAccess</a> enumeration. If the dynamic assembly is persistent and has been written to disk before <b>GetType</b> is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly. If the assembly has not been saved to disk when <b>GetType</b> is called, the method returns <b>null</b>.<b>GetType</b> does not understand transient dynamic assemblies; therefore, calling <b>GetType</b> to retrieve a type in a transient dynamic assembly returns <b>null</b>.<p> To use <b>GetType</b> on a dynamic module, subscribe to the  <a href="../../System/types/AppDomain.html#AssemblyResolve">AppDomain.AssemblyResolve</a> event and call <b>GetType</b> before saving. Otherwise, you will get two copies of the assembly in memory.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
<p> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the inheritance is the
                  same as that of the methods that implement the property. Reflection treats
                  properties as hide-by-name-and-signature. See note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual) can be hide-by-name or
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the inheritance is the
                  same as that of the methods that implement the property. Reflection treats
                  properties as hide-by-name-and-signature. See note 2
                  below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
<p> Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</p>
<p><i>typeName</i> can be a simple type name, a type name that includes a namespace, or a complex name that includes an assembly name specification.</p>
<p> If <i>typeName</i> includes only the name of the  <a href="../../System/types/Type.html">Type</a>, this method searches in the calling object's assembly, then in the mscorlib.dll assembly. If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</p>
<p> <a href="#AssemblyQualifiedName">Type.AssemblyQualifiedName</a> can return a fully qualified type name including nested types and the assembly name. All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Delimiter
                </TH>
<TH>
                  Meaning
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Backslash (\)
                </TD>
<TD>
                  Escape character.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Comma (,)
                </TD>
<TD>
                  Precedes the Assembly name.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Plus sign (+)
                </TD>
<TD>
                  Precedes a nested class.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Period (.)
                </TD>
<TD>
                  Denotes namespace identifiers.
                </TD>
</TR>
</table>
<p> For example, the fully qualified name for a class might look like this: </p>
<p><code>
                TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly
              </code></p>
<p> If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\) to prevent it from being interpreted as a nesting separator. Reflection emits this string as follows: </p>
<p><code>
                TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly
              </code></p>
<p> A "++" becomes "\+\+", and a "\" becomes "\\".</p>
<p> This qualified name can be persisted and later used to load the  <a href="../../System/types/Type.html">Type</a>. To search for and load a  <a href="../../System/types/Type.html">Type</a>, use  <a href="#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> either with the type name only or with the assembly qualified type name. <a href="#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> with the type name only will look for the  <a href="../../System/types/Type.html">Type</a> in the caller's assembly and then in the System assembly. <a href="#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> with the assembly qualified type name will look for the  <a href="../../System/types/Type.html">Type</a> in any assembly.</p>
<p> Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type. To retrieve the type name without these trailing characters, use <code>
                t.GetElementType().ToString()
              </code>, where <i>t</i> is the type.</p>
<p> Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</p>
<p> The following table shows the syntax you use with <b>GetType</b> for various types.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  To Get
                </TH>
<TH>
                  Use
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  An
                  unmanaged pointer to
                  <b>MyType</b></TD>
<TD>
                    Type.GetType("MyType*")
                  </TD>
</TR>
<TR valign="top">
<TD>
                  An
                  unmanaged pointer to a pointer to
                  <b>MyType</b></TD>
<TD>
                    Type.GetType("MyType**")
                  </TD>
</TR>
<TR valign="top">
<TD>
                  A
                  managed pointer
                  or
                  reference to
                  <b>MyType</b></TD>
<TD>
                    Type.GetType("MyType&amp;")
                  
                  . Note that unlike pointers, references are
                  limited to one level.
                </TD>
</TR>
<TR valign="top">
<TD>
                  A parent class and a nested class
                </TD>
<TD>
                    Type.GetType("MyParentClass+MyNestedClass")
                  </TD>
</TR>
<TR valign="top">
<TD>
                  A one-dimensional array with a lower bound of 0
                </TD>
<TD>
                    Type.GetType("MyArray[]")
                  </TD>
</TR>
<TR valign="top">
<TD>
                  A one-dimensional array with an unknown lower bound
                </TD>
<TD>
                    Type.GetType("MyArray[*]")
                  </TD>
</TR>
<TR valign="top">
<TD>
                  An n-dimensional array
                </TD>
<TD>
                  A comma (,) inside the brackets a total of n-1
                  times. For example,
                  
                    System.Object[,,]
                  
                  represents a three-dimensional
                  <b>Object</b>
                  array.
                </TD>
</TR>
<TR valign="top">
<TD>
                  A
                  two-dimensional array's array
                </TD>
<TD>
                    Type.GetType("MyArray[][]")
                  </TD>
</TR>
<TR valign="top">
<TD>
                  A rectangular two-dimensional array with unknown lower bounds
                </TD>
<TD>
                    Type.GetType("MyArray[*,*]")
                  
                  or
                  
                    Type.GetType("MyArray[,]")
                  </TD>
</TR>
</table>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
			try
			{
				// Create object of 'Type' class.
				Type myType1 = Type.GetType("System.Int32");
				Console.WriteLine("The 'Fullname' is  {0} ", myType1.FullName);
				// Since 'NoAssembly' assembly does not exist, 'GetType' throws 'TypeLoadException'.
				Type myType2 = Type.GetType("NoAssembly", true);
				Console.WriteLine("The 'Fullname' is  {0} ", myType2.FullName);
			}
			catch(TypeLoadException e)
			{
				Console.WriteLine(e.Message);
			}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/String.html">String</a> |  <a href="../../System/types/TypeLoadException.html">TypeLoadException</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#AssemblyQualifiedName">Type.AssemblyQualifiedName</a> |  <a href="../../System.Reflection/types/Assembly.html#GetAssembly(System.Type)">Assembly.GetAssembly</a> |  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> |  <a href="../../System.Reflection/types/AssemblyName.html">AssemblyName</a> | <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconSpecifyingFullyQualifiedTypeNames.asp">MSDN: specifyingfullyqualifiedtypenames</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetTypeTopic4"></a><a name="GetType(System.String,System.Boolean,System.Boolean)">GetType</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>typeName</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>throwOnError</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>ignoreCase</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Gets the  <a href="../../System/types/Type.html">Type</a> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if an error occurs while loading the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public static <a href="../../System/types/Type.html">Type</a> GetType(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>typeName</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>throwOnError</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>ignoreCase</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>typeName</i><br><dl>
<dd>
<param> The name of the  <a href="../../System/types/Type.html">Type</a> to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>throwOnError</i><br><dl>
<dd>
<param><b>true</b> to throw a  <a href="../../System/types/TypeLoadException.html">TypeLoadException</a> if an error occurs while loading the  <a href="../../System/types/Type.html">Type</a>.<p> -or- </p>
<p><b>false</b> to ignore errors while loading the  <a href="../../System/types/Type.html">Type</a>.</p><b>true</b> to throw a  <a href="../../System/types/TypeLoadException.html">TypeLoadException</a> if an error occurs while loading the  <a href="../../System/types/Type.html">Type</a>.<p> -or- </p>
<p><b>false</b> to ignore errors while loading the  <a href="../../System/types/Type.html">Type</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>ignoreCase</i><br><dl>
<dd>
<param><b>true</b> to perform a case-insensitive search for <i>typeName</i>, if <i>typeName</i> has less than 128 characters.<p> -or- </p>
<p><b>false</b> to perform a case-sensitive search for <i>typeName</i>.</p><b>true</b> to perform a case-insensitive search for <i>typeName</i>, if <i>typeName</i> has less than 128 characters.<p> -or- </p>
<p><b>false</b> to perform a case-sensitive search for <i>typeName</i>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The  <a href="../../System/types/Type.html">Type</a> with the specified name, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>typeName</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/TargetInvocationException.html">TargetInvocationException</a></td>
<td> A class initializer is invoked and throws an exception.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/TypeLoadException.html">TypeLoadException</a></td>
<td><i>throwOnError</i> is <b>true</b> and an error is encountered while loading the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd><b>GetType</b> only works on assemblies loaded from disk. If you call <b>GetType</b> to look up a type defined in a dynamic assembly defined using the  <a href="../../System.Reflection.Emit/System.Reflection.Emit.html">System.Reflection.Emit</a> services, you might get inconsistent behavior. The behavior depends on whether the dynamic assembly is persistent, that is, created using the <b>RunAndSave</b> or <b>Save</b> access modes of the  <a href="../../System.Reflection.Emit/types/AssemblyBuilderAccess.html">AssemblyBuilderAccess</a> enumeration. If the dynamic assembly is persistent and has been written to disk before <b>GetType</b> is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly. If the assembly has not been saved to disk when <b>GetType</b> is called, the method returns <b>null</b>.<b>GetType</b> does not understand transient dynamic assemblies; therefore, calling <b>GetType</b> to retrieve a type in a transient dynamic assembly returns <b>null</b>.<p> To use <b>GetType</b> on a dynamic module, subscribe to the  <a href="../../System/types/AppDomain.html#AssemblyResolve">AppDomain.AssemblyResolve</a> event and call <b>GetType</b> before saving. Otherwise, you will get two copies of the assembly in memory.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
<p> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the inheritance is the
                  same as that of the methods that implement the property. Reflection treats
                  properties as hide-by-name-and-signature. See note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual) can be hide-by-name or
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the inheritance is the
                  same as that of the methods that implement the property. Reflection treats
                  properties as hide-by-name-and-signature. See note 2
                  below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
<p> Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</p>
<p><i>typeName</i> can be a simple type name, a type name that includes a namespace, or a complex name that includes an assembly name specification.</p>
<p> If <i>typeName</i> includes only the name of the  <a href="../../System/types/Type.html">Type</a>, this method searches in the calling object's assembly, then in the mscorlib.dll assembly. If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</p>
<p><b></b></p>
<p> <a href="#AssemblyQualifiedName">Type.AssemblyQualifiedName</a> can return a fully qualified type name including nested types and the assembly name. All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Delimiter
                </TH>
<TH>
                  Meaning
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Backslash (\)
                </TD>
<TD>
                  Escape character.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Comma (,)
                </TD>
<TD>
                  Precedes the Assembly name.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Plus sign (+)
                </TD>
<TD>
                  Precedes a nested class.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Period (.)
                </TD>
<TD>
                  Denotes namespace identifiers.
                </TD>
</TR>
</table>
<p> For example, the fully qualified name for a class might look like this: </p>
<p><code>
                TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly
              </code></p>
<p> If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\) to prevent it from being interpreted as a nesting separator. Reflection emits this string as follows: </p>
<p><code>
                TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly
              </code></p>
<p> A "++" becomes "\+\+", and a "\" becomes "\\".</p>
<p> This qualified name can be persisted and later used to load the  <a href="../../System/types/Type.html">Type</a>. To search for and load a  <a href="../../System/types/Type.html">Type</a>, use  <a href="#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> either with the type name only or with the assembly qualified type name. <a href="#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> with the type name only will look for the  <a href="../../System/types/Type.html">Type</a> in the caller's assembly and then in the System assembly. <a href="#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> with the assembly qualified type name will look for the  <a href="../../System/types/Type.html">Type</a> in any assembly.</p>
<p> Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type. To retrieve the type name without these trailing characters, use <code>
                t.GetElementType().ToString()
              </code>, where <i>t</i> is the type.</p>
<p> Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</p>
<p> The following table shows the syntax you use with <b>GetType</b> for various types.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  To Get
                </TH>
<TH>
                  Use
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  An
                  unmanaged pointer to
                  <b>MyType</b></TD>
<TD>
                    Type.GetType("MyType*")
                  </TD>
</TR>
<TR valign="top">
<TD>
                  An
                  unmanaged pointer to a pointer to
                  <b>MyType</b></TD>
<TD>
                    Type.GetType("MyType**")
                  </TD>
</TR>
<TR valign="top">
<TD>
                  A
                  managed pointer
                  or
                  reference to
                  <b>MyType</b></TD>
<TD>
                    Type.GetType("MyType&amp;")
                  
                  . Note that unlike pointers, references are
                  limited to one level.
                </TD>
</TR>
<TR valign="top">
<TD>
                  A parent class and a nested class
                </TD>
<TD>
                    Type.GetType("MyParentClass+MyNestedClass")
                  </TD>
</TR>
<TR valign="top">
<TD>
                  A one-dimensional array with a lower bound of 0
                </TD>
<TD>
                    Type.GetType("MyArray[]")
                  </TD>
</TR>
<TR valign="top">
<TD>
                  A one-dimensional array with an unknown lower bound
                </TD>
<TD>
                    Type.GetType("MyArray[*]")
                  </TD>
</TR>
<TR valign="top">
<TD>
                  An n-dimensional array
                </TD>
<TD>
                  A comma (,) inside the brackets a total of n-1
                  times. For example,
                  
                    System.Object[,,]
                  
                  represents a three-dimensional
                  <b>Object</b>
                  array.
                </TD>
</TR>
<TR valign="top">
<TD>
                  A
                  two-dimensional array's array
                </TD>
<TD>
                    Type.GetType("MyArray[][]")
                  </TD>
</TR>
<TR valign="top">
<TD>
                  A rectangular two-dimensional array with unknown lower bounds
                </TD>
<TD>
                    Type.GetType("MyArray[*,*]")
                  
                  or
                  
                    Type.GetType("MyArray[,]")
                  </TD>
</TR>
</table>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/String.html">String</a> |  <a href="../../System/types/TypeLoadException.html">TypeLoadException</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#AssemblyQualifiedName">Type.AssemblyQualifiedName</a> |  <a href="../../System.Reflection/types/Assembly.html#GetAssembly(System.Type)">Assembly.GetAssembly</a> |  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> |  <a href="../../System.Reflection/types/AssemblyName.html">AssemblyName</a> | <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconSpecifyingFullyQualifiedTypeNames.asp">MSDN: specifyingfullyqualifiedtypenames</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetTypeArrayTopic1"></a><a name="GetTypeArray(System.Object[])">GetTypeArray</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Object.html">object[]</a> <i>args</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Gets the types of the objects in the specified array.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public static <a href="../../System/types/Type.html">Type[]</a> GetTypeArray(<br>   <font color="#008080"><a href="../../System/types/Object.html">object[]</a> <i>args</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>args</i><br><dl>
<dd>
<param> An array of objects whose types to determine.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the types of the corresponding elements in <i>args</i>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>args</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/TargetInvocationException.html">TargetInvocationException</a></td>
<td> The class initializers are invoked and at least one throws an exception.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
				Object[] myObject = new Object[3];
				myObject[0] = 66;
				myObject[1] = "puri";
				myObject[2] = 33.33;
				// Get the array of 'Type' class objects.
				Type[] myTypeArray = Type.GetTypeArray(myObject);
				Console.WriteLine("Full names of the 'Type' objects in the array are:");
				for(int h = 0; h &lt; myTypeArray.Length ; h++)
				{
					Console.WriteLine(myTypeArray[h].FullName);
				}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetTypeCodeTopic1"></a><a name="GetTypeCode(System.Type)">GetTypeCode</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>type</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Gets the underlying type code of the specified  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public static <a href="../../System/types/TypeCode.html">TypeCode</a> GetTypeCode(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>type</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>type</i><br><dl>
<dd>
<param> The  <a href="../../System/types/Type.html">Type</a> whose underlying type code to get.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The  <a href="../../System/types/TypeCode.html">TypeCode</a> value of the underlying type.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
				// Create an object of 'Type' class.
				Type myType1 = Type.GetType("System.Int32");
				// Get the 'TypeCode' of the 'Type' class object created above.
				TypeCode myTypeCode = Type.GetTypeCode(myType1);
				Console.WriteLine("TypeCode is: {0}",myTypeCode);

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/TypeCode.html">TypeCode</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetTypeFromHandleTopic1"></a><a name="GetTypeFromHandle(System.RuntimeTypeHandle)">GetTypeFromHandle</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/RuntimeTypeHandle.html">RuntimeTypeHandle</a> <i>handle</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Gets the  <a href="../../System/types/Type.html">Type</a> referenced by the specified type handle.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public static <a href="../../System/types/Type.html">Type</a> GetTypeFromHandle(<br>   <font color="#008080"><a href="../../System/types/RuntimeTypeHandle.html">RuntimeTypeHandle</a> <i>handle</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>handle</i><br><dl>
<dd>
<param> The  <a href="../../System/types/RuntimeTypeHandle.html">RuntimeTypeHandle</a> object that refers to the  <a href="../../System/types/Type.html">Type</a>.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The  <a href="../../System/types/Type.html">Type</a> referenced by the specified  <a href="../../System/types/RuntimeTypeHandle.html">RuntimeTypeHandle</a>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>handle</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/TargetInvocationException.html">TargetInvocationException</a></td>
<td> A class initializer is invoked and throws an exception.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The handles are valid only in the application domain in which they were obtained.<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
        MyClass1 myClass1 = new MyClass1();
	     // Get the type referenced by the specified type handle.
        Type myClass1Type = Type.GetTypeFromHandle(Type.GetTypeHandle(myClass1));
        Console.WriteLine("The Names of the Attributes :"+myClass1Type.Attributes);

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/RuntimeTypeHandle.html">RuntimeTypeHandle</a> |  <a href="#TypeHandle">Type.TypeHandle</a> |  <a href="#GetTypeHandle(System.Object)">Type.GetTypeHandle</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetTypeHandleTopic1"></a><a name="GetTypeHandle(System.Object)">GetTypeHandle</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>o</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Gets the handle for the  <a href="../../System/types/Type.html">Type</a> of a specified object.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public static <a href="../../System/types/RuntimeTypeHandle.html">RuntimeTypeHandle</a> GetTypeHandle(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>o</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>o</i><br><dl>
<dd>
<param> The  <a href="../../System/types/Object.html">Object</a> for which to get the Type handle.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The handle for the  <a href="../../System/types/Type.html">Type</a> of the specified  <a href="../../System/types/Object.html">Object</a>.</dd>
</dl><b>Remarks</b><dl>
<dd> The handles are valid only in the application domain in which they were obtained.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
       MyClass1 myClass1 = new MyClass1();
        // Get the handle for the specified object.
       RuntimeTypeHandle myClass1Type = Type.GetTypeHandle(myClass1);
       Console.WriteLine("Value :"+myClass1Type.Value);
       Console.WriteLine("Type  :"+myClass1Type.GetType());

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/RuntimeTypeHandle.html">RuntimeTypeHandle</a> |  <a href="#TypeHandle">Type.TypeHandle</a> |  <a href="#GetTypeFromHandle(System.RuntimeTypeHandle)">Type.GetTypeFromHandle</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="HasElementTypeImplTopic1"></a><a name="HasElementTypeImpl">HasElementTypeImpl</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, implements the  <a href="#HasElementType">Type.HasElementType</a> property and determines whether the current  <a href="../../System/types/Type.html">Type</a> encompasses or refers to another type; that is, whether the current  <a href="../../System/types/Type.html">Type</a> is an array, a pointer, or is passed by reference.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected abstract <a href="../../System/types/Boolean.html">bool</a> HasElementTypeImpl();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the  <a href="../../System/types/Type.html">Type</a> is an array, a pointer, or is passed by reference; otherwise, <b>false</b>.</dd>
</dl><b>Remarks</b><dl>
<dd> For example, Type.GetType("Int32[]").HasElementTypeImpl returns <b>true</b>, but Type.GetType("Int32").HasElementTypeImpl returns <b>false</b>. HasElementTypeImpl also returns <b>true</b> for "Int32*" and "Int32&amp;".</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
public class MyTypeDelegator : TypeDelegator
{
   public string myElementType = null;
   private Type myType = null ; 

   public MyTypeDelegator(Type myType) : base(myType)
   {
      this.myType = myType;
   }

   // Overrides 'HasElementTypeImpl()' method of 'Type' class.
   protected override bool HasElementTypeImpl()
   {
      // Check whether the type is an array.
      if(myType.IsArray)
      {
         myElementType = "array";
         return true;
      }
      // Check whether the type is a reference.
      if(myType.IsByRef)
      {
         myElementType = "reference";
         return true;
      }
      // Check whether the type is a pointer.
      if(myType.IsPointer)
      { 
         myElementType = "pointer";
         return true;
      }
      // The type is not a reference or array or pointer type.
      return false;
   }  
}

public class Type_HasElementTypeImpl
{
   public static void Main()
   {
      try
      {
         int myInt = 0 ; 
         int[] myArray = new int[5];

         MyTypeDelegator myType = new MyTypeDelegator(myArray.GetType());

         Console.WriteLine("\nCheck whether a variable refers to an array or pointer or reference type.\n");
         // Check if 'myType' is an array, pointer, reference type.  
         if( myType.HasElementType)
            Console.WriteLine("'myArray' is an {0}", myType.myElementType);
         else
            Console.WriteLine("'myArray' does not refer to an array or pointer or reference");

         myType = new MyTypeDelegator(myInt.GetType());

         // Check if 'myType' is an array, pointer, reference type. 
         if( myType.HasElementType)
            Console.WriteLine("'myInt' is an {0}", myType.myElementType);
         else
            Console.WriteLine("'myInt' does not refer to an array or pointer or reference");

      }
      catch( Exception e )
      {
         Console.WriteLine("Exception: {0}", e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#HasElementType">Type.HasElementType</a> |  <a href="#IsArray">Type.IsArray</a> |  <a href="#IsPointer">Type.IsPointer</a> |  <a href="#IsByRef">Type.IsByRef</a> |  <a href="#GetElementType">Type.GetElementType</a> |  <a href="#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="InvokeMemberTopic1"></a><a name="InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">InvokeMember</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>invokeAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>target</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object[]</a> <i>args</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Invokes the specified member, using the specified binding constraints and matching the specified argument list.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Object.html">object</a> InvokeMember(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>invokeAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>target</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object[]</a> <i>args</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the constructor, method, property, or field member to invoke. -or- <p> An empty string ("") to invoke the default member.</p> -or- <p> An empty string ("") to invoke the default member.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>invokeAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted. The access can be one of the <b>BindingFlags</b> such as <b>Public</b>, <b>NonPublic</b>, <b>Private</b>, <b>InvokeMethod</b>, <b>GetField</b>, and so on. The type of lookup need not be specified. If the type of lookup is omitted, <b>BindingFlags.Public</b> | <b>BindingFlags.Instance</b> will apply.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>target</i><br><dl>
<dd>
<param> The  <a href="../../System/types/Object.html">Object</a> on which to invoke the specified member.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>args</i><br><dl>
<dd>
<param> An array containing the arguments to pass to the member to invoke.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An  <a href="../../System/types/Object.html">Object</a> representing the return value of the invoked member.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>invokeAttr</i> contains <i>CreateInstance</i> and <i>typeName</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>args</i> is multidimensional.<p> -or- </p>
<p><i>invokeAttr</i> is not a valid  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> attribute.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains <i>CreateInstance</i> combined with <i>InvokeMethod</i>, <i>GetField</i>, <i>SetField</i>, <i>GetProperty</i>, or <i>SetProperty</i>.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains both <i>GetField</i> and <i>SetField</i>.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains both <i>GetProperty</i> and <i>SetProperty</i>.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains <i>InvokeMethod</i> combined with <i>SetField</i> or <i>SetProperty</i>.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains <i>SetField</i> and <i>args</i> has more than one element.</p>
<p> -or- </p>
<p> This method is called on a COM object and one of the following binding flags was not passed in: <b>BindingFlags.InvokeMethod</b>, <b>BindingFlags.GetProperty</b>, <b>BindingFlags.SetProperty</b>, <b>BindingFlags.PutDispProperty</b>, or <b>BindingFlags.PutRefDispProperty</b>.</p>
<p> -or- </p>
<p> One of the named parameter arrays contains a string that is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/MemberAccessException.html">MemberAccessException</a></td>
<td> The specified member is a class initializer.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/MissingFieldException.html">MissingFieldException</a></td>
<td> The field or property cannot be found.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/MissingMethodException.html">MissingMethodException</a></td>
<td> The method cannot be found.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Security/types/SecurityException.html">SecurityException</a></td>
<td> The specified member is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public members outside the current assembly.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/TargetException.html">TargetException</a></td>
<td> The specified member cannot be invoked on <i>target</i>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one method matches the binding criteria.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which members to include in the search: <UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public members in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public members (that is, private and protected members) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static members up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.IgnoreCase</b> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <b>IgnoreCase</b> flag.</li>
<li><b>BindingFlags.DeclaredOnly</b> to search only the members declared on the  <a href="../../System/types/Type.html">Type</a>, not members that were simply inherited.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> invocation flags can be used to denote what action to take with the member: </p>
<UL>
<li><b>CreateInstance</b> to invoke a constructor.<i>name</i> is ignored. Not valid with other invocation flags.</li>
<li><b>InvokeMethod</b> to invoke a method, but not a constructor or a type initializer. Not valid with <b>SetField</b> or <b>SetProperty</b>.</li>
<li><b>GetField</b> to get the value of a field. Not valid with <b>SetField</b>.</li>
<li><b>SetField</b> to set the value of a field. Not valid with <b>GetField</b>.</li>
<li><b>GetProperty</b> to get a property. Not valid with <b>SetProperty</b>.</li>
<li><b>SetProperty</b> to set a property. Not valid with <b>GetProperty</b>.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> A method will be invoked if the following conditions are true: </p>
<UL>
<li> The number of parameters in the method declaration equals the number of arguments in the <i>args</i> array (unless default arguments are defined on the member), and </li>
<li> The type of each arguments can be converted by the binder to the type of the parameter.</li>
</UL> The binder will find all of the matching methods. These methods are found based upon the type of binding requested ( <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> values <b>InvokeMethod</b>, <b>GetProperty</b>, and so on). The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.<p> After the method is selected, it is invoked. Accessibility is checked at that point. The search may control which set of methods are searched based upon the accessibility attribute associated with the method. The  <a href="../../System.Reflection/types/Binder.html#BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)">Binder.BindToMethod</a> method of the  <a href="../../System.Reflection/types/Binder.html">Binder</a> class is responsible for selecting the method to be invoked. The default binder selects the most specific match.</p>
<p> Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through  <a href="../../System.Reflection/System.Reflection.html">System.Reflection</a> whenever the code is fully trusted.</p>
<p> You can use Type.InvokeMember to set a field to a particular value by specifying BindingFlags.SetField. For example, if you want to set a public instance field named F on class C, and F is a <b>String</b> you can say: </p><code>
              typeof(C).InvokeMember( "F",
              BindingFlags.SetField, null, C, new Object{ "strings new value"}, null, null,
              null );
            </code><p> Now suppose that F is a <b>String[]</b> you can say: </p><code>
              typeof(C).InvokeMember( "F",
              BindingFlags.SetField, null, C, new Object{new String[]{"a","z","c","d"}, null,
              null, null );
            </code><p> which will initialize the field F to this new array. Furthermore you can use Type.InvokeMember to set a position in an array by supplying to the index of the value and then the next value by doing the following: </p><code>
              typeof(C).InvokeMember( "F",
              BindingFlags.SetField, null, C, new Object{1, "b"}, null, null, null );
            </code><p> This will change string "z" in the array that F holds to string "b".</p>
</dd>
</dl><b>Example</b><dl>
<dd> Here are syntax examples using <b>InvokeMember</b> to invoke, get, and set various members.<pre>
using System;
using System.IO;
using System.Reflection;

public class Sample
{
 public void Method()
 {

//Call a static method
 Type t = typeof (TestClass);
 t.InvokeMember ("SayHello", BindingFlags.Public | BindingFlags.InvokeMethod | BindingFlags.Static, null, null, new object [] {});
         
 //Call an instance method
 TestClass c = new TestClass ();
 c.GetType().InvokeMember ("AddUp", BindingFlags.Public | BindingFlags.InvokeMethod, null, c, new object [] {});
 c.GetType().InvokeMember ("AddUp", BindingFlags.Public | BindingFlags.InvokeMethod, null, c, new object [] {});
         
 //Call a method with arguments
 object [] args = new object [] {100.09, 184.45};
 object result;
 result = t.InvokeMember ("ComputeSum", BindingFlags.Public | BindingFlags.InvokeMethod | BindingFlags.Static, null, null, args);
 Console.WriteLine ("{0} + {1} = {2}", args[0], args[1], result);
         
 //Get a field value
 result = t.InvokeMember ("Name", BindingFlags.Public | BindingFlags.GetField, null, c, new object [] {});
 Console.WriteLine ("Name == {0}", result);
         
 //Set a field
 t.InvokeMember ("Name", BindingFlags.Public |BindingFlags.SetField, null, c, new object [] {"NewName"});
 result = t.InvokeMember ("Name", BindingFlags.Public |BindingFlags.GetField, null, c, new object [] {});
 Console.WriteLine ("Name == {0}", result);
         
 //Get an indexed property value
 int  index = 3;
 result = t.InvokeMember ("Item", BindingFlags.Public |BindingFlags.GetProperty , null, c, new object [] {index});
 Console.WriteLine ("Item[{0}] == {1}", index, result);
         
 //Set an indexed property value
 index = 3;
 t.InvokeMember ("Item", BindingFlags.Public |BindingFlags.SetProperty, null, c, new object [] {index, "NewValue"});
 result = t.InvokeMember ("Item", BindingFlags.Public |BindingFlags.GetProperty , null, c, new object [] {index});
 Console.WriteLine ("Item[{0}] == {1}", index, result);
         
 //Get a field or property
 result = t.InvokeMember ("Name", BindingFlags.Public |BindingFlags.GetField | BindingFlags.GetProperty, null, c, new object [] {});
 Console.WriteLine ("Name == {0}", result);
 result = t.InvokeMember ("Value", BindingFlags.Public |BindingFlags.GetField | BindingFlags.GetProperty, null, c, new object [] {});
 Console.WriteLine ("Value == {0}", result);
         
 //Call a method using named arguments
 object[] argValues = new object [] {"Mouse", "Micky"};
 String [] argNames = new String [] {"lastName", "firstName"};
 t.InvokeMember ("PrintName", BindingFlags.Public |BindingFlags.InvokeMethod, null, null, argValues, null, null, argNames);
         
 //Call the default member of a type
 Type t3 = typeof (TestClass2);
 t3.InvokeMember ("", BindingFlags.Public |BindingFlags.InvokeMethod, null, new TestClass2(), new object [] {});
         
 //Invoking a ByRef member
 MethodInfo m = t.GetMethod("Swap");
 args = new object[2];
 args[0] = 1;
 args[1] = 2;
 m.Invoke(new TestClass(),args);
 Console.WriteLine ("{0}, {1}", args[0], args[1]);
 Console.WriteLine ("\r\nPress Return to exit.");
 Console.Read();

 }
}

// Class added so sample will compile
public class TestClass {}

// Class added so sample will compile
public class TestClass2 {}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting members that are not public. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#MemberAccess">ReflectionPermissionFlag.MemberAccess</a></dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/SecurityPermission.html">SecurityPermission</a> to call unmanaged code. Associated enumeration:  <a href="../../System.Security.Permissions/types/SecurityPermissionFlag.html#UnmanagedCode">SecurityPermissionFlag.UnmanagedCode</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/Binder.html">Binder</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Reflection/types/ParameterAttributes.html">ParameterAttributes</a> |  <a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="InvokeMemberTopic2"></a><a name="InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">InvokeMember</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>invokeAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>target</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object[]</a> <i>args</i>,</font><br>   <font color="#008080"><a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> <i>culture</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Object.html">object</a> InvokeMember(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>invokeAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>target</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object[]</a> <i>args</i>,</font><br>   <font color="#008080"><a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> <i>culture</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the constructor, method, property, or field member to invoke.<p> -or- </p>
<p> An empty string ("") to invoke the default member.</p> The  <a href="../../System/types/String.html">String</a> containing the name of the constructor, method, property, or field member to invoke.<p> -or- </p>
<p> An empty string ("") to invoke the default member.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>invokeAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted. The access can be one of the <b>BindingFlags</b> such as <b>Public</b>, <b>NonPublic</b>, <b>Private</b>, <b>InvokeMethod</b>, <b>GetField</b>, and so on. The type of lookup need not be specified. If the type of lookup is omitted, <b>BindingFlags.Public</b> | <b>BindingFlags.Instance</b> will apply.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>target</i><br><dl>
<dd>
<param> The  <a href="../../System/types/Object.html">Object</a> on which to invoke the specified member.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>args</i><br><dl>
<dd>
<param> An array containing the arguments to pass to the member to invoke.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>culture</i><br><dl>
<dd>
<param> The  <a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.<p> -or- </p>
<p><b>null</b> to use the current thread's  <a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a>.</p> The  <a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.<p> -or- </p>
<p><b>null</b> to use the current thread's  <a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An  <a href="../../System/types/Object.html">Object</a> representing the return value of the invoked member.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>invokeAttr</i> contains <i>CreateInstance</i> and <i>typeName</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>args</i> is multidimensional.<p> -or- </p>
<p><i>invokeAttr</i> is not a valid  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> attribute.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains <i>CreateInstance</i> combined with <i>InvokeMethod</i>, <i>GetField</i>, <i>SetField</i>, <i>GetProperty</i>, or <i>SetProperty</i>.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains both <i>GetField</i> and <i>SetField</i>.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains both <i>GetProperty</i> and <i>SetProperty</i>.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains <i>InvokeMethod</i> combined with <i>SetField</i> or <i>SetProperty</i>.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains <i>SetField</i> and <i>args</i> has more than one element.</p>
<p> -or- </p>
<p> This method is called on a COM object and one of the following binding flags was not passed in: <b>BindingFlags.InvokeMethod</b>, <b>BindingFlags.GetProperty</b>, <b>BindingFlags.SetProperty</b>, <b>BindingFlags.PutDispProperty</b>, or <b>BindingFlags.PutRefDispProperty</b>.</p>
<p> -or- </p>
<p> One of the named parameter arrays contains a string that is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/MemberAccessException.html">MemberAccessException</a></td>
<td> The specified member is a class initializer.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/MissingFieldException.html">MissingFieldException</a></td>
<td> The field or property cannot be found.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/MissingMethodException.html">MissingMethodException</a></td>
<td> The method cannot be found.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Security/types/SecurityException.html">SecurityException</a></td>
<td> The specified member is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public members outside the current assembly.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/TargetException.html">TargetException</a></td>
<td> The specified member cannot be invoked on <i>target</i>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one method matches the binding criteria.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Although the default binder does not process  <a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> (the <i>culture</i> parameter), you can use the abstract  <a href="../../System.Reflection/types/Binder.html">Binder</a> class to write a custom binder that does process <i>culture</i>.<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which members to include in the search: </p>
<UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public members in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public members (that is, private and protected members) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static members up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.IgnoreCase</b> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <b>IgnoreCase</b> flag.</li>
<li><b>BindingFlags.DeclaredOnly</b> to search only the members declared on the  <a href="../../System/types/Type.html">Type</a>, not members that were simply inherited.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> invocation flags can be used to denote what action to take with the member: </p>
<UL>
<li><b>CreateInstance</b> to invoke a constructor.<i>name</i> is ignored. Not valid with other invocation flags.</li>
<li><b>InvokeMethod</b> to invoke a method, but not a constructor or a type initializer. Not valid with <b>SetField</b> or <b>SetProperty</b>.</li>
<li><b>GetField</b> to get the value of a field. Not valid with <b>SetField</b>.</li>
<li><b>SetField</b> to set the value of a field. Not valid with <b>GetField</b>.</li>
<li><b>GetProperty</b> to get a property. Not valid with <b>SetProperty</b>.</li>
<li><b>SetProperty</b> to set a property. Not valid with <b>GetProperty</b>.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> A method will be invoked if the following conditions are true: </p>
<UL>
<li> The number of parameters in the method declaration equals the number of arguments in the <i>args</i> array (unless default arguments are defined on the member).</li>
<li> The type of each arguments can be converted by the binder to the type of the parameter.</li>
</UL> The binder will find all of the matching methods. These methods are found based upon the type of binding requested ( <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> values <b>InvokeMethod</b>, <b>GetProperty</b>, and so on). The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.<p> After the method is selected, it is invoked. Accessibility is checked at that point. The search may control which set of methods are searched based upon the accessibility attribute associated with the method. The  <a href="../../System.Reflection/types/Binder.html#BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)">Binder.BindToMethod</a> method of the  <a href="../../System.Reflection/types/Binder.html">Binder</a> class is responsible for selecting the method to be invoked. The default binder selects the most specific match.</p>
<p> Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through Reflection whenever the code is fully trusted.</p>
<p> You can use Type.InvokeMember to set a field to a particular value by specifying BindingFlags.SetField. For example, if you want to set a public instance field named F on class C, and F is a <b>String</b> you can say: </p><code>
              typeof(C).InvokeMember( "F",
              BindingFlags.SetField, null, C, new Object{ "strings new value"}, null, null,
              null );
            </code><p> Now suppose that F is a <b>String[]</b> you can say: </p><code>
              typeof(C).InvokeMember( "F",
              BindingFlags.SetField, null, C, new Object{new String[]{"a","z","c","d"}, null,
              null, null );
            </code><p> which will initialize the field F to this new array. Furthermore you can use Type.InvokeMember to set a position in an array by supplying to the index of the value and then the next value by doing the following: </p><code>
              typeof(C).InvokeMember( "F",
              BindingFlags.SetField, null, C, new Object{1, "b"}, null, null, null );
            </code><p> This will change string "z" in the array that F holds to string "b".</p>
</dd>
</dl><b>Example</b><dl>
<dd> Here are syntax examples using <b>InvokeMember</b> to invoke, get, and set various members.<pre>
using System;
using System.IO;
using System.Reflection;

public class Sample
{
 public void Method()
 {

//Call a static method
 Type t = typeof (TestClass);
 t.InvokeMember ("SayHello", BindingFlags.Public | BindingFlags.InvokeMethod | BindingFlags.Static, null, null, new object [] {});
         
 //Call an instance method
 TestClass c = new TestClass ();
 c.GetType().InvokeMember ("AddUp", BindingFlags.Public | BindingFlags.InvokeMethod, null, c, new object [] {});
 c.GetType().InvokeMember ("AddUp", BindingFlags.Public | BindingFlags.InvokeMethod, null, c, new object [] {});
         
 //Call a method with arguments
 object [] args = new object [] {100.09, 184.45};
 object result;
 result = t.InvokeMember ("ComputeSum", BindingFlags.Public | BindingFlags.InvokeMethod | BindingFlags.Static, null, null, args);
 Console.WriteLine ("{0} + {1} = {2}", args[0], args[1], result);
         
 //Get a field value
 result = t.InvokeMember ("Name", BindingFlags.Public | BindingFlags.GetField, null, c, new object [] {});
 Console.WriteLine ("Name == {0}", result);
         
 //Set a field
 t.InvokeMember ("Name", BindingFlags.Public |BindingFlags.SetField, null, c, new object [] {"NewName"});
 result = t.InvokeMember ("Name", BindingFlags.Public |BindingFlags.GetField, null, c, new object [] {});
 Console.WriteLine ("Name == {0}", result);
         
 //Get an indexed property value
 int  index = 3;
 result = t.InvokeMember ("Item", BindingFlags.Public |BindingFlags.GetProperty , null, c, new object [] {index});
 Console.WriteLine ("Item[{0}] == {1}", index, result);
         
 //Set an indexed property value
 index = 3;
 t.InvokeMember ("Item", BindingFlags.Public |BindingFlags.SetProperty, null, c, new object [] {index, "NewValue"});
 result = t.InvokeMember ("Item", BindingFlags.Public |BindingFlags.GetProperty , null, c, new object [] {index});
 Console.WriteLine ("Item[{0}] == {1}", index, result);
         
 //Get a field or property
 result = t.InvokeMember ("Name", BindingFlags.Public |BindingFlags.GetField | BindingFlags.GetProperty, null, c, new object [] {});
 Console.WriteLine ("Name == {0}", result);
 result = t.InvokeMember ("Value", BindingFlags.Public |BindingFlags.GetField | BindingFlags.GetProperty, null, c, new object [] {});
 Console.WriteLine ("Value == {0}", result);
         
 //Call a method using named arguments
 object[] argValues = new object [] {"Mouse", "Micky"};
 String [] argNames = new String [] {"lastName", "firstName"};
 t.InvokeMember ("PrintName", BindingFlags.Public |BindingFlags.InvokeMethod, null, null, argValues, null, null, argNames);
         
 //Call the default member of a type
 Type t3 = typeof (TestClass2);
 t3.InvokeMember ("", BindingFlags.Public |BindingFlags.InvokeMethod, null, new TestClass2(), new object [] {});
         
 //Invoking a ByRef member
 MethodInfo m = t.GetMethod("Swap");
 args = new object[2];
 args[0] = 1;
 args[1] = 2;
 m.Invoke(new TestClass(),args);
 Console.WriteLine ("{0}, {1}", args[0], args[1]);
 Console.WriteLine ("\r\nPress Return to exit.");
 Console.Read();

 }
}

// Class added so sample will compile
public class TestClass {}

// Class added so sample will compile
public class TestClass2 {}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting members that are not public. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#MemberAccess">ReflectionPermissionFlag.MemberAccess</a></dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/SecurityPermission.html">SecurityPermission</a> to call unmanaged code. Associated enumeration:  <a href="../../System.Security.Permissions/types/SecurityPermissionFlag.html#UnmanagedCode">SecurityPermissionFlag.UnmanagedCode</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/Binder.html">Binder</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Reflection/types/ParameterAttributes.html">ParameterAttributes</a> |  <a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="InvokeMemberTopic3"></a><a name="InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">InvokeMember</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>invokeAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>target</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object[]</a> <i>args</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i>,</font><br>   <font color="#008080"><a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> <i>culture</i>,</font><br>   <font color="#008080"><a href="../../System/types/String.html">string[]</a> <i>namedParameters</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, invokes the specified member, using the specified binding constraints and matching the specified argument list, modifiers and culture.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/Object.html">object</a> InvokeMember(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>invokeAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>target</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object[]</a> <i>args</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i>,</font><br>   <font color="#008080"><a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> <i>culture</i>,</font><br>   <font color="#008080"><a href="../../System/types/String.html">string[]</a> <i>namedParameters</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the constructor, method, property, or field member to invoke.<p> -or- </p>
<p> An empty string ("") to invoke the default member.</p> The  <a href="../../System/types/String.html">String</a> containing the name of the constructor, method, property, or field member to invoke.<p> -or- </p>
<p> An empty string ("") to invoke the default member.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>invokeAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted. The access can be one of the <b>BindingFlags</b> such as <b>Public</b>, <b>NonPublic</b>, <b>Private</b>, <b>InvokeMethod</b>, <b>GetField</b>, and so on. The type of lookup need not be specified. If the type of lookup is omitted, <b>BindingFlags.Public</b> | <b>BindingFlags.Instance</b> will apply.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>target</i><br><dl>
<dd>
<param> The  <a href="../../System/types/Object.html">Object</a> on which to invoke the specified member.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>args</i><br><dl>
<dd>
<param> An array containing the arguments to pass to the member to invoke.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <i>args</i> array. A parameter's associated attributes are stored in the member's signature. The default binder does not process this parameter. An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <i>args</i> array. A parameter's associated attributes are stored in the member's signature. The default binder does not process this parameter.</dd>
</dl>
</p>
</dd>
<dd>
<p><i>culture</i><br><dl>
<dd>
<param> The  <a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.<p> -or- </p>
<p><b>null</b> to use the current thread's  <a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a>.</p> The  <a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.<p> -or- </p>
<p><b>null</b> to use the current thread's  <a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>namedParameters</i><br><dl>
<dd>
<param> An array containing the names of the parameters to which the values in the <i>args</i> array are passed.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An  <a href="../../System/types/Object.html">Object</a> representing the return value of the invoked member.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>invokeAttr</i> contains <i>CreateInstance</i> and <i>typeName</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>args</i> is multidimensional.<p> -or- </p>
<p><i>modifiers</i> is multidimensional.</p>
<p> -or- </p>
<p><i>args</i> and <i>modifiers</i> do not have the same length.</p>
<p> -or- </p>
<p><i>invokeAttr</i> is not a valid  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> attribute.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains <i>CreateInstance</i> combined with <i>InvokeMethod</i>, <i>GetField</i>, <i>SetField</i>, <i>GetProperty</i>, or <i>SetProperty</i>.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains both <i>GetField</i> and <i>SetField</i>.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains both <i>GetProperty</i> and <i>SetProperty</i>.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains <i>InvokeMethod</i> combined with <i>SetField</i> or <i>SetProperty</i>.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains <i>SetField</i> and <i>args</i> has more than one element.</p>
<p> -or- </p>
<p> The named parameter array is larger than the argument array.</p>
<p> -or- </p>
<p> This method is called on a COM object and one of the following binding flags was not passed in: <b>BindingFlags.InvokeMethod</b>, <b>BindingFlags.GetProperty</b>, <b>BindingFlags.SetProperty</b>, <b>BindingFlags.PutDispProperty</b>, or <b>BindingFlags.PutRefDispProperty</b>.</p>
<p> -or- </p>
<p> One of the named parameter arrays contains a string that is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/MemberAccessException.html">MemberAccessException</a></td>
<td> The specified member is a class initializer.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/MissingFieldException.html">MissingFieldException</a></td>
<td> The field or property cannot be found.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/MissingMethodException.html">MissingMethodException</a></td>
<td> The method cannot be found.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Security/types/SecurityException.html">SecurityException</a></td>
<td> The specified member is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public members outside the current assembly.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/TargetException.html">TargetException</a></td>
<td> The specified member cannot be invoked on <i>target</i>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one method matches the binding criteria.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">IReflect.InvokeMember</a></dd>
</dl><b>Remarks</b><dl>
<dd><b>InvokeMember</b> calls a constructor member or a method member, gets or sets a property member, gets or sets a data field member, or gets or sets an element of an array member.<p> Although the default binder does not process  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> or  <a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> (the <i>modifiers</i> and <i>culture</i> parameters), you can use the abstract  <a href="../../System.Reflection/types/Binder.html">Binder</a> class to write a custom binder that does process <i>modifiers</i> and <i>culture</i>.<b>ParameterModifier</b> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</p>
<p> The <i>args</i> array and the <i>modifiers</i> array have the same length. A parameter specified in the <i>args</i> array can have the following attributes, which are specified in the <i>modifiers</i> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.</p>
<p> Each parameter in the <i>namedParameters</i> array gets the value in the corresponding element in the <i>args</i> array. If the length of <i>args</i> is greater than the length of <i>namedParameters</i>, the remaining argument values are passed in order.</p>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which members to include in the search: </p>
<UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public members in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public members (that is, private and protected members) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static members up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.IgnoreCase</b> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <b>IgnoreCase</b> flag.</li>
<li><b>BindingFlags.DeclaredOnly</b> to search only the members declared on the  <a href="../../System/types/Type.html">Type</a>, not members that were simply inherited.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> invocation flags can be used to denote what action to take with the member: </p>
<UL>
<li><b>CreateInstance</b> to invoke a constructor.<i>name</i> is ignored. Not valid with other invocation flags.</li>
<li><b>InvokeMethod</b> to invoke a method, but not a constructor or a type initializer. Not valid with <b>SetField</b> or <b>SetProperty</b>.</li>
<li><b>GetField</b> to get the value of a field. Not valid with <b>SetField</b>.</li>
<li><b>SetField</b> to set the value of a field. Not valid with <b>GetField</b>.</li>
<li><b>GetProperty</b> to get a property. Not valid with <b>SetProperty</b>.</li>
<li><b>SetProperty</b> to set a property. Not valid with <b>GetProperty</b>.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> A method will be invoked if the following conditions are true: </p>
<UL>
<li> The number of parameters in the method declaration equals the number of arguments in the <i>args</i> array (unless default arguments are defined on the member).</li>
<li> The type of each argument can be converted by the binder to the type of the parameter.</li>
</UL> The binder will find all of the matching methods. These methods are found based upon the type of binding requested ( <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> values <b>InvokeMethod</b>, <b>GetProperty</b>, and so on). The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.<p> After the method is selected, it is invoked. Accessibility is checked at that point. The search may control which set of methods are searched based upon the accessibility attribute associated with the method. The  <a href="../../System.Reflection/types/Binder.html#BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)">Binder.BindToMethod</a> method of the  <a href="../../System.Reflection/types/Binder.html">Binder</a> class is responsible for selecting the method to be invoked. The default binder selects the most specific match.</p>
<p><b>InvokeMember</b> can be used to invoke methods with parameters that have default values. To bind to these methods, Reflection requires one of the binding flags <b>DefaultValueBinding</b>, <b>DefaultValueChangeType</b>, or <b>DefaultValueFull</b> to be specified explicitly. This is a requirement even in those cases where a value is passed for a parameter that has a default value.</p>
<p> For example, consider a method such as MyMethod(int x, float y = 2.0). To invoke this method with only the first argument as MyMethod(4), pass one of the above binding flags and pass two arguments, namely, 4 for the first argument and  <a href="../../System.Reflection/types/Missing.html#Value">Missing.Value</a> for the second argument. Unless you use <b>Missing.Value</b>, you may not omit optional parameters with the <b>Invoke</b> method. If you must do so, use <b>InvokeMember</b> instead.</p>
<p> Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through  <a href="../../System.Reflection/System.Reflection.html">System.Reflection</a> whenever the code is fully trusted.</p>
<p> You can use Type.InvokeMember to set a field to a particular value by specifying BindingFlags.SetField. For example, if you want to set a public instance field named F on class C, and F is a <b>String</b> you can say: </p><code>
              typeof(C).InvokeMember( "F",
              BindingFlags.SetField, null, C, new Object{ "strings new value"}, null, null,
              null );
            </code><p> Now suppose that F is a <b>String[]</b> you can say: </p><code>
              typeof(C).InvokeMember( "F",
              BindingFlags.SetField, null, C, new Object{new String[]{"a","z","c","d"}, null,
              null, null );
            </code><p> which will initialize the field F to this new array. Furthermore you can use Type.InvokeMember to set a position in an array by supplying to the index of the value and then the next value by doing the following: </p><code>
              typeof(C).InvokeMember( "F",
              BindingFlags.SetField, null, C, new Object{1, "b"}, null, null, null );
            </code><p> This will change string "z" in the array that F holds to string "b".</p>
</dd>
</dl><b>Example</b><dl>
<dd> Here are syntax examples using <b>InvokeMember</b> to invoke, get, and set various members.<pre>
using System;
using System.IO;
using System.Reflection;

public class Sample
{
 public void Method()
 {

//Call a static method
 Type t = typeof (TestClass);
 t.InvokeMember ("SayHello", BindingFlags.Public | BindingFlags.InvokeMethod | BindingFlags.Static, null, null, new object [] {});
         
 //Call an instance method
 TestClass c = new TestClass ();
 c.GetType().InvokeMember ("AddUp", BindingFlags.Public | BindingFlags.InvokeMethod, null, c, new object [] {});
 c.GetType().InvokeMember ("AddUp", BindingFlags.Public | BindingFlags.InvokeMethod, null, c, new object [] {});
         
 //Call a method with arguments
 object [] args = new object [] {100.09, 184.45};
 object result;
 result = t.InvokeMember ("ComputeSum", BindingFlags.Public | BindingFlags.InvokeMethod | BindingFlags.Static, null, null, args);
 Console.WriteLine ("{0} + {1} = {2}", args[0], args[1], result);
         
 //Get a field value
 result = t.InvokeMember ("Name", BindingFlags.Public | BindingFlags.GetField, null, c, new object [] {});
 Console.WriteLine ("Name == {0}", result);
         
 //Set a field
 t.InvokeMember ("Name", BindingFlags.Public |BindingFlags.SetField, null, c, new object [] {"NewName"});
 result = t.InvokeMember ("Name", BindingFlags.Public |BindingFlags.GetField, null, c, new object [] {});
 Console.WriteLine ("Name == {0}", result);
         
 //Get an indexed property value
 int  index = 3;
 result = t.InvokeMember ("Item", BindingFlags.Public |BindingFlags.GetProperty , null, c, new object [] {index});
 Console.WriteLine ("Item[{0}] == {1}", index, result);
         
 //Set an indexed property value
 index = 3;
 t.InvokeMember ("Item", BindingFlags.Public |BindingFlags.SetProperty, null, c, new object [] {index, "NewValue"});
 result = t.InvokeMember ("Item", BindingFlags.Public |BindingFlags.GetProperty , null, c, new object [] {index});
 Console.WriteLine ("Item[{0}] == {1}", index, result);
         
 //Get a field or property
 result = t.InvokeMember ("Name", BindingFlags.Public |BindingFlags.GetField | BindingFlags.GetProperty, null, c, new object [] {});
 Console.WriteLine ("Name == {0}", result);
 result = t.InvokeMember ("Value", BindingFlags.Public |BindingFlags.GetField | BindingFlags.GetProperty, null, c, new object [] {});
 Console.WriteLine ("Value == {0}", result);
         
 //Call a method using named arguments
 object[] argValues = new object [] {"Mouse", "Micky"};
 String [] argNames = new String [] {"lastName", "firstName"};
 t.InvokeMember ("PrintName", BindingFlags.Public |BindingFlags.InvokeMethod, null, null, argValues, null, null, argNames);
         
 //Call the default member of a type
 Type t3 = typeof (TestClass2);
 t3.InvokeMember ("", BindingFlags.Public |BindingFlags.InvokeMethod, null, new TestClass2(), new object [] {});
         
 //Invoking a ByRef member
 MethodInfo m = t.GetMethod("Swap");
 args = new object[2];
 args[0] = 1;
 args[1] = 2;
 m.Invoke(new TestClass(),args);
 Console.WriteLine ("{0}, {1}", args[0], args[1]);
 Console.WriteLine ("\r\nPress Return to exit.");
 Console.Read();

 }
}

// Class added so sample will compile
public class TestClass {}

// Class added so sample will compile
public class TestClass2 {}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting members that are not public. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#MemberAccess">ReflectionPermissionFlag.MemberAccess</a></dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/SecurityPermission.html">SecurityPermission</a> to call unmanaged code. Associated enumeration:  <a href="../../System.Security.Permissions/types/SecurityPermissionFlag.html#UnmanagedCode">SecurityPermissionFlag.UnmanagedCode</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/Binder.html">Binder</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Reflection/types/ParameterAttributes.html">ParameterAttributes</a> |  <a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="IsArrayImplTopic1"></a><a name="IsArrayImpl">IsArrayImpl</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, implements the  <a href="#IsArray">Type.IsArray</a> property and determines whether the  <a href="../../System/types/Type.html">Type</a> is an array.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected abstract <a href="../../System/types/Boolean.html">bool</a> IsArrayImpl();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the  <a href="../../System/types/Type.html">Type</a> is an array; otherwise, <b>false</b>.</dd>
</dl><b>Remarks</b><dl>
<dd> An instance of the  <a href="../../System/types/Array.html">Array</a> class must return <b>false</b> because it is an object, not an array.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
public class MyTypeDelegator : TypeDelegator
{
   public string myElementType = null;
   public Type myType;
   
   public MyTypeDelegator(Type myType) : base(myType)
   {
      this.myType = myType;
   }
   // Overrides 'IsArrayImpl()' method of 'Type' class.
   protected override bool IsArrayImpl()
   {
      // Check whether type is an array.
      if(myType.IsArray)
      {
         myElementType = "array";
         return true;
      }
      // Type is not an array.
      return false;  
   }
}
public class Type_IsArrayImpl
{
   public static void Main()
   {
      try
      {
         int myInt = 0 ; 
         
         // An array element.
         int[] myArray = new int[5];

         MyTypeDelegator myType = new MyTypeDelegator(myArray.GetType());
         
         Console.WriteLine("\nCheck if the variable is an array\n");

         // Check if 'myType' is an array type.  
         if( myType.IsArray)
            Console.WriteLine(" 'myArray' is an {0} ", myType.myElementType);
         else
            Console.WriteLine(" 'myArray' is not an array ");

         myType = new MyTypeDelegator(myInt.GetType());

         // Check if 'myType' is an array type. 
         if( myType.IsArray)
            Console.WriteLine(" 'myInt' is an ", myType.myElementType);
         else
            Console.WriteLine(" 'myInt' is not an array");
      }
      catch( Exception e )
      {
         Console.WriteLine("Exception : {0}", e.Message );
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#IsArray">Type.IsArray</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="IsAssignableFromTopic1"></a><a name="IsAssignableFrom(System.Type)">IsAssignableFrom</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>c</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Determines whether an instance of the current  <a href="../../System/types/Type.html">Type</a> can be assigned from an instance of the specified <b>Type</b>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/Boolean.html">bool</a> IsAssignableFrom(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>c</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>c</i><br><dl>
<dd>
<param> The <b>Type</b> to compare with the current <b>Type</b>.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the <i>c</i> parameter and the current <b>Type</b> represent the same type, or if the current <b>Type</b> is in the inheritance hierarchy of <i>c</i>, or if the current <b>Type</b> is an interface that <i>c</i> supports.<b>false</b> if none of these conditions are the case, or if <i>c</i> is <b>null</b>.</dd>
</dl><b>Remarks</b><dl>
<dd> This method can be overridden by a derived class.<p> Determine the element types of a <b>Type</b> using  <a href="#GetElementType">Type.GetElementType</a>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following example demonstrates the <b>IsAssignable</b> method using arrays.<pre>
using System;
class ArrayTypeTest 
{
   public static void Main() 
   {
   int i = 1;
   int [] array10  = new int [10];
   int [] array2   = new int[2];
   int [,]array22  = new int[2,2];
   int [,]array24  = new int[2,4];
   int [,,]array333 = new int[3,3,3];
   Type array10Type = array10.GetType();
   Type array2Type  = array2.GetType();
   Type array22Type = array22.GetType();
   Type array24Type = array24.GetType();
   Type array333Type = array333.GetType();

   // If X and Y are not both arrays, then return false.
   Console.WriteLine("int[2]  is assignable from int? {0} ", array2Type.IsAssignableFrom(i.GetType()));
   // If X and Y have same type and rank, then return true.
   Console.WriteLine("int[2]  is assignable from int[10]? {0} ", array2Type.IsAssignableFrom(array10Type));
   Console.WriteLine("int[2,2] is assignable from int[2,4]? {0}", array22Type.IsAssignableFrom(array24Type));
   Console.WriteLine("int[2,4] is assignable from int[2,2]? {0}", array24Type.IsAssignableFrom(array22Type));
   Console.WriteLine("");
   // If X and Y do not have the same rank, then return false.
   Console.WriteLine("int[2,2] is assignable from int[10]? {0}", array22Type.IsAssignableFrom(array10Type));
   Console.WriteLine("int[2,2]   is assignable from int[3,3,3]? {0}", array22Type.IsAssignableFrom(array333Type));
   Console.WriteLine("int[3,3,3] is assignable from int[2,2]? {0}", array333Type.IsAssignableFrom(array22Type));
   }
}

    </pre>
<p> This code produces the following output: </p>
<pre>
              				int[2] is assignable from int? False
              				int[2] is assignable from int[10]? True
              				int[2,2] is assignable from int[2,4]? True
              				int[2,4] is assignable from int[2,2]? True
              				int[2,2] is assignable from int[10]? False
              				int[2,2] is assignable from int[3,3,3]? False
              				int[3,3,3] is assignable from int[2,2]? False
              			
            </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="IsByRefImplTopic1"></a><a name="IsByRefImpl">IsByRefImpl</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, implements the  <a href="#IsByRef">Type.IsByRef</a> property and determines whether the  <a href="../../System/types/Type.html">Type</a> is passed by reference.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected abstract <a href="../../System/types/Boolean.html">bool</a> IsByRefImpl();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the  <a href="../../System/types/Type.html">Type</a> is passed by reference; otherwise, <b>false</b>.</dd>
</dl><b>Remarks</b><dl>
<dd></dd>
</dl><b>See also: 
			</b><br> <a href="#IsByRef">Type.IsByRef</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="IsCOMObjectImplTopic1"></a><a name="IsCOMObjectImpl">IsCOMObjectImpl</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, implements the  <a href="#IsCOMObject">Type.IsCOMObject</a> property and determines whether the  <a href="../../System/types/Type.html">Type</a> is a COM object.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected abstract <a href="../../System/types/Boolean.html">bool</a> IsCOMObjectImpl();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the  <a href="../../System/types/Type.html">Type</a> is a COM object; otherwise, <b>false</b>.</dd>
</dl><b>Remarks</b><dl>
<dd>
<p> This method returns <b>false</b> for COM interfaces because they are not objects. COM interfaces can be implemented by Microsoft .NET Framework objects.</p>
</dd>
</dl><b>See also: 
			</b><br> <a href="#IsCOMObject">Type.IsCOMObject</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="IsContextfulImplTopic1"></a><a name="IsContextfulImpl">IsContextfulImpl</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Implements the  <a href="#IsContextful">Type.IsContextful</a> property and determines whether the  <a href="../../System/types/Type.html">Type</a> can be hosted in a context.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected virtual <a href="../../System/types/Boolean.html">bool</a> IsContextfulImpl();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the  <a href="../../System/types/Type.html">Type</a> can be hosted in a context; otherwise, <b>false</b>.</dd>
</dl><b>Remarks</b><dl>
<dd> This method can be overridden by a derived class.<p> A context intercepts calls to the class members and enforce policies that are applied to the class, such as synchronization.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
public class MyTypeDelegatorClass : TypeDelegator
{
   public string myElementType = null;
   private Type myType = null ; 

   public MyTypeDelegatorClass(Type myType) : base(myType)
   {
      this.myType = myType;
   }

   // Override 'IsContextfulImpl' method of 'Type' class.
   protected override bool IsContextfulImpl()
   {
      // Check whether the type is contextful.
      if(myType.IsContextful)
      { 
         myElementType = " is contextful ";
         return true;
      }
      return false;
   }
}

public class MyTypeDemoClass
{
   public static void Main()
   {
      try
      {
         MyTypeDelegatorClass myType;
         Console.WriteLine ("Check whether 'MyContextBoundClass' can be hosted in a context.");
         // Check if 'MyContextBoundClass' type is contextful.
         myType = new MyTypeDelegatorClass(typeof(MyContextBoundClass));
         if( myType.IsContextful)
         {
            Console.WriteLine(typeof(MyContextBoundClass) + " can be hosted in a context.");
         }
         else
         {
            Console.WriteLine(typeof(MyContextBoundClass) + " cannot be hosted in a context.");
         }

         // Check if 'int' type is contextful.
         myType = new MyTypeDelegatorClass(typeof(MyTypeDemoClass));
         Console.WriteLine ("\nCheck whether 'MyTypeDemoClass' can be hosted in a context.");
         if( myType.IsContextful)
         {
            Console.WriteLine(typeof(MyTypeDemoClass) + " can be hosted in a context.");
         }
         else
         {
            Console.WriteLine(typeof(MyTypeDemoClass) + " cannot be hosted in a context.");
         }
      }
      catch( Exception e )
      {
         Console.WriteLine("Exception: {0}", e.Message);
      }
   }
}

// This class is used to demonstrate 'IsContextfulImpl' method.
public class MyContextBoundClass : ContextBoundObject
{
   public string myString = "This class is used to demonstrate members of the 'Type' class.";
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#IsContextful">Type.IsContextful</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="IsDefinedTopic1"></a><a name="IsDefined(System.Type,System.Boolean)">IsDefined</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>attributeType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>inherit</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System.Reflection/types/MemberInfo.html#IsDefined(System.Type,System.Boolean)">System.Reflection.MemberInfo.IsDefined</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, indicates whether one or more instance of <i>attributeType</i> is defined on this member.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public abstract <a href="../../System/types/Boolean.html">bool</a> IsDefined(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>attributeType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>inherit</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>attributeType</i><br><dl>
<dd>
<param> The <b>Type</b> object to which the custom attributes are applied.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>inherit</i><br><dl>
<dd>
<param> Specifies whether to search this member's inheritance chain to find the attributes.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if one or more instance of <i>attributeType</i> is defined on this member; otherwise <b>false</b>.</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/ICustomAttributeProvider.html#IsDefined(System.Type,System.Boolean)">ICustomAttributeProvider.IsDefined</a></dd>
</dl><b>Example</b><dl>
<dd>
<pre>

using System;
using System.Reflection;

// Define a custom attribute with one named parameter.
[AttributeUsage(AttributeTargets.All)]
public class MyAttribute : Attribute
{
   private string myName;
   public MyAttribute(string name)
   {
      myName = name;
   }
   public string Name
   {
      get
      {
         return myName;
      }
   }
}

// Define a class which has the custom attribute associated with one of its members.
public class MyClass1
{
   [MyAttribute("This is an example attribute")]
   public void MyMethod(int i)
   {
      return;
   }
}

public class MemberInfo_GetCustomAttributes_IsDefined
{
   public static void Main()
   {
      try
      {
         // Get the type of the class 'MyClass1'.
         Type myType = typeof(MyClass1);
         // Get the members associated with the class 'MyClass1'.
         MemberInfo[] myMembers = myType.GetMembers();

         // Display the attributes for each of the members of the class 'MyClass1'.
         for(int i = 0; i &lt; myMembers.Length; i++)
         {
            // Display the attribute if it is of type 'MyAttribute'.
            if(myMembers[i].IsDefined(typeof(MyAttribute), false))
            {
               Object[] myAttributes = myMembers[i].GetCustomAttributes(typeof(MyAttribute), false);
               Console.WriteLine("\nThe attributes of type 'MyAttribute' for the member {0} are : \n",
                                    myMembers[i]);
               for(int j = 0; j &lt; myAttributes.Length; j++)
                  // Display the value associated with the attribute.
                  Console.WriteLine("The value of the attribute is : \"{0}\"",
                                       ((MyAttribute)myAttributes[j]).Name);
            }
         }
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception Caught! "+e.Message);
      }
   }
}

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="IsInstanceOfTypeTopic1"></a><a name="IsInstanceOfType(System.Object)">IsInstanceOfType</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>o</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Determines whether the specified object is an instance of the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/Boolean.html">bool</a> IsInstanceOfType(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>o</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>o</i><br><dl>
<dd>
<param> The object to compare with the current <b>Type</b>.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the current <b>Type</b> is in the inheritance hierarchy of the object represented by the <i>o</i> parameter, or if the current Type is an interface that <i>o</i> supports.<b>false</b> if neither of these conditions is the case, or if <i>o</i> is <b>null</b>.</dd>
</dl><b>Remarks</b><dl>
<dd> This method can be overridden by a derived class.</dd>
</dl><b>Example</b><dl>
<dd> The following example demonstrates the use of the <b>IsInstanceOfType</b> method.<pre>
using System;
public interface IMyIfc {}
public class MyClass : IMyIfc {}
public class MyDerivedClass : MyClass {}
class IsInstanceTest 
{
   public static void Main() 
   {
   Type imyifcType=typeof(IMyIfc);
   MyClass mc = new MyClass();
   Type mcType = mc.GetType();
   MyClass mdc = new MyDerivedClass();
   Type mdcType = mdc.GetType();
   int [] array  = new int [10];
   Type arrayType = typeof(Array);
   Console.WriteLine("int[] is instance of Array? {0}", arrayType.IsInstanceOfType(array));
   Console.WriteLine("myclass instance is instance of MyClass? {0}", mcType.IsInstanceOfType(mc));
   Console.WriteLine("myderivedclass instance is instance of MyClass? {0}", mcType.IsInstanceOfType(mdc));
   Console.WriteLine("myclass instance is instance of IMyIfc? {0}", imyifcType.IsInstanceOfType(mc));
   Console.WriteLine("myderivedclass instance is instance of IMyIfc? {0}", imyifcType.IsInstanceOfType(mdc));
   }
}

    </pre>
<p> This code produces the following output: </p>
<pre>
              				int[] is instance of Array? True 
              				myclass instance is instance of MyClass? True 
              				myderivedclass instance is instance of MyClass? True 
              				myclass instance is instance of IMyIfc? True 
              				myderivedclass instance is instance of IMyIfc? True
              			
            </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="IsMarshalByRefImplTopic1"></a><a name="IsMarshalByRefImpl">IsMarshalByRefImpl</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Implements the  <a href="#IsMarshalByRef">Type.IsMarshalByRef</a> property and determines whether the  <a href="../../System/types/Type.html">Type</a> is marshalled by reference.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected virtual <a href="../../System/types/Boolean.html">bool</a> IsMarshalByRefImpl();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the  <a href="../../System/types/Type.html">Type</a> is marshalled by reference; otherwise, <b>false</b>.</dd>
</dl><b>Remarks</b><dl>
<dd> This method can be overridden by a derived class.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
public class MyTypeDelegatorClass : TypeDelegator
{
   public string myElementType = null;
   private Type myType = null ; 

   public MyTypeDelegatorClass(Type myType) : base(myType)
   {
      this.myType = myType;
   }

   // Override 'IsMarshalByRefImpl' method of 'Type' class.
   protected override bool IsMarshalByRefImpl()
   {
      // Check whether the type is marshalled by reference.
      if(myType.IsMarshalByRef)
      { 
         myElementType = " marshalled by reference";
         return true;
      }
      return false;
   }
}

public class MyTypeDemoClass
{
   public static void Main()
   {
      try
      {
         MyTypeDelegatorClass myType;
         Console.WriteLine ("Check whether 'MyContextBoundClass' is marshalled by reference");
         // Check if 'MyContextBoundClass' type is marshalled by reference.
         myType = new MyTypeDelegatorClass(typeof(MyContextBoundClass));
         if( myType.IsMarshalByRef )
         {
            Console.WriteLine(typeof(MyContextBoundClass) + " is marshalled by reference.");
         }
         else
         {
            Console.WriteLine(typeof(MyContextBoundClass) + " is not marshalled by reference.");
         }

         // Check if 'int' type is marshalled by reference.
         myType = new MyTypeDelegatorClass(typeof(int));
         Console.WriteLine ("\nCheck whether 'int' is marshalled by reference");
         if( myType.IsMarshalByRef)
         {
            Console.WriteLine(typeof(int) + " is marshalled by reference.");
         }
         else
         {
            Console.WriteLine(typeof(int) + " is not marshalled by reference.");
         }
      }
      catch( Exception e )
      {
         Console.WriteLine("Exception: {0}", e.Message);
      }
   }
}
// This class is used to demonstrate 'IsMarshalByRefImpl' method.
public class MyContextBoundClass : ContextBoundObject
{
   public string myString = "This class is used demonstrate members of the 'Type' class.";
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#IsMarshalByRef">Type.IsMarshalByRef</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="IsPointerImplTopic1"></a><a name="IsPointerImpl">IsPointerImpl</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, implements the  <a href="#IsPointer">Type.IsPointer</a> property and determines whether the  <a href="../../System/types/Type.html">Type</a> is a pointer.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected abstract <a href="../../System/types/Boolean.html">bool</a> IsPointerImpl();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the  <a href="../../System/types/Type.html">Type</a> is a pointer; otherwise, <b>false</b>.</dd>
</dl><b>Remarks</b><dl>
<dd></dd>
</dl><b>See also: 
			</b><br> <a href="#IsPointer">Type.IsPointer</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="IsPrimitiveImplTopic1"></a><a name="IsPrimitiveImpl">IsPrimitiveImpl</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> When overridden in a derived class, implements the  <a href="#IsPrimitive">Type.IsPrimitive</a> property and determines whether the  <a href="../../System/types/Type.html">Type</a> is one of the primitive types.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected abstract <a href="../../System/types/Boolean.html">bool</a> IsPrimitiveImpl();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the  <a href="../../System/types/Type.html">Type</a> is one of the primitive types; otherwise, <b>false</b>.</dd>
</dl><b>Remarks</b><dl>
<dd> The primitive types are  <a href="../../System/types/Boolean.html">Boolean</a>,  <a href="../../System/types/Byte.html">Byte</a>,  <a href="../../System/types/SByte.html">SByte</a>,  <a href="../../System/types/Int16.html">Int16</a>,  <a href="../../System/types/UInt16.html">UInt16</a>,  <a href="../../System/types/Int32.html">Int32</a>,  <a href="../../System/types/UInt32.html">UInt32</a>,  <a href="../../System/types/Int64.html">Int64</a>,  <a href="../../System/types/UInt64.html">UInt64</a>,  <a href="../../System/types/Char.html">Char</a>,  <a href="../../System/types/Double.html">Double</a>, and  <a href="../../System/types/Single.html">Single</a>.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
public class MyTypeDelegatorClass : TypeDelegator
{
   public string myElementType = null;
   private Type myType = null ; 

   public MyTypeDelegatorClass(Type myType) : base(myType)
   {
      this.myType = myType;
   }

   // Override 'IsPrimitiveImpl' method of 'Type' class.
   protected override bool IsPrimitiveImpl()
   {
      // Check whether the type is a primitive type.
      if(myType.IsPrimitive)
      { 
         myElementType = "primitive";
         return true;
      }
      return false;
   }
}

public class MyTypeDemoClass
{
   public static void Main()
   {
      try
      {
         Console.WriteLine ("Check whether 'int' is a primitive type");
         MyTypeDelegatorClass myType;
         myType = new MyTypeDelegatorClass(typeof(int));
         // Check if 'int' type is a primitive type.
         if( myType.IsPrimitive)
         {
            Console.WriteLine(typeof(int) + " is a primitive type.");
         }
         else
         {
            Console.WriteLine(typeof(int) + " is not a primitive type.");
         }

         Console.WriteLine ("\nCheck whether 'string' is a primitive type");
         myType = new MyTypeDelegatorClass(typeof(string));
         // Check if 'string' type is a primitive type.
         if( myType.IsPrimitive)
         {
            Console.WriteLine(typeof(string) + " is a primitive type.");
         }
         else
         {
            Console.WriteLine(typeof(string) + " is not a primitive type.");
         }
      }
      catch( Exception e )
      {
         Console.WriteLine("Exception: {0}", e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/Boolean.html">Boolean</a> |  <a href="../../System/types/Byte.html">Byte</a> |  <a href="../../System/types/SByte.html">SByte</a> |  <a href="../../System/types/Int16.html">Int16</a> |  <a href="../../System/types/UInt16.html">UInt16</a> |  <a href="../../System/types/Int32.html">Int32</a> |  <a href="../../System/types/UInt32.html">UInt32</a> |  <a href="../../System/types/Int64.html">Int64</a> |  <a href="../../System/types/UInt64.html">UInt64</a> |  <a href="../../System/types/Char.html">Char</a> |  <a href="../../System/types/Double.html">Double</a> |  <a href="../../System/types/Single.html">Single</a> |  <a href="#IsPrimitive">Type.IsPrimitive</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="IsSubclassOfTopic1"></a><a name="IsSubclassOf(System.Type)">IsSubclassOf</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>c</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Determines whether the current  <a href="../../System/types/Type.html">Type</a> derives from the specified <b>Type</b>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/Boolean.html">bool</a> IsSubclassOf(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>c</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>c</i><br><dl>
<dd>
<param> The <b>Type</b> to compare with the current <b>Type</b>.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the <b>Type</b> represented by the <i>c</i> parameter and the current <b>Type</b> represent classes, and the class represented by the current <b>Type</b> derives from the class represented by <i>c</i>; otherwise, <b>false</b>. This method also returns <b>false</b> if <i>c</i> and the current <b>Type</b> represent the same class.</dd>
</dl><b>Remarks</b><dl>
<dd> This method can be overridden by a derived class.</dd>
</dl><b>Example</b><dl>
<dd> The following example demonstrates the use of the <b>IsSubclassOf</b> method.<pre>
using System;
public interface IMyIfc {}
public interface IDerived : IMyIfc {}
public class Class1 : IMyIfc {}
public class MyDerivedClass : Class1 {}
class IsSubclassTest 
{
   public static void Main() 
   {
   Type imyifcType = typeof(IMyIfc);
   Type imyderivedType = typeof(IDerived);
   Class1 mc = new Class1();
   Type mcType = mc.GetType();
   Class1 mdc = new MyDerivedClass();
   Type mdcType = mdc.GetType();
   int [] array  = new int [10];
   Type arrayOfIntsType = array.GetType();
   Type arrayType = typeof(Array);
	
   Console.WriteLine("Array is derived class of int[]? {0}", arrayType.IsSubclassOf(arrayOfIntsType));
   Console.WriteLine("int [] is derived class of Array? {0}", arrayOfIntsType.IsSubclassOf(arrayType));
   Console.WriteLine("IMyIfc is derived class of IDerived? {0}", imyifcType.IsSubclassOf(imyderivedType));
   Console.WriteLine("myclass is derived class of Class1? {0}", mcType.IsSubclassOf(mcType));
   Console.WriteLine("myderivedclass is derived class of Class1? {0}", mdcType.IsSubclassOf(mcType));
   }
}

    </pre>
<p> This code produces the following output: </p>
<pre>
              				Array is derived class of int[]? False 
              				int [] is derived class of Array? True 
              				IMyIfc is derived class of IDerived? False 
              				myclass is derived class of Class1? False 
              				myderivedclass is derived class of Class1? True
              			
            </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#BaseType">Type.BaseType</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="IsValueTypeImplTopic1"></a><a name="IsValueTypeImpl">IsValueTypeImpl</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Implements the  <a href="#IsValueType">Type.IsValueType</a> property and determines whether the  <a href="../../System/types/Type.html">Type</a> is a value type; that is, not a class or an interface.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected virtual <a href="../../System/types/Boolean.html">bool</a> IsValueTypeImpl();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the  <a href="../../System/types/Type.html">Type</a> is a value type; otherwise, <b>false</b>.</dd>
</dl><b>Remarks</b><dl>
<dd> Value types describe values that are represented as sequences of bits; value types are not classes or interfaces. These are referred to as "structs" in some programming languages. Enums are value types.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
public class MyTypeDelegator : TypeDelegator
{
   public string myElementType = null;
   private Type myType = null ; 

   public MyTypeDelegator(Type myType) : base(myType)
   {
      this.myType = myType;
   }

   // Override 'IsValueTypeImpl()' method of 'Type' class.
   protected override bool IsValueTypeImpl()
   {
      // Check whether the type is an value type.
      if(myType.IsValueType)
      {
         myElementType = "value";
         return true;
      }
      // The type is not value type.
      return false;
   }  
}
public class Type_IsValueTypeImpl 
{
   public class MyClass
   {
   }
   public static void Main()
   {
      try
      {
         int myInt = 0 ; 
         MyClass myClass = new MyClass ();

         MyTypeDelegator myType = new MyTypeDelegator(myInt.GetType());
         Console.WriteLine("\nCheck whether a variable refers to a value type.\n");
         
         // Check if 'myType' is a value type.  
         if( myType.IsValueType)
            Console.WriteLine("\n'myInt' is a {0} type.", myType.myElementType);
         else
            Console.WriteLine("\n'myInt' is not a value type.");

         myType = new MyTypeDelegator(myClass.GetType());

         // Check if 'myType' is a value type.  
         if( myType.IsValueType)
            Console.WriteLine("\n'myClass' is a {0} type.", myType.myElementType);
         else
            Console.WriteLine("\n'myClass' is not a value type.");

      }
      catch( Exception e )
      {
            Console.WriteLine("\nThe following exception is raised:" +e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsClass">Type.IsClass</a> |  <a href="#IsInterface">Type.IsInterface</a> |  <a href="../../System/types/ValueType.html">ValueType</a> |  <a href="#IsValueType">Type.IsValueType</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="MemberwiseCloneTopic1"></a><a name="MemberwiseClone">MemberwiseClone</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#MemberwiseClone">System.Object.MemberwiseClone</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected <a href="../../System/types/Object.html">object</a> MemberwiseClone();</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="ToStringTopic1"></a><a name="ToString">ToString</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns a <b>String</b> representing the name of the current <b>Type</b>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/String.html">string</a> ToString();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System/types/String.html">String</a> representing the name of the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl><b>Remarks</b><dl>
<dd> This method returns the fully qualified common language runtime namespace and name for all primitive types. For example, the C# instruction, <code>
                (long)0.Type().ToString()
              </code> returns "System.Int64" instead of merely "Int64".</dd>
</dl><b>Example</b><dl>
<dd>
<pre>

namespace MyNamespace
{
   class MyClass
   {
   }
}
public class Type_ToString_3
{
   public static void Main()
   {
      
      try
      {
         Type myType = typeof(MyNamespace.MyClass);
         
         Console.WriteLine("\nPrinting the details of '{0}'\n", myType); 
         // Get the namespace of the class 'Type_ToString_3'.
         Console.WriteLine("Namespace : {0}", myType.Namespace);
         
         // Get the name of the module.
         Console.WriteLine("Module    : {0} ",myType.Module);
         
         // Get fully qualified common language runtime namespace.
         Console.WriteLine("Fully Qualified type : {0}", myType.ToString());
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception : " + e.Message ); 
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/String.html">String</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite">
<h3 align="center"><a href="#TopOfPage">
					Top of page
				</a></h3><i><a href="../../documentation_license.txt">
				  Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
				</a></i></body>
</html>
