<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../refdoc.css">
<title>Type: System.Object</title>
</head>
<body><a name="TopOfPage"></a><h2>System.Object Class</h2><b>Assembly: </b>Mscorlib.dll<br><b>Namespace: </b>System<br><dl>
<dt><b>Summary</b></dt>
<dd> Supports all classes in the .NET Framework class hierarchy and provides low-level services to derived classes. This is the ultimate superclass of all classes in the .NET Framework; it is the root of the type hierarchy.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code>[Serializable]<br><b>public class Object</b></code></td>
</tr>
</table>
</dd>
</dl><b>Thread Safety</b><br><dl>
<dd> Public static (non-instance) members of this type are safe for multithreaded operations. Instance members are not guaranteed to be thread-safe.</dd>
</dl><b>Remarks</b><dl>
<dd> Languages typically do not require a class to declare inheritance from  <a href="../../System/types/Object.html">Object</a> because the inheritance is implicit.<p> Because all classes in the .NET Framework are derived from  <a href="../../System/types/Object.html">Object</a>, every method defined in the  <a href="../../System/types/Object.html">Object</a> class is available in all objects in the system. Derived classes can and do override some of these methods, including: </p>
<UL>
<li> <a href="#Equals(System.Object)">Object.Equals</a> - Supports comparisons between objects.</li>
<li> <a href="#Finalize">Object.Finalize</a> - Performs cleanup operations before an object is automatically reclaimed.</li>
<li> <a href="#GetHashCode">Object.GetHashCode</a> - Generates a number corresponding to the value of the object to support the use of a hash table.</li>
<li> <a href="#ToString">Object.ToString</a> - Manufactures a human-readable text string that describes an instance of the class.</li>
</UL>
</dd>
</dl><b>See also: </b><dl>
<dd> <a href="../../System/System.html">System Namespace</a></dd>
</dl>
<h3>System.Object Member List: </h3>
<dl>
<dt><b>Public Constructors</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#ctor1">ctor #1</a></td>
<td width="55%">Default constructor. This constructor is called by derived class constructors to initialize state in this type.<br> Initializes a new instance of the  <a href="../../System/types/Object.html">Object</a> class.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Public Methods</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#Equals(System.Object)">Equals</a></td>
<td width="55%"><b>Overloaded:</b><br><code>Equals(object obj)<br><br></code> Determines whether the specified  <a href="../../System/types/Object.html">Object</a> is equal to the current  <a href="../../System/types/Object.html">Object</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Equals(System.Object,System.Object)">Equals</a></td>
<td width="55%"><b>Overloaded:</b><br><code>Equals(object objA, object objB)<br><br></code> Determines whether the specified  <a href="../../System/types/Object.html">Object</a> instances are considered equal.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetHashCode">GetHashCode</a></td>
<td width="55%"> Serves as a hash function for a particular type, suitable for use in hashing algorithms and data structures like a hash table.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetType">GetType</a></td>
<td width="55%"> Gets the  <a href="../../System/types/Type.html">Type</a> of the current instance.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ReferenceEquals(System.Object,System.Object)">ReferenceEquals</a></td>
<td width="55%"> Determines whether the specified  <a href="../../System/types/Object.html">Object</a> instances are the same instance.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ToString">ToString</a></td>
<td width="55%"> Returns a  <a href="../../System/types/String.html">String</a> that represents the current  <a href="../../System/types/Object.html">Object</a>.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Protected Methods</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#Finalize">Finalize</a></td>
<td width="55%"><b>Overridden: </b><br> Allows an  <a href="../../System/types/Object.html">Object</a> to attempt to free resources and perform other cleanup operations before the  <a href="../../System/types/Object.html">Object</a> is reclaimed by garbage collection.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#MemberwiseClone">MemberwiseClone</a></td>
<td width="55%"> Creates a shallow copy of the current  <a href="../../System/types/Object.html">Object</a>.</td>
</tr>
</table>
</dd>
</dl><b>Descendants:</b> All types
			<hr>
<h3>System.Object Member Details</h3><b><i><a name=".ctorTopic1"></a><a name="ctor1">ctor #1</a></i></b><b><i></i></b><dl>
<dt><b>Summary</b></dt>
<dd> Initializes a new instance of the  <a href="../../System/types/Object.html">Object</a> class.</dd>
</dl><br><dl>
<dd>Default constructor. This constructor is called by derived class constructors to initialize state in this type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public Object();</b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This constructor is called by constructors in derived classes, but it can also be used to directly create an instance of the  <a href="../../System/types/Object.html">Object</a> class.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="EqualsTopic1"></a><a name="Equals(System.Object)">Equals</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>obj</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Determines whether the specified  <a href="../../System/types/Object.html">Object</a> is equal to the current  <a href="../../System/types/Object.html">Object</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/Boolean.html">bool</a> Equals(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>obj</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>obj</i><br><dl>
<dd>
<param> The  <a href="../../System/types/Object.html">Object</a> to compare with the current  <a href="../../System/types/Object.html">Object</a>.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the specified  <a href="../../System/types/Object.html">Object</a> is equal to the current  <a href="../../System/types/Object.html">Object</a>; otherwise, <b>false</b>.</dd>
</dl><b>Remarks</b><dl>
<dd> The default implementation of  <a href="#Equals(System.Object)">Object.Equals</a> supports reference equality only, but derived classes can override this method to support value equality.<p> For reference types, equality is defined as object equality; that is, whether the references refer to the same object. For value types, equality is defined as bitwise equality. The  <a href="../../System/types/ValueType.html">ValueType</a> class supports value types.</p><br><br><b>Notes to implementors: </b><p> This method can be overridden by a derived class. For example, many of the base data types return <b>true</b> if both objects represent the same value; otherwise, <b>false</b>.</p>
<p> This method only compares primitives and objects. It must be overridden to compare more complex structures, such as arrays of objects.</p>
<p> The following statements must be true for all implementations of the  <a href="#Equals(System.Object)">Object.Equals</a> method. In the list, x, y, and z represent object references that are not <b>null</b>.</p>
<UL>
<li> x.Equals(x) returns <b>true</b>, except in cases that involve floating-point types. See IEC 60559:1989, Binary Floating-point Arithmetic for Microprocessor Systems.</li>
<li> x.Equals(y) returns the same value as y.Equals(x).</li>
<li> x.Equals(y) returns <b>true</b> if both x and y are <b>NaN</b>.</li>
<li> (x.Equals(y) &amp;&amp; y.Equals(z)) returns <b>true</b> if and only if x.Equals(z) returns <b>true</b>.</li>
<li> Successive calls to x.Equals(y) return the same value as long as the objects referenced by x and y are not modified.</li>
<li> x.Equals(<b>null</b>) returns <b>false</b>.</li>
</UL>
<p> See  <a href="#GetHashCode">Object.GetHashCode</a> for additional required behaviors pertaining to the  <a href="#Equals(System.Object)">Object.Equals</a> method.</p>
<p> Implementations of  <a href="#Equals(System.Object)">Object.Equals</a> must not throw exceptions.</p>
<p> For some kinds of objects, it is desirable to have  <a href="#Equals(System.Object)">Object.Equals</a> test for value equality instead of referential equality. Such implementations of  <a href="#Equals(System.Object)">Object.Equals</a> return <b>true</b> if the two objects have the same "value", even if they are not the same instance. The type's implementer decides what constitutes an object's "value", but it is typically some or all the data stored in the instance variables of the object. For example, the value of a  <a href="../../System/types/String.html">String</a> is based on the characters of the string; the  <a href="#Equals(System.Object)">Object.Equals</a> method of the  <a href="../../System/types/String.html">String</a> class returns <b>true</b> for any two string instances that contain exactly the same characters in the same order.</p>
<p> Types that implement  <a href="../../System/types/IComparable.html">IComparable</a> must override  <a href="#Equals(System.Object)">Object.Equals</a>.</p>
<p> Types that override  <a href="#Equals(System.Object)">Object.Equals</a> must also override  <a href="#GetHashCode">Object.GetHashCode</a>; otherwise,  <a href="../../System.Collections/types/Hashtable.html">Hashtable</a> might not work correctly.</p>
<p> If your programming language supports operator overloading and if you choose to overload the equality operator for a given type, that type should override the  <a href="#Equals(System.Object)">Object.Equals</a> method. Such implementations of the  <a href="#Equals(System.Object)">Object.Equals</a> method should return the same results as the equality operator. Following this guideline will help ensure that class library code using  <a href="#Equals(System.Object)">Object.Equals</a> (such as  <a href="../../System.Collections/types/ArrayList.html">ArrayList</a> and  <a href="../../System.Collections/types/Hashtable.html">Hashtable</a>) behaves in a manner that is consistent with the way the equality operator is used by application code.</p>
<p> The following guidelines are for implementing a value type: </p>
<UL>
<li> Consider overriding  <a href="#Equals(System.Object)">Object.Equals</a> to gain increased performance over that provided by the default implementation of  <a href="#Equals(System.Object)">Object.Equals</a> on  <a href="../../System/types/ValueType.html">ValueType</a>.</li>
<li> If you override  <a href="#Equals(System.Object)">Object.Equals</a> and the language supports operator overloading, you must overload the equality operator for your value type.</li>
</UL>
<p> The following guidelines are for implementing a reference type: </p>
<UL>
<li> Consider overriding  <a href="#Equals(System.Object)">Object.Equals</a> on a reference type if the semantics of the type are based on the fact that the type represents some value(s).</li>
<li> Most reference types should not overload the equality operator, even if they override  <a href="#Equals(System.Object)">Object.Equals</a>. However, if you are implementing a reference type that is intended to have value semantics, such as a complex number type, you should override the equality operator.</li>
</UL>
</dd>
</dl><b>Example</b><dl>
<dd> The following code example compares the current instance with another object.<pre>
using System;

public class Sample {
    void Method() {
    Object Obj1 = new Object();
    Object Obj2 = new Object();
    Console.WriteLine(Obj1.Equals(Obj2)); //===&gt; false
    Obj2 = Obj1;
    Console.WriteLine(Obj1.Equals(Obj2)); //===&gt; true
    }
}

    </pre>
<p> The following example shows a <b>Point</b> class that overrides the  <a href="#Equals(System.Object)">Object.Equals</a> method to provide value equality and a class <b>Point3D</b>, which is derived from <b>Point</b>. Because <b>Point</b> 's override of  <a href="#Equals(System.Object)">Object.Equals</a> is the first in the inheritance chain to introduce value equality, the  <a href="#Equals(System.Object)">Object.Equals</a> method of the base class (which is inherited from  <a href="../../System/types/Object.html">Object</a> and checks for referential equality) is not invoked. However, <b>Point3D.Equals</b> invokes <b>Point.Equals</b> because <b>Point</b> implements  <a href="#Equals(System.Object)">Object.Equals</a> in a manner that provides value equality.</p>
<pre>
using System;

class Point: Object {
   protected int x, y;

   public Point() {
     this.x = 0;
     this.y = 0;
   }

   public Point(int X, int Y) {
      this.x = X;
      this.y = Y;
   }
 
   public override bool Equals(Object obj) {
      //Check for null and compare run-time types.
      if (obj == null || GetType() != obj.GetType()) return false;
      Point p = (Point)obj;
      return (x == p.x) &amp;&amp; (y == p.y);
   }

   public override int GetHashCode() {
      return x ^ y;
   }
}


class Point3D: Point {
   int z;

   public Point3D(int X, int Y, int Z) {
      this.x = X;
      this.y = Y;
      this.z = Z; 
   }

   public override bool Equals(Object obj) {
      return base.Equals(obj) &amp;&amp; z == ((Point3D)obj).z;
   }

   public override int GetHashCode() {
      return base.GetHashCode() ^ z;
   }
}

    </pre>
<p> The <b>Point.Equals</b> method checks that the <i>obj</i> argument is not <b>null</b> and that it references an instance of the same type as this object. If either of those checks fail, the method returns <b>false</b>.</p>
<p> The  <a href="#Equals(System.Object)">Object.Equals</a> method uses  <a href="#GetType">Object.GetType</a> to determine whether the run-time types of the two objects are identical. (Note that <b>typeof</b> is not used here because it returns the static type.) If the method used a check of the form <code>
                obj is Point
              </code>, the check would return <b>true</b> in cases where <i>obj</i> is an instance of a derived class of <b>Point</b>, even though <i>obj</i> and the current instance are not of the same runtime type. Having verified that both objects are of the same type, the method casts <i>obj</i> to type <b>Point</b> and returns the result of comparing the instance variables of the two objects.</p>
<p> In <b>Point3D.Equals</b>, the inherited  <a href="#Equals(System.Object)">Object.Equals</a> method is invoked before anything else is done; the inherited  <a href="#Equals(System.Object)">Object.Equals</a> method checks to see that <i>obj</i> is not <b>null</b>, that <i>obj</i> is an instance of the same class as this object and that the inherited instance variables match. Only when the inherited  <a href="#Equals(System.Object)">Object.Equals</a> returns <b>true</b> does the method compare the instance variables introduced in the derived class. Specifically, the cast to <b>Point3D</b> is not executed unless <i>obj</i> has been determined to be of type <b>Point3D</b> or a derived class of <b>Point3D</b>.</p>
<p> In the previous example, <b>operator ==</b> (the equality operator) is used to compare the individual instance variables. In some cases, it is appropriate to use the  <a href="#Equals(System.Object)">Object.Equals</a> method to compare instance variables in an  <a href="#Equals(System.Object)">Object.Equals</a> implementation, as shown in the following code example.</p>
<pre>
using System;

class Rectangle {
   Point a, b;

   public Rectangle(int upLeftX, int upLeftY, int downRightX, int downRightY) {
      this.a = new Point(upLeftX, upLeftY);
      this.b = new Point(downRightX, downRightY);
   }

   public override bool Equals(Object obj) {
     // Performs an equality check on two rectangles (Point object pairs).
      if (obj == null || GetType() != obj.GetType()) return false;
      Rectangle r = (Rectangle)obj;
      //Uses Equals to compare variables.
      return a.Equals(r.a) &amp;&amp; b.Equals(r.b);
   }

   public override int GetHashCode() {
      return a.GetHashCode() ^ b.GetHashCode();
   }

}

    </pre>
<p> In some languages, such as C#, operator overloading is supported. When a type overloads <b>operator ==</b>, it should also override the  <a href="#Equals(System.Object)">Object.Equals</a> method to provide the same functionality. This is typically accomplished by writing the  <a href="#Equals(System.Object)">Object.Equals</a> method in terms of the overloaded <b>operator ==</b>, as in the following code example.</p>
<pre>
using System;

public struct Complex {
   public double re, im;

   public override bool Equals(Object obj) {
      return obj is Complex &amp;&amp; this == (Complex)obj;
   }

   public override int GetHashCode() {
      return re.GetHashCode() ^ im.GetHashCode();
   }

   public static bool operator ==(Complex x, Complex y) {
      return x.re == y.re &amp;&amp; x.im == y.im;
   }

   public static bool operator !=(Complex x, Complex y) {
      return !(x == y);
   }
}

    </pre>
<p> Because <b>Complex</b> is a C# struct (a value type), it cannot be derived from; therefore, the  <a href="#Equals(System.Object)">Object.Equals</a> method need not compare the  <a href="#GetType">Object.GetType</a> results for each object, but can instead use the <b>is</b> operator to check the type of the <i>obj</i> parameter.</p>
</dd>
</dl><b>See also: 
			</b><br> <a href="#ReferenceEquals(System.Object,System.Object)">Object.ReferenceEquals</a> |  <a href="#GetHashCode">Object.GetHashCode</a> |  <a href="../../System/types/ValueType.html">ValueType</a> |  <a href="../../System/types/IComparable.html">IComparable</a> |  <a href="../../System.Collections/types/ArrayList.html">ArrayList</a> |  <a href="../../System.Collections/types/Hashtable.html">Hashtable</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="EqualsTopic2"></a><a name="Equals(System.Object,System.Object)">Equals</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>objA</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>objB</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Determines whether the specified  <a href="../../System/types/Object.html">Object</a> instances are considered equal.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public static <a href="../../System/types/Boolean.html">bool</a> Equals(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>objA</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>objB</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>objA</i><br><dl>
<dd>
<param> The first  <a href="../../System/types/Object.html">Object</a> to compare.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>objB</i><br><dl>
<dd>
<param> The second  <a href="../../System/types/Object.html">Object</a> to compare.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if <i>objA</i> is the same instance as <i>objB</i> or if both are null references or if <code>
                objA.Equals(objB)
              </code> returns <b>true</b>; otherwise, <b>false</b>.</dd>
</dl><b>Remarks</b><dl>
<dd> The default implementation of  <a href="#Equals(System.Object)">Object.Equals</a> supports reference equality only, but derived classes can override this method to support value equality.<p> For reference types, equality is defined as object equality; that is, whether the references refer to the same object. For value types, equality is defined as bitwise equality. The  <a href="../../System/types/ValueType.html">ValueType</a> class supports value types.</p>
<p> This method first determines whether both parameters are null references before calling <code>
                objA.Equals(objB)
              </code>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following code example compares different objects.<pre>
using System;

public class MyClass {
   public static void Main() {
   string s1 = "Tom";
   string s2 = "Carol";
   Console.WriteLine("Object.Equals(\"{0}\", \"{1}\") =&gt; {2}", 
      s1, s2, Object.Equals(s1, s2));

   s1 = "Tom";
   s2 = "Tom";
   Console.WriteLine("Object.Equals(\"{0}\", \"{1}\") =&gt; {2}", 
      s1, s2, Object.Equals(s1, s2));

   s1 = null;
   s2 = "Tom";
   Console.WriteLine("Object.Equals(null, \"{1}\") =&gt; {2}",
       s1, s2, Object.Equals(s1, s2));

   s1 = "Carol";
   s2 = null;
   Console.WriteLine("Object.Equals(\"{0}\", null) =&gt; {2}", 
       s1, s2, Object.Equals(s1, s2));

   s1 = null;
   s2 = null;
   Console.WriteLine("Object.Equals(null, null) =&gt; {2}", 
       s1, s2, Object.Equals(s1, s2));
   }
}


/*

This code produces the following output.

Object.Equals("Tom", "Carol") =&gt; False
Object.Equals("Tom", "Tom") =&gt; True
Object.Equals(null, "Tom") =&gt; False
Object.Equals("Carol", null) =&gt; False
Object.Equals(null, null) =&gt; True

*/

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#ReferenceEquals(System.Object,System.Object)">Object.ReferenceEquals</a> |  <a href="../../System/types/ValueType.html">ValueType</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="FinalizeTopic1"></a><a name="Finalize">Finalize</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Allows an  <a href="../../System/types/Object.html">Object</a> to attempt to free resources and perform other cleanup operations before the  <a href="../../System/types/Object.html">Object</a> is reclaimed by garbage collection.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            ~Object();</b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> <a href="#Finalize">Object.Finalize</a> is protected and, therefore, is accessible only through this class or a derived class.<p> This method is automatically called after an object becomes inaccessible, unless the object has been exempted from finalization by a call to  <a href="../../System/types/GC.html#SuppressFinalize(System.Object)">GC.SuppressFinalize</a>. During shutdown of an application domain, <b>Finalize</b> is automatically called on objects that are not exempt from finalization, even those that are still accessible.<b>Finalize</b> is automatically called only once on a given instance, unless the object is re-registered using a mechanism such as  <a href="../../System/types/GC.html#ReRegisterForFinalize(System.Object)">GC.ReRegisterForFinalize</a> and <b>GC.SuppressFinalize</b> has not been subsequently called.</p>
<p> Every implementation of  <a href="#Finalize">Object.Finalize</a> in a derived type must call its base type's implementation of  <a href="#Finalize">Object.Finalize</a>. This is the only case in which application code is allowed to call  <a href="#Finalize">Object.Finalize</a>.</p>
<p> <a href="#Finalize">Object.Finalize</a> operations have the following limitations: </p>
<UL>
<li> The exact time when the finalizer executes during garbage collection is undefined. Resources are not guaranteed to be released at any specific time, unless calling a <b>Close</b> method or a <b>Dispose</b> method.</li>
<li> The finalizers of two objects are not guaranteed to run in any specific order, even if one object refers to the other. That is, if Object A has a reference to Object B and both have finalizers, Object B might have already finalized when the finalizer of Object A starts.</li>
<li> The thread on which the finalizer is run is unspecified.</li>
</UL>
<p> The  <a href="#Finalize">Object.Finalize</a> method might not run to completion or might not run at all in the following exceptional circumstances: </p>
<UL>
<li> Another finalizer blocks indefinitely (goes into an infinite loop, tries to obtain a lock it can never obtain and so on). Because the runtime attempts to run finalizers to completion, other finalizers might not be called if a finalizer blocks indefinitely.</li>
<li> The process terminates without giving the runtime a chance to clean up. In this case, the runtime's first notification of process termination is a DLL_PROCESS_DETACH notification.</li>
</UL>
<p> The runtime continues to <b>Finalize</b> objects during shutdown only while the number of finalizable objects continues to decrease.</p>
<p> If  <a href="#Finalize">Object.Finalize</a> or an override of  <a href="#Finalize">Object.Finalize</a> throws an exception, the runtime ignores the exception, terminates that  <a href="#Finalize">Object.Finalize</a> method, and continues the finalization process.</p><br><br><b>Notes to implementors: </b><p> <a href="#Finalize">Object.Finalize</a> does nothing by default. It must be overridden by a derived class only if necessary, because reclamation during garbage collection tends to take much longer if a  <a href="#Finalize">Object.Finalize</a> operation must be run.</p>
<p> If an  <a href="../../System/types/Object.html">Object</a> holds references to any resources,  <a href="#Finalize">Object.Finalize</a> must be overridden by a derived class in order to free these resources before the  <a href="../../System/types/Object.html">Object</a> is discarded during garbage collection.</p>
<p> A type should implement  <a href="#Finalize">Object.Finalize</a> when it uses unmanaged resources such as file handles or database connections that must be released when the managed object that uses them is reclaimed. See the  <a href="../../System/types/IDisposable.html">IDisposable</a> interface for a complementary and more controllable means of disposing resources.</p>
<p> <a href="#Finalize">Object.Finalize</a> can take any action, including resurrecting an object (that is, making the object accessible again) after it has been cleaned up during garbage collection. However, the object can only be resurrected once;  <a href="#Finalize">Object.Finalize</a> cannot be called on resurrected objects during garbage collection.</p>
<p> Destructors are the C# mechanism for performing cleanup operations. Destructors provide appropriate safeguards, such as automatically calling the base type's destructor. In C# code,  <a href="#Finalize">Object.Finalize</a> cannot be called or overridden.</p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/GC.html">GC</a> |  <a href="../../System/types/WeakReference.html">WeakReference</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetHashCodeTopic1"></a><a name="GetHashCode">GetHashCode</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Serves as a hash function for a particular type, suitable for use in hashing algorithms and data structures like a hash table.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/Int32.html">int</a> GetHashCode();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A hash code for the current  <a href="../../System/types/Object.html">Object</a>.</dd>
</dl><b>Remarks</b><dl>
<dd> This method can be overridden by a derived class. Value classes must override this method to provide a hash function that is appropriate for the class and that ensures a better distribution in the hash table. Classes that might be used as a key in a hash table must also override this method, because objects that are used as keys in a hash table are required to generate their own hash code through this method.<p> This implementation of  <a href="#GetHashCode">Object.GetHashCode</a> can only guarantee that the same hash code will be returned for the same instance; it cannot guarantee that different instances will have different hash codes or that two objects referring to the same value will have the same hash codes. Different versions of the .NET Framework might also generate different hash codes for the same instance. Therefore, do not persist hash codes to files or send them over the network. To guarantee the same hash code for the same object, you must define your own immutable hash function using the  <a href="../../System.Collections/types/IHashCodeProvider.html">IHashCodeProvider</a> interface and use it consistently.</p>
<p> The default implementation returns an index for the object determined by the common language runtime. The index is unique to an instance of an object within an AppDomain for an instance of the executing engine. However, because this index can be reused after the object is reclaimed during garbage collection, it is possible to obtain the same hash code for two different objects. Also, two objects that represent the same value have the same hash code only if they are the exact same object. This implementation is not particularly useful for hashing; therefore, derived classes should override  <a href="#GetHashCode">Object.GetHashCode</a>.</p><br><br><b>Notes to implementors: </b><p> A hash function is used to quickly generate a number (hash code) that corresponds to the value of an object. Hash functions are usually specific to each  <a href="../../System/types/Type.html">Type</a> and should use at least one of the instance fields as input.</p>
<p> A hash function must have the following properties: </p>
<UL>
<li> If two objects of the same type represent the same value, the hash function must return the same constant value for either object.</li>
<li> For the best performance, a hash function should generate a random distribution for all input.</li>
<li> A hash function should be based on an immutable data member. The hash function should return exactly the same value regardless of any changes that are made to the object. Basing the hash function on a mutable data member can cause serious problems, including never being able to access that object in a hash table.</li>
</UL>
<p> For example, the implementation of  <a href="../../System/types/String.html#GetHashCode">String.GetHashCode</a> provided by the  <a href="../../System/types/String.html">String</a> class returns unique hash codes for unique string values. Therefore, two  <a href="../../System/types/String.html">String</a> objects return the same hash code if they represent the same string value. Also, the method uses all the characters in the string to generate reasonably randomly distributed output, even when the input is clustered in certain ranges (for example, many users might have strings that contain only the lower 128 ASCII characters, even though a string can contain any of the 65,535 Unicode characters).</p>
<p> <a href="#GetHashCode">Object.GetHashCode</a> must always return the same value for a given instance of the object. One way to ensure this is by basing the hash code on an immutable data member. For derived classes of  <a href="../../System/types/Object.html">Object</a>,  <a href="#GetHashCode">Object.GetHashCode</a> can delegate to the  <a href="#GetHashCode">Object.GetHashCode</a> implementation, if and only if that derived class defines value equality to be reference equality and the type is not a value type.</p>
<p> Providing a good hash function on a class can significantly affect the performance of adding those objects to a hash table. In a hash table with a good implementation of a hash function, searching for an element takes constant time (for example, an O(1) operation). In a hash table with a poor implementation of a hash function, the performance of a search depends on the number of items in the hash table (for example, an O(<i>n</i>) operation, where <i>n</i> is the number of items in the hash table). Hash functions should also be inexpensive to compute.</p>
<p> Implementations of  <a href="#GetHashCode">Object.GetHashCode</a> must not result in circular references. For example, if <b>ClassA.GetHashCode</b> calls <b>ClassB.GetHashCode</b>, <b>ClassB.GetHashCode</b> must not call <b>ClassA.GetHashCode</b> either directly or indirectly.</p>
<p> Implementations of <b>GetHashCode</b> must not throw exceptions.</p>
<p> Derived classes that override  <a href="#GetHashCode">Object.GetHashCode</a> must also override  <a href="#Equals(System.Object)">Object.Equals</a> to guarantee that two objects considered equal have the same hash code; otherwise,  <a href="../../System.Collections/types/Hashtable.html">Hashtable</a> might not work correctly.</p>
</dd>
</dl><b>Example</b><dl>
<dd> In some cases,  <a href="#GetHashCode">Object.GetHashCode</a> is implemented to simply return an integer value. The following code example illustrates an implementation of  <a href="../../System/types/Int32.html#GetHashCode">Int32.GetHashCode</a>, which returns an integer value.<pre>
using System;

public struct Int32 {
   public int value;

   //other methods...

   public override int GetHashCode() {
      return value;
   }
}

    </pre>
<p> Frequently, a type has multiple data fields that can participate in generating the hash code. One way to generate a hash code is to combine these fields using an <b>XOR (eXclusive OR)</b> operation, as shown in the following code example.</p>
<pre>
using System;

public struct Point {
   public int x;
   public int y; 

   //other methods
   
   public override int GetHashCode() {
      return x ^ y;
   }
}

    </pre>
<p> The following code example illustrates another case where the type's fields are combined using <b>XOR (eXclusive OR)</b> to generate the hash code. Notice that in this code example, the fields represent user-defined types, each of which implements  <a href="#GetHashCode">Object.GetHashCode</a> and  <a href="#Equals(System.Object)">Object.Equals</a>.</p>
<pre>
using System;

public class SomeType {
   public override int GetHashCode() {
     return 0;
   }
}

public class AnotherType {
   public override int GetHashCode() {
     return 1;
   }
}

public class LastType {
   public override int GetHashCode() {
     return 2;
   }
}

public class MyClass {
   SomeType a = new SomeType();
   AnotherType b = new AnotherType();
   LastType c = new LastType();

   public override int GetHashCode () {
     return a.GetHashCode() ^ b.GetHashCode() ^ c.GetHashCode();
   }
}

    </pre>
<p> If the data member of the derived class is bigger than an  <a href="../../System/types/Int32.html">Int32</a>, you can combine the high order bits of the value with the low order bits using an <b>XOR (eXclusive OR)</b> operation, as shown in the following code example.</p>
<pre>
using System;

public struct Int64 {
   public long value;

   //other methods...

   public override int GetHashCode() {
      return ((int)value ^ (int)(value &gt;&gt; 32));
   }
}

    </pre>
</dd>
</dl><b>
								See also:
							</b><br><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconhashtable.asp">MSDN: hashtable</a> |  <a href="../../System.Collections/types/Hashtable.html">Hashtable</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetTypeTopic1"></a><a name="GetType">GetType</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Gets the  <a href="../../System/types/Type.html">Type</a> of the current instance.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Type.html">Type</a> GetType();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The  <a href="../../System/types/Type.html">Type</a> instance that represents the exact runtime type of the current instance.</dd>
</dl><b>Remarks</b><dl>
<dd> For two objects <i>x</i> and <i>y</i> that have identical runtime types, <code>
                Object.ReferenceEquals(x.GetType(),y.GetType())
              </code> returns <b>true</b>.<p> The  <a href="../../System/types/Type.html">Type</a> object exposes the metadata associated with the class of the current  <a href="../../System/types/Object.html">Object</a>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following code example demonstrates that  <a href="#GetType">Object.GetType</a> returns the runtime type of the current instance.<pre>
using System;

public class MyBaseClass: Object {
}

public class MyDerivedClass: MyBaseClass {
}

public class Test {

   public static void Main() {
      MyBaseClass myBase = new MyBaseClass();
      MyDerivedClass myDerived = new MyDerivedClass();
      object o = myDerived;
      MyBaseClass b = myDerived;

      Console.WriteLine("mybase: Type is {0}", myBase.GetType());
      Console.WriteLine("myDerived: Type is {0}", myDerived.GetType());
      Console.WriteLine("object o = myDerived: Type is {0}", o.GetType());
      Console.WriteLine("MyBaseClass b = myDerived: Type is {0}", b.GetType());
   }
}


/*

This code produces the following output.

mybase: Type is MyBaseClass
myDerived: Type is MyDerivedClass
object o = myDerived: Type is MyDerivedClass
MyBaseClass b = myDerived: Type is MyDerivedClass 

*/

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/Type.html">Type</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="MemberwiseCloneTopic1"></a><a name="MemberwiseClone">MemberwiseClone</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Creates a shallow copy of the current  <a href="../../System/types/Object.html">Object</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected <a href="../../System/types/Object.html">object</a> MemberwiseClone();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A shallow copy of the current  <a href="../../System/types/Object.html">Object</a>.</dd>
</dl><b>Remarks</b><dl>
<dd> This method cannot be overridden; a derived class should implement the  <a href="../../System/types/ICloneable.html">ICloneable</a> interface if a shallow copy is not appropriate. <a href="#MemberwiseClone">Object.MemberwiseClone</a> is protected and, therefore, is accessible only through this class or a derived class.<p> A shallow copy creates a new instance of the same type as the original object, and then copies the non-static fields of the original object. If the field is a value type, a bit-by-bit copy of the field is performed. If the field is a reference type, the reference is copied but the referred object is not; therefore, the reference in the original object and the reference in the clone point to the same object. In contrast, a deep copy of an object duplicates everything directly or indirectly referenced by the fields in the object.</p>
<p> For example, if X is an  <a href="../../System/types/Object.html">Object</a> with references to the objects A and B, and the object A also has a reference to an object M, a shallow copy of X is an object Y, which also has references to objects A and B. In contrast, a deep copy of X is an object Y with direct references to objects C and D, and an indirect reference to object N, where C is a copy of A, D is a copy of B, and N is a copy of M.</p>
<p> The  <a href="../../System/types/Type.html">Type</a> of the clone is the same as the type of the original  <a href="../../System/types/Object.html">Object</a>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following code example shows how to copy an instance of a class using  <a href="#MemberwiseClone">Object.MemberwiseClone</a>.<pre>
using System;

class MyBaseClass {
   public static string CompanyName = "My Company";
   public int age;
   public string name;
}

class MyDerivedClass: MyBaseClass {

   static void Main() {
   
   // Creates an instance of MyDerivedClass and assign values to its fields.
   MyDerivedClass m1 = new MyDerivedClass();
   m1.age = 42;
   m1.name = "Sam";

   // Performs a shallow copy of m1 and assign it to m2.
   MyDerivedClass m2 = (MyDerivedClass) m1.MemberwiseClone();
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/ICloneable.html">ICloneable</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="ReferenceEqualsTopic1"></a><a name="ReferenceEquals(System.Object,System.Object)">ReferenceEquals</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>objA</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>objB</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Determines whether the specified  <a href="../../System/types/Object.html">Object</a> instances are the same instance.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public static <a href="../../System/types/Boolean.html">bool</a> ReferenceEquals(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>objA</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>objB</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>objA</i><br><dl>
<dd>
<param> The first  <a href="../../System/types/Object.html">Object</a> to compare.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>objB</i><br><dl>
<dd>
<param> The second  <a href="../../System/types/Object.html">Object</a> to compare.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if <i>objA</i> is the same instance as <i>objB</i> or if both are null references; otherwise, <b>false</b>.</dd>
</dl><b>Example</b><dl>
<dd> The following code example uses  <a href="#ReferenceEquals(System.Object,System.Object)">Object.ReferenceEquals</a> to determine if two objects are the same instance.<pre>
using System;

class MyClass {

   static void Main() {
      object o = null;
      object p = null;
      object q = new Object();

      Console.WriteLine(Object.ReferenceEquals(o, p));
      p = q;
      Console.WriteLine(Object.ReferenceEquals(p, q));
      Console.WriteLine(Object.ReferenceEquals(o, p));
   }
}


/*

This code produces the following output.

True
True
False

*/

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#Equals(System.Object)">Object.Equals</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="ToStringTopic1"></a><a name="ToString">ToString</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns a  <a href="../../System/types/String.html">String</a> that represents the current  <a href="../../System/types/Object.html">Object</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/String.html">string</a> ToString();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System/types/String.html">String</a> that represents the current  <a href="../../System/types/Object.html">Object</a>.</dd>
</dl><b>Remarks</b><dl>
<dd> This method returns a human-readable string that is culture-sensitive. For example, for an instance of the  <a href="../../System/types/Double.html">Double</a> class whose value is zero, the implementation of  <a href="../../System/types/Double.html#ToString">Double.ToString</a> might return "0.00" or "0,00" depending on the current UI culture.<p> The default implementation returns the fully qualified name of the type of the  <a href="../../System/types/Object.html">Object</a>.</p><br><br><b>Notes to implementors: </b> This method can be overridden in a derived class to return values that are meaningful for that type. For example, the base data types, such as  <a href="../../System/types/Int32.html">Int32</a>, implement  <a href="#ToString">Object.ToString</a> so that it returns the string form of the value that the object represents. Derived classes that require more control over the formatting of strings than  <a href="#ToString">Object.ToString</a> provides should implement  <a href="../../System/types/IFormattable.html">IFormattable</a>, whose  <a href="../../System/types/IFormattable.html#ToString(System.String,System.IFormatProvider)">IFormattable.ToString</a> method uses the current thread's  <a href="../../System.Threading/types/Thread.html#CurrentCulture">Thread.CurrentCulture</a> property.</dd>
</dl><b>Example</b><dl>
<dd> The following code example demonstrates what  <a href="#ToString">Object.ToString</a> returns.<pre>
using System;

public class Sample
{
    void Method() {

        // Prints out: "System.Object"
        Object o = new Object();
        Console.WriteLine (o.ToString());

    }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/String.html">String</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite">
<h3 align="center"><a href="#TopOfPage">
					Top of page
				</a></h3><i><a href="../../documentation_license.txt">
				  Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
				</a></i></body>
</html>
