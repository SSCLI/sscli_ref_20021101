<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../refdoc.css">
<title>Type: System.Xml.XmlValidatingReader</title>
</head>
<body><a name="TopOfPage"></a><h2>System.Xml.XmlValidatingReader Class</h2><b>Assembly: </b>System.Xml.dll<br><b>Namespace: </b>System.Xml<br><dl>
<dt><b>Summary</b></dt>
<dd> Represents a reader that provides DTD, XML-Data Reduced (XDR) schema, and XML Schema definition language (XSD) schema validation.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
        public class XmlValidatingReader : XmlReader, IXmlLineInfo
      </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd><b>XmlValidatingReader</b> implements the  <a href="../../System.Xml/types/XmlReader.html">XmlReader</a> class and provides support for data validation. Use the  <a href="#Schemas">XmlValidatingReader.Schemas</a> property to have the reader validate using schema files cached in an  <a href="../../System.Xml.Schema/types/XmlSchemaCollection.html">XmlSchemaCollection</a>. The  <a href="#ValidationType">XmlValidatingReader.ValidationType</a> property specifies what type of validation the reader should perform. Setting the property to ValidationType.None creates a non-validating reader.<p> If you do not need data validation, the ability to resolve general entities, or support for default attributes, use  <a href="../../System.Xml/types/XmlTextReader.html">XmlTextReader</a>.</p>
<p> To read XML data from an  <a href="../../System.Xml/types/XmlNode.html">XmlNode</a>, use  <a href="../../System.Xml/types/XmlNodeReader.html">XmlNodeReader</a>.</p>
</dd>
</dl><b>See also: </b><dl>
<dd> <a href="../../System.Xml/System.Xml.html">System.Xml Namespace</a></dd>
</dl>
<h3>System.Xml.XmlValidatingReader Member List: </h3>
<dl>
<dt><b>Public Constructors</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#ctor1">ctor #1</a></td>
<td width="55%"><b>Overloaded:</b><br><code>.ctor(XmlReader reader)<br><br></code> Initializes a new instance of the <b>XmlValidatingReader</b> class that validates the content returned from the given  <a href="../../System.Xml/types/XmlReader.html">XmlReader</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ctor2">ctor #2</a></td>
<td width="55%"><b>Overloaded:</b><br><code>.ctor(Stream xmlFragment, XmlNodeType fragType, XmlParserContext context)<br><br></code> Initializes a new instance of the <b>XmlValidatingReader</b> class with the specified values.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ctor3">ctor #3</a></td>
<td width="55%"><b>Overloaded:</b><br><code>.ctor(string xmlFragment, XmlNodeType fragType, XmlParserContext context)<br><br></code> Initializes a new instance of the <b>XmlValidatingReader</b> class with the specified values.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Public Properties</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#AttributeCount">AttributeCount</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Gets the number of attributes on the current node.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#BaseURI">BaseURI</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Gets the base URI of the current node.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#CanResolveEntity">CanResolveEntity</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Gets a value indicating whether this reader can parse and resolve entities.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Depth">Depth</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Gets the depth of the current node in the XML document.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Encoding">Encoding</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets the encoding attribute for the document.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#EntityHandling">EntityHandling</a></td>
<td width="55%"><b>Read-write</b><br><br> Gets or sets a value that specifies how the reader handles entities.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#EOF">EOF</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Gets a value indicating whether the reader is positioned at the end of the stream.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#HasAttributes">HasAttributes</a><br>(inherited from <b>System.Xml.XmlReader)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System.Xml/types/XmlReader.html#HasAttributes">System.Xml.XmlReader.HasAttributes</a></font></b><br><br><br> Gets a value indicating whether the current node has any attributes.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#HasValue">HasValue</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Gets a value indicating whether the current node can have a  <a href="#Value">XmlValidatingReader.Value</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsDefault">IsDefault</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Gets a value indicating whether the current node is an attribute that was generated from the default value defined in the DTD or schema.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsEmptyElement">IsEmptyElement</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Gets a value indicating whether the current node is an empty element (for example, <code>
                &lt;MyElement/&gt;
              </code>).</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Item(System.Int32)">Item</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overloaded:</b><br><code>Item[int i] {get<br><br></code><b>Overridden: </b><br> Gets the value of the attribute with the specified index.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Item(System.String)">Item</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overloaded:</b><br><code>Item[string name] {get<br><br></code><b>Overridden: </b><br> Gets the value of the attribute with the specified name.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Item(System.String,System.String)">Item</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overloaded:</b><br><code>Item[string name, string namespaceURI] {get<br><br></code><b>Overridden: </b><br> Gets the value of the attribute with the specified local name and namespace URI.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#LocalName">LocalName</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Gets the local name of the current node.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Name">Name</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Gets the qualified name of the current node.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Namespaces">Namespaces</a></td>
<td width="55%"><b>Read-write</b><br><br> Gets or sets a value indicating whether to do namespace support.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#NamespaceURI">NamespaceURI</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Gets the namespace URI (as defined in the W3C Namespace specification) of the node on which the reader is positioned.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#NameTable">NameTable</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Gets the  <a href="../../System.Xml/types/XmlNameTable.html">XmlNameTable</a> associated with this implementation.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#NodeType">NodeType</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Gets the type of the current node.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Prefix">Prefix</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Gets the namespace prefix associated with the current node.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#QuoteChar">QuoteChar</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Gets the quotation mark character used to enclose the value of an attribute node.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Reader">Reader</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets the  <a href="../../System.Xml/types/XmlReader.html">XmlReader</a> used to construct this <b>XmlValidatingReader</b>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ReadState">ReadState</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Gets the state of the reader.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Schemas">Schemas</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a  <a href="../../System.Xml.Schema/types/XmlSchemaCollection.html">XmlSchemaCollection</a> to use for validation.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#SchemaType">SchemaType</a></td>
<td width="55%"><b>Read-only</b><br><br> Gets a schema type object.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ValidationType">ValidationType</a></td>
<td width="55%"><b>Read-write</b><br><br> Gets a value describing what type of validation to perform.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Value">Value</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Gets the text value of the current node.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#XmlLang">XmlLang</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Gets the current <b>xml:lang</b> scope.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#XmlResolver">XmlResolver</a></td>
<td width="55%"><b>Write-only</b><br><br> Sets the  <a href="../../System.Xml/types/XmlResolver.html">XmlResolver</a> used for resolving external DTD and schema location references. The <b>XmlResolver</b> is also used to handle any import or include elements found in XML Schema definition language (XSD) schemas.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#XmlSpace">XmlSpace</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Gets the current <b>xml:space</b> scope.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Public Methods</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#Close">Close</a></td>
<td width="55%"><b>Overridden: </b><br> Changes the  <a href="../../System.Xml/types/XmlReader.html#ReadState">XmlReader.ReadState</a> to Closed.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Equals(System.Object)">Equals</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#Equals(System.Object)">System.Object.Equals</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetAttribute(System.Int32)">GetAttribute</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetAttribute(int i)<br><br></code><b>Overridden: </b><br> Gets the value of the attribute with the specified index.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetAttribute(System.String)">GetAttribute</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetAttribute(string name)<br><br></code><b>Overridden: </b><br> Gets the value of the attribute with the specified name.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetAttribute(System.String,System.String)">GetAttribute</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetAttribute(string localName, string namespaceURI)<br><br></code><b>Overridden: </b><br> Gets the value of the attribute with the specified local name and namespace URI.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetHashCode">GetHashCode</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#GetHashCode">System.Object.GetHashCode</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetType">GetType</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#GetType">System.Object.GetType</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsStartElement">IsStartElement</a><br>(inherited from <b>System.Xml.XmlReader)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>IsStartElement()<br><br></code><b><font color="#800080">See base class member description: <a href="../../System.Xml/types/XmlReader.html#IsStartElement">System.Xml.XmlReader.IsStartElement</a></font></b><br><br><br> Calls  <a href="#MoveToContent">XmlReader.MoveToContent</a> and tests if the current content node is a start tag or empty element tag.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsStartElement(System.String)">IsStartElement</a><br>(inherited from <b>System.Xml.XmlReader)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>IsStartElement(string name)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System.Xml/types/XmlReader.html#IsStartElement(System.String)">System.Xml.XmlReader.IsStartElement</a></font></b><br><br><br> Calls  <a href="#MoveToContent">XmlReader.MoveToContent</a> and tests if the current content node is a start tag or empty element tag and if the  <a href="#Name">XmlReader.Name</a> property of the element found matches the given argument.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsStartElement(System.String,System.String)">IsStartElement</a><br>(inherited from <b>System.Xml.XmlReader)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>IsStartElement(string localname, string ns)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System.Xml/types/XmlReader.html#IsStartElement(System.String,System.String)">System.Xml.XmlReader.IsStartElement</a></font></b><br><br><br> Calls  <a href="#MoveToContent">XmlReader.MoveToContent</a> and tests if the current content node is a start tag or empty element tag and if the  <a href="#LocalName">XmlReader.LocalName</a> and  <a href="#NamespaceURI">XmlReader.NamespaceURI</a> properties of the element found match the given strings.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#LookupNamespace(System.String)">LookupNamespace</a></td>
<td width="55%"><b>Overridden: </b><br> Resolves a namespace prefix in the current element's scope.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#MoveToAttribute(System.Int32)">MoveToAttribute</a></td>
<td width="55%"><b>Overloaded:</b><br><code>MoveToAttribute(int i)<br><br></code><b>Overridden: </b><br> Moves to the attribute with the specified index.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#MoveToAttribute(System.String)">MoveToAttribute</a></td>
<td width="55%"><b>Overloaded:</b><br><code>MoveToAttribute(string name)<br><br></code><b>Overridden: </b><br> Moves to the attribute with the specified name.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#MoveToAttribute(System.String,System.String)">MoveToAttribute</a></td>
<td width="55%"><b>Overloaded:</b><br><code>MoveToAttribute(string localName, string namespaceURI)<br><br></code><b>Overridden: </b><br> Moves to the attribute with the specified local name and namespace URI.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#MoveToContent">MoveToContent</a><br>(inherited from <b>System.Xml.XmlReader)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System.Xml/types/XmlReader.html#MoveToContent">System.Xml.XmlReader.MoveToContent</a></font></b><br><br><br> Checks whether the current node is a content (non-white space text, <b>CDATA</b>, <b>Element</b>, <b>EndElement</b>, <b>EntityReference</b>, or <b>EndEntity</b>) node. If the node is not a content node, the reader skips ahead to the next content node or end of file. It skips over nodes of the following type: <b>ProcessingInstruction</b>, <b>DocumentType</b>, <b>Comment</b>, <b>Whitespace</b>, or <b>SignificantWhitespace</b>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#MoveToElement">MoveToElement</a></td>
<td width="55%"><b>Overridden: </b><br> Moves to the element that contains the current attribute node.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#MoveToFirstAttribute">MoveToFirstAttribute</a></td>
<td width="55%"><b>Overridden: </b><br> Moves to the first attribute.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#MoveToNextAttribute">MoveToNextAttribute</a></td>
<td width="55%"><b>Overridden: </b><br> Moves to the next attribute.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Read">Read</a></td>
<td width="55%"><b>Overridden: </b><br> Reads the next node from the stream.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ReadAttributeValue">ReadAttributeValue</a></td>
<td width="55%"><b>Overridden: </b><br> Parses the attribute value into one or more <b>Text</b>, <b>EntityReference</b>, or <b>EndEntity</b> nodes.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ReadElementString">ReadElementString</a><br>(inherited from <b>System.Xml.XmlReader)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>ReadElementString()<br><br></code><b><font color="#800080">See base class member description: <a href="../../System.Xml/types/XmlReader.html#ReadElementString">System.Xml.XmlReader.ReadElementString</a></font></b><br><br><br> Reads a text-only element.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ReadElementString(System.String)">ReadElementString</a><br>(inherited from <b>System.Xml.XmlReader)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>ReadElementString(string name)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System.Xml/types/XmlReader.html#ReadElementString(System.String)">System.Xml.XmlReader.ReadElementString</a></font></b><br><br><br> Checks that the  <a href="#Name">XmlReader.Name</a> property of the element found matches the given string before reading a text-only element.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ReadElementString(System.String,System.String)">ReadElementString</a><br>(inherited from <b>System.Xml.XmlReader)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>ReadElementString(string localname, string ns)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System.Xml/types/XmlReader.html#ReadElementString(System.String,System.String)">System.Xml.XmlReader.ReadElementString</a></font></b><br><br><br> Checks that the  <a href="#LocalName">XmlReader.LocalName</a> and  <a href="#NamespaceURI">XmlReader.NamespaceURI</a> properties of the element found matches the given strings before reading a text-only element.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ReadEndElement">ReadEndElement</a><br>(inherited from <b>System.Xml.XmlReader)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System.Xml/types/XmlReader.html#ReadEndElement">System.Xml.XmlReader.ReadEndElement</a></font></b><br><br><br> Checks that the current content node is an end tag and advances the reader to the next node.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ReadInnerXml">ReadInnerXml</a></td>
<td width="55%"><b>Overridden: </b><br> Reads all the content, including markup, as a string.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ReadOuterXml">ReadOuterXml</a></td>
<td width="55%"><b>Overridden: </b><br> Reads the content, including markup, representing this node and all its children.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ReadStartElement">ReadStartElement</a><br>(inherited from <b>System.Xml.XmlReader)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>ReadStartElement()<br><br></code><b><font color="#800080">See base class member description: <a href="../../System.Xml/types/XmlReader.html#ReadStartElement">System.Xml.XmlReader.ReadStartElement</a></font></b><br><br><br> Checks that the current node is an element and advances the reader to the next node.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ReadStartElement(System.String)">ReadStartElement</a><br>(inherited from <b>System.Xml.XmlReader)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>ReadStartElement(string name)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System.Xml/types/XmlReader.html#ReadStartElement(System.String)">System.Xml.XmlReader.ReadStartElement</a></font></b><br><br><br> Checks that the current content node is an element with the given  <a href="#Name">XmlReader.Name</a> and advances the reader to the next node.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ReadStartElement(System.String,System.String)">ReadStartElement</a><br>(inherited from <b>System.Xml.XmlReader)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>ReadStartElement(string localname, string ns)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System.Xml/types/XmlReader.html#ReadStartElement(System.String,System.String)">System.Xml.XmlReader.ReadStartElement</a></font></b><br><br><br> Checks that the current content node is an element with the given  <a href="#LocalName">XmlReader.LocalName</a> and  <a href="#NamespaceURI">XmlReader.NamespaceURI</a> and advances the reader to the next node.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ReadString">ReadString</a></td>
<td width="55%"><b>Overridden: </b><br> Reads the contents of an element or text node as a string.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ReadTypedValue">ReadTypedValue</a></td>
<td width="55%"> Gets the common language runtime type for the specified XML Schema definition language (XSD) type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ResolveEntity">ResolveEntity</a></td>
<td width="55%"><b>Overridden: </b><br> Resolves the entity reference for <b>EntityReference</b> nodes.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Skip">Skip</a><br>(inherited from <b>System.Xml.XmlReader)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System.Xml/types/XmlReader.html#Skip">System.Xml.XmlReader.Skip</a></font></b><br><br><br> Skips the children of the current node.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ToString">ToString</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#ToString">System.Object.ToString</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Public Events</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#ValidationEventHandler">ValidationEventHandler</a></td>
<td width="55%"> Sets an event handler for receiving information about DTD, XML-Data Reduced (XDR) schema, and XML Schema definition language (XSD) schema validation errors.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Protected Methods</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#Finalize">Finalize</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#Finalize">System.Object.Finalize</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#MemberwiseClone">MemberwiseClone</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#MemberwiseClone">System.Object.MemberwiseClone</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
</table>
</dd>
</dl>
<p><b>Hierarchy:</b><ul class="none">
<li><a href="../../System/types/Object.html">System.Object</a></li>
<ul class="none">
<li><a href="../../System.Xml/types/XmlReader.html">System.Xml.XmlReader</a></li>
<ul class="none">
<li><b>System.Xml.XmlValidatingReader</b></li>
</ul>
</ul>
</ul>
</p>
<hr>
<h3>System.Xml.XmlValidatingReader Member Details</h3><b>Overloaded <i><a name=".ctorTopic1"></a><a name="ctor1">ctor #1</a></i></b><b><i></i></b><dl>
<dt><b>Summary</b></dt>
<dd> Initializes a new instance of the <b>XmlValidatingReader</b> class that validates the content returned from the given  <a href="../../System.Xml/types/XmlReader.html">XmlReader</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public XmlValidatingReader(<br>   <font color="#008080"><a href="../../System.Xml/types/XmlReader.html">XmlReader</a> <i>reader</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>reader</i><br><dl>
<dd>
<param> The <b>XmlReader</b> to read from while validating. The current implementation only supports  <a href="../../System.Xml/types/XmlTextReader.html">XmlTextReader</a>.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td> The reader specified is not an <b>XmlTextReader</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> All nodes returned from the given <b>XmlReader</b> are also returned from this validating reader, so there is no information loss in the process. New nodes not returned from the underlying reader may be added by this reader (for example, default attributes and the children of an entity reference). Any properties set on the given <b>XmlTextReader</b> also applies to this validating reader. For example, if the supplied reader had WhitespaceHandling.None set, this validating reader also ignores whitespace.<p> When external DTDs or schemas are needed for validation the  <a href="#XmlResolver">XmlValidatingReader.XmlResolver</a> property sets the  <a href="../../System.Xml/types/XmlResolver.html">XmlResolver</a> object to use for resolving external resources.</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following example validates two documents.<pre>
using System;
using System.IO;
using System.Xml;
using System.Xml.Schema;

public class Sample
{

  private Boolean m_success = true;

  public Sample ()
  {
      //Validate the document using an external XSD schema.  Validation should fail.
      Validate("notValidXSD.xml"); 

      //Validate the document using an inline XSD. Validation should succeed.
      Validate("inlineXSD.xml");
  }    

  public static void Main ()
  {
      Sample validation = new Sample();
  }

  private void Validate(String filename)
  {    
      m_success = true;
      Console.WriteLine("\r\n******");
      Console.WriteLine("Validating XML file " + filename.ToString());
      XmlTextReader txtreader = new XmlTextReader (filename);
      XmlValidatingReader reader = new XmlValidatingReader (txtreader);

      // Set the validation event handler
      reader.ValidationEventHandler += new ValidationEventHandler (ValidationCallBack);

      // Read XML data
      while (reader.Read()){}
      Console.WriteLine ("Validation finished. Validation {0}", (m_success==true ? "successful!" : "failed."));

      //Close the reader.
      reader.Close();
  }

  //Display the validation error.
  public void ValidationCallBack (object sender, ValidationEventArgs args)
  {
     m_success = false;
     Console.WriteLine("\r\n\tValidation error: " + args.Message );
  }
}

    </pre>
<p> The sample uses the following input files: </p>
<p><b>notValidXSD.xml</b></p>
<pre>
&lt;?xml version='1.0'?&gt;
&lt;bookstore xmlns="urn:bookstore-schema"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="urn:bookstore-schema books.xsd"&gt;
  &lt;book&gt;
    &lt;author&gt;
      &lt;first-name&gt;Benjamin&lt;/first-name&gt;
      &lt;last-name&gt;Franklin&lt;/last-name&gt;
    &lt;/author&gt;
  &lt;/book&gt;
  &lt;book genre="novel"&gt;
    &lt;title&gt;The Confidence Man&lt;/title&gt;
    &lt;author&gt;
      &lt;first-name&gt;Herman&lt;/first-name&gt;
      &lt;last-name&gt;Melville&lt;/last-name&gt;
    &lt;/author&gt;
    &lt;price&gt;11.99&lt;/price&gt;
  &lt;/book&gt;
&lt;/bookstore&gt;

    </pre>
<p><b>books.xsd</b></p>
<pre>
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns="urn:bookstore-schema"
    elementFormDefault="qualified"
    targetNamespace="urn:bookstore-schema"&gt;

 &lt;xsd:element name="bookstore" type="bookstoreType"/&gt;

 &lt;xsd:complexType name="bookstoreType"&gt;
  &lt;xsd:sequence maxOccurs="unbounded"&gt;
   &lt;xsd:element name="book"  type="bookType"/&gt;
  &lt;/xsd:sequence&gt;
 &lt;/xsd:complexType&gt;

 &lt;xsd:complexType name="bookType"&gt;
  &lt;xsd:sequence&gt;
   &lt;xsd:element name="title" type="xsd:string"/&gt;
   &lt;xsd:element name="author" type="authorName"/&gt;
   &lt;xsd:element name="price"  type="xsd:decimal"/&gt;
  &lt;/xsd:sequence&gt;
  &lt;xsd:attribute name="genre" type="xsd:string"/&gt;
 &lt;/xsd:complexType&gt;

 &lt;xsd:complexType name="authorName"&gt;
  &lt;xsd:sequence&gt;
   &lt;xsd:element name="first-name"  type="xsd:string"/&gt;
   &lt;xsd:element name="last-name" type="xsd:string"/&gt;
  &lt;/xsd:sequence&gt;
 &lt;/xsd:complexType&gt;

&lt;/xsd:schema&gt;

    </pre>
<p><b>inlineXSD.xml</b></p>
<pre>
&lt;store-data&gt;
&lt;!--Inline XSD schema--&gt;
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
 &lt;xsd:element name="bookstore" type="bookstoreType"/&gt;
 &lt;xsd:complexType name="bookstoreType"&gt;
  &lt;xsd:sequence maxOccurs="unbounded"&gt;
   &lt;xsd:element name="book"  type="bookType"/&gt;
  &lt;/xsd:sequence&gt;
 &lt;/xsd:complexType&gt;

 &lt;xsd:complexType name="bookType"&gt;
  &lt;xsd:sequence&gt;
   &lt;xsd:element name="title" type="xsd:string"/&gt;
   &lt;xsd:element name="price"  type="xsd:decimal"/&gt;
  &lt;/xsd:sequence&gt;
  &lt;xsd:attribute name="genre" type="xsd:string"/&gt;
 &lt;/xsd:complexType&gt;
&lt;/xsd:schema&gt;
&lt;!-- end of schema --&gt;

&lt;bookstore&gt;
  &lt;book genre="novel"&gt;
    &lt;title&gt;Pride And Prejudice&lt;/title&gt;
    &lt;price&gt;19.95&lt;/price&gt;
  &lt;/book&gt;
&lt;/bookstore&gt;
&lt;/store-data&gt;

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Xml/types/XmlTextReader.html">XmlTextReader</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded <i><a name=".ctorTopic2"></a><a name="ctor2">ctor #2</a></i></b><b><i></i></b><dl>
<dt><b>Summary</b></dt>
<dd> Initializes a new instance of the <b>XmlValidatingReader</b> class with the specified values.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public XmlValidatingReader(<br>   <font color="#008080"><a href="../../System.IO/types/Stream.html">Stream</a> <i>xmlFragment</i>,</font><br>   <font color="#008080"><a href="../../System.Xml/types/XmlNodeType.html">XmlNodeType</a> <i>fragType</i>,</font><br>   <font color="#008080"><a href="../../System.Xml/types/XmlParserContext.html">XmlParserContext</a> <i>context</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>xmlFragment</i><br><dl>
<dd>
<param> The stream containing the XML fragment to parse.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>fragType</i><br><dl>
<dd>
<param> The  <a href="../../System.Xml/types/XmlNodeType.html">XmlNodeType</a> of the XML fragment. This determines what the fragment can contain (see table below).
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>context</i><br><dl>
<dd>
<param> The  <a href="../../System.Xml/types/XmlParserContext.html">XmlParserContext</a> in which the XML fragment is to be parsed. This includes the  <a href="../../System.Xml/types/XmlNameTable.html">XmlNameTable</a> to use, encoding, namespace scope, the current <b>xml:lang</b> and the <b>xml:space</b> scope. The  <a href="../../System.Xml/types/XmlParserContext.html">XmlParserContext</a> in which the XML fragment is to be parsed. This includes the  <a href="../../System.Xml/types/XmlNameTable.html">XmlNameTable</a> to use, encoding, namespace scope, the current <b>xml:lang</b> and the <b>xml:space</b> scope.</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Xml/types/XmlException.html">XmlException</a></td>
<td><i>fragType</i> is not one of the node types listed in the table below.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This constructor parses the given string as a fragment of XML. If the XML fragment is an element or attribute, you can bypass the root level rules for well-formed XML documents.<p> The following table lists valid values for <i>fragType</i> and how the reader parses each of the different node types.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  XmlNodeType
                </TH>
<TH>
                  Fragment May Contain
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Element
                </TD>
<TD>
                  Any
                  valid element content (for example, any combination of elements, comments, processing instructions, cdata, text, entity references).
                </TD>
</TR>
<TR valign="top">
<TD>
                  Attribute
                </TD>
<TD>
                  The value of an attribute (the part inside the quotes).
                </TD>
</TR>
<TR valign="top">
<TD>
                  Document
                </TD>
<TD>
                  The contents of an entire XML document; this enforces document level rules.
                </TD>
</TR>
</table>
<p> The reader uses the following to determine the encoding of the stream.</p>
<OL>
<li> Checks the  <a href="../../System.Xml/types/XmlParserContext.html#Encoding">XmlParserContext.Encoding</a> property to determine the encoding.</li>
<li> If the <b>Encoding</b> property is <b>null</b>, the reader checks for a byte-order mark at the beginning of the stream.</li>
<li> If the <b>Encoding</b> property is <b>null</b>, and no byte-order mark is found, the reader assumes the stream is encoded in UTF-8.</li>
</OL>
<p> If this reader will be validating using DTD (that is,  <a href="#ValidationType">XmlValidatingReader.ValidationType</a> is set to ValidationType.DTD or ValidationType.Auto) the <b>XmlParserContext</b> specified in the constructor must supply all the necessary DocumentType information.</p><br><br><b>Note </b> It is not possible to validate a fragment using a DTD. By definition a DTD requires an entire document to be loaded for validation.<p> If this reader will be validating using XML-Data Reduced (XDR) or XML Schema definition language (XSD) schemas, use the  <a href="#Schemas">XmlValidatingReader.Schemas</a> property to specify the  <a href="../../System.Xml.Schema/types/XmlSchemaCollection.html">XmlSchemaCollection</a> containing the schemas (that is, the <b>XmlParserContext</b> does not need to supply the DocumentType information).</p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded <i><a name=".ctorTopic3"></a><a name="ctor3">ctor #3</a></i></b><b><i></i></b><dl>
<dt><b>Summary</b></dt>
<dd> Initializes a new instance of the <b>XmlValidatingReader</b> class with the specified values.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public XmlValidatingReader(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>xmlFragment</i>,</font><br>   <font color="#008080"><a href="../../System.Xml/types/XmlNodeType.html">XmlNodeType</a> <i>fragType</i>,</font><br>   <font color="#008080"><a href="../../System.Xml/types/XmlParserContext.html">XmlParserContext</a> <i>context</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>xmlFragment</i><br><dl>
<dd>
<param> The string containing the XML fragment to parse.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>fragType</i><br><dl>
<dd>
<param> The  <a href="../../System.Xml/types/XmlNodeType.html">XmlNodeType</a> of the XML fragment. This also determines what the fragment string can contain (see table below).
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>context</i><br><dl>
<dd>
<param> The  <a href="../../System.Xml/types/XmlParserContext.html">XmlParserContext</a> in which the XML fragment is to be parsed. This includes the  <a href="../../System.Xml/types/NameTable.html">NameTable</a> to use, encoding, namespace scope, the current xml:lang and the xml:space scope. The  <a href="../../System.Xml/types/XmlParserContext.html">XmlParserContext</a> in which the XML fragment is to be parsed. This includes the  <a href="../../System.Xml/types/NameTable.html">NameTable</a> to use, encoding, namespace scope, the current xml:lang and the xml:space scope.</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Xml/types/XmlException.html">XmlException</a></td>
<td><i>fragType</i> is not one of the node types listed in the table below.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This constructor parses the given string as a fragment of XML. If the XML fragment is an element or attribute, you can bypass the root level rules for well-formed XML documents. This constructor can handle strings returned from  <a href="#ReadInnerXml">XmlValidatingReader.ReadInnerXml</a>.<p> The following table lists valid values for <i>fragType</i> and how the reader parses each of the different node types.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  XmlNodeType
                </TH>
<TH>
                  Fragment May Contain
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Element
                </TD>
<TD>
                  Any
                  valid element content (for example, any combination of elements, comments, processing instructions, cdata, text, entity references).
                </TD>
</TR>
<TR valign="top">
<TD>
                  Attribute
                </TD>
<TD>
                  The value of an attribute (the part inside the quotes).
                </TD>
</TR>
<TR valign="top">
<TD>
                  Document
                </TD>
<TD>
                  The contents of an entire XML document; this enforces document level rules.
                </TD>
</TR>
</table>
<p> If this reader will be validating using DTD (that is,  <a href="#ValidationType">XmlValidatingReader.ValidationType</a> is set to ValidationType.DTD or ValidationType.Auto) the <b>XmlParserContext</b> specified in the constructor must supply all the necessary DocumentType information.</p><br><br><b>Note </b> It is not possible to validate a fragment using DTD. By definition DTD requires an entire document to be loaded for validation.<p> If this reader will be validating using XML-Data Reduced (XDR) or XML Schema definition language (XSD) schemas, use the  <a href="#Schemas">XmlValidatingReader.Schemas</a> property to specify the  <a href="../../System.Xml.Schema/types/XmlSchemaCollection.html">XmlSchemaCollection</a> containing the schemas (the <b>XmlParserContext</b> does not need to supply the DocumentType information).</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following example reads an XML fragment. It uses an <b>XmlParserContext</b> and its  <a href="../../System.Xml/types/XmlNamespaceManager.html">XmlNamespaceManager</a> to handle namespace matching.<pre>
using System;
using System.IO;
using System.Xml;

public class Sample 
{
  public static void Main()
  {
    XmlValidatingReader reader = null;

    try
    {
       //Create the XML fragment to be parsed.
       string xmlFrag ="&lt;book&gt; " +
                       "&lt;title&gt;Pride And Prejudice&lt;/title&gt;" +
                       "&lt;bk:genre&gt;novel&lt;/bk:genre&gt;" +
                       "&lt;/book&gt;"; 

       //Create the XmlNamespaceManager that is used to
       //look up namespace information.
       NameTable nt = new NameTable();
       XmlNamespaceManager nsmgr = new XmlNamespaceManager(nt);
       nsmgr.AddNamespace("bk", "urn:sample");

       //Create the XmlParserContext.
       XmlParserContext context = new XmlParserContext(null, nsmgr, null, XmlSpace.None);

       //Implement the reader. 
       reader = new XmlValidatingReader(xmlFrag, XmlNodeType.Element, context);
  
       //Parse the XML fragment.  If they exist, display the   
       //prefix and namespace URI of each element.
       while (reader.Read()){
         if (reader.IsStartElement()){
           if (reader.Prefix==String.Empty)
              Console.WriteLine("&lt;{0}&gt;", reader.LocalName);
           else{
               Console.Write("&lt;{0}:{1}&gt;", reader.Prefix, reader.LocalName);
               Console.WriteLine(" The namespace URI is " + reader.NamespaceURI);
           }
         }
       }
       

     } 

     finally 
     {
        if (reader != null)
          reader.Close();
      }
  }
} // End class

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="AttributeCountTopic1"></a><a name="AttributeCount">AttributeCount</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the number of attributes on the current node.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Int32.html">int</a> AttributeCount {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This property is relevant to <b>Element</b>, <b>DocumentType</b> and <b>XmlDeclaration</b> nodes only. (Other node types do not have attributes.) </dd>
</dl><b>Example</b><dl>
<dd> The following example reads all the elements on the root node.<pre>
using System;
using System.IO;
using System.Xml;

public class Sample 
{
  public static void Main()
  {
    XmlValidatingReader reader = null;

    try
    {
       //Create the string to parse.
       string xmlFrag="&lt;book genre='novel' ISBN='1-861003-78' pubdate='1987'&gt;&lt;/book&gt; ";

       //Create the XmlNamespaceManager.
       NameTable nt = new NameTable();
       XmlNamespaceManager nsmgr = new XmlNamespaceManager(nt);

       //Create the XmlParserContext.
       XmlParserContext context = new XmlParserContext(null, nsmgr, null, XmlSpace.None);

       //Create the XmlValidatingReader .
       reader = new XmlValidatingReader(xmlFrag, XmlNodeType.Element, context);
  
       //Read the attributes on the root element.
       reader.MoveToContent();
       if (reader.HasAttributes){
         for (int i=0; i&lt;reader.AttributeCount; i++){
            reader.MoveToAttribute(i);
            Console.WriteLine("{0} = {1}", reader.Name, reader.Value);
         }
         //Move the reader back to the node that owns the attribute.
         reader.MoveToElement();
       }

     } 

     finally 
     {
        if (reader != null)
          reader.Close();
      }
  }
} // End class

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="BaseURITopic1"></a><a name="BaseURI">BaseURI</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the base URI of the current node.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/String.html">string</a> BaseURI {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> A networked XML document is comprised of chunks of data aggregated using various W3C standard inclusion mechanisms and therefore contains nodes that come from different places. DTD entities are an example of this, but this is not limited to DTDs. The base URI tells you where these nodes came from. If there is no base URI for the nodes being returned (for example, they were parsed from an in-memory string), String.Empty is returned.</dd>
</dl><b>Example</b><dl>
<dd> The following example parses a file and displays the base URI of each node.<pre>
using System;
using System.IO;
using System.Xml;

public class Sample
{
  public static void Main()
  {
    XmlValidatingReader reader = null;
    XmlTextReader txtreader = null;

    try
    {           
        //Create the validating reader.
        txtreader = new XmlTextReader("http://localhost/uri.xml");
        reader = new XmlValidatingReader(txtreader);
        reader.ValidationType = ValidationType.None;

        //Parse the file and display the base URI for each node.
        while (reader.Read())
        {
            Console.WriteLine("({0}) {1}", reader.NodeType, reader.BaseURI);
         }           
     }

     finally
     {
       if (reader!=null)
         reader.Close();
     }
  }
} // End class

    </pre> The example uses the file, <b>uri.xml</b>, as input. The <b>style.xml</b> file contains the XML text <code>
              &lt;style&gt;hardcover&lt;/style&gt;
            </code>.<pre>

&lt;!-- XML fragment --&gt;
&lt;!DOCTYPE book [&lt;!ENTITY s SYSTEM "tmp/style.xml"&gt;]&gt;
&lt;book genre="novel"&gt;
  &lt;title&gt;Pride And Prejudice&lt;/title&gt;
  &lt;misc&gt;&amp;s;&lt;/misc&gt;
&lt;/book&gt;

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="CanResolveEntityTopic1"></a><a name="CanResolveEntity">CanResolveEntity</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether this reader can parse and resolve entities.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Boolean.html">bool</a> CanResolveEntity {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="DepthTopic1"></a><a name="Depth">Depth</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the depth of the current node in the XML document.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Int32.html">int</a> Depth {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd> The following example displays each node including its depth, line number, and line position.<pre>
using System;
using System.IO;
using System.Xml;

public class Sample{

  public static void Main(){

    // Create the XML fragment to be parsed.
    string xmlFrag  = 
    @"&lt;book&gt;
           &lt;misc&gt;
              &lt;style&gt;paperback&lt;/style&gt;
              &lt;pages&gt;240&lt;/pages&gt;
           &lt;/misc&gt;
        &lt;/book&gt;
    ";

    // Create the XmlNamespaceManager.
    XmlNamespaceManager nsmgr = new XmlNamespaceManager(new NameTable());

    // Create the XmlParserContext.
    XmlParserContext context = new XmlParserContext(null, nsmgr, null, XmlSpace.None);

    // Create the reader.
    XmlValidatingReader reader = new XmlValidatingReader(xmlFrag, XmlNodeType.Element, context);

    IXmlLineInfo lineInfo = ((IXmlLineInfo)reader);
    if (lineInfo.HasLineInfo()){
       
      // Parse the XML and display each node.
      while (reader.Read()){
       switch (reader.NodeType){
         case XmlNodeType.Element:
           Console.Write("{0} {1},{2}  ", reader.Depth, lineInfo.LineNumber, lineInfo.LinePosition);
           Console.WriteLine("&lt;{0}&gt;", reader.Name);
           break;
         case XmlNodeType.Text:
           Console.Write("{0} {1},{2}  ", reader.Depth, lineInfo.LineNumber, lineInfo.LinePosition);
           Console.WriteLine("  {0}", reader.Value);
           break;
         case XmlNodeType.EndElement:
           Console.Write("{0} {1},{2}  ", reader.Depth, lineInfo.LineNumber, lineInfo.LinePosition);
           Console.WriteLine("&lt;/{0}&gt;", reader.Name);
           break;
       }       
     }           
    }

    // Close the reader.
    reader.Close();       
  }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Xml/types/IXmlLineInfo.html">IXmlLineInfo</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="EncodingTopic1"></a><a name="Encoding">Encoding</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the encoding attribute for the document.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Text/types/Encoding.html">Encoding</a> Encoding {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> When any external reference is read (such as expanding an entity in a DTD file or reading a schema file) the encoding property is set to the encoding value of the external reference. If encoding is not specified in the external reference, and there is no byte-order mark, this defaults to UTF-8.<p> All the encoding standards that the underlying operating system supports are supported.</p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="EntityHandlingTopic1"></a><a name="EntityHandling">EntityHandling</a></i></b><b><i></i></b><b><font color="#008080"> (read-write)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets or sets a value that specifies how the reader handles entities.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Xml/types/EntityHandling.html">EntityHandling</a> EntityHandling {get; set;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentOutOfRangeException.html">ArgumentOutOfRangeException</a></td>
<td> Invalid value was specified.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This property can be changed on the fly and takes effect after the next  <a href="#Read">XmlValidatingReader.Read</a> call.<p> When <b>EntityHandling</b> is set to <b>ExpandCharEntities</b>, attribute values are only partially normalized. The reader normalizes each individual text node independently from the content of adjacent entity reference nodes.</p>
<p> To illustrate the difference between the entity handling modes consider the following XML: </p>
<pre>
              &lt;!DOCTYPE doc [&lt;!ENTITY num "123"&gt;]&gt;
               &lt;doc&gt; &amp;#65; &amp;num; &lt;/doc&gt;
            </pre>
<p> When <b>EntityHandling</b> is set to <b>ExpandEntities</b> the "doc" element node contains one text node with the expanded entity text: </p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Depth
                </TH>
<TH> NodeType </TH>
<TH>
                  Name
                </TH>
<TH>
                  Value
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  1
                </TD>
<TD>
                  Text
                </TD>
<TD></TD>
<TD>
                  A 123
                </TD>
</TR>
</table>
<p> When <b>EntityHandling</b> is set to <b>ExpandCharEntites</b>, and  <a href="../../System.Xml/types/XmlTextReader.html#WhitespaceHandling">XmlTextReader.WhitespaceHandling</a> is set to Significant or All, the "doc" element expands the character entity and returns the general entity as a node: </p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Depth
                </TH>
<TH>
                  NodeType
                </TH>
<TH>
                  Name
                </TH>
<TH>
                  Value
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  1
                </TD>
<TD>
                  Text
                </TD>
<TD></TD>
<TD>
                  A
                </TD>
</TR>
<TR valign="top">
<TD>
                  1
                </TD>
<TD>
                  EntityReference
                </TD>
<TD>
                  num
                </TD>
<TD></TD>
</TR>
<TR valign="top">
<TD>
                  1
                </TD>
<TD>
                  SignificantWhitespace
                </TD>
<TD></TD>
<TD></TD>
</TR>
</table>
</dd>
</dl><b>Example</b><dl>
<dd> The following example uses the <b>ResolveEntity</b> method to expand a general entity.<pre>
using System;
using System.IO;
using System.Xml;

public class Sample
{

  public static void Main()
  {
    XmlTextReader reader = null;

    try
    {           
        //Load the reader with the XML file.
        reader = new XmlTextReader("book1.xml");
        reader.WhitespaceHandling = WhitespaceHandling.None;

        //Parse the file and display each node.
        while (reader.Read())
        {
           if (reader.HasValue)
             Console.WriteLine("({0})  {1}={2}", reader.NodeType, reader.Name, reader.Value);
           else
             Console.WriteLine("({0}) {1}", reader.NodeType, reader.Name);
         }           
     }

     finally
     {
       if (reader!=null)
         reader.Close();
     }
  }
} // End class

    </pre> The example uses the file, <b>book1.xml</b>, as input.<pre>

&lt;?xml version='1.0' ?&gt;
&lt;!DOCTYPE book [&lt;!ENTITY h 'hardcover'&gt;]&gt;
&lt;book&gt;
  &lt;title&gt;Pride And Prejudice&lt;/title&gt;
  &lt;misc&gt;&amp;h;&lt;/misc&gt;
&lt;/book&gt;

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="EOFTopic1"></a><a name="EOF">EOF</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the reader is positioned at the end of the stream.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Boolean.html">bool</a> EOF {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="HasAttributesTopic1"></a><a name="HasAttributes">HasAttributes</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System.Xml/types/XmlReader.html#HasAttributes">System.Xml.XmlReader.HasAttributes</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the current node has any attributes.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/Boolean.html">bool</a> HasAttributes {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd> The following example displays all attributes on the current node.<pre>
    public void DisplayAttributes(XmlReader reader)
    {
        if (reader.HasAttributes)
        {
            Console.WriteLine("Attributes of &lt;" + reader.Name + "&gt;");
            while (reader.MoveToNextAttribute())
            {
                Console.WriteLine(" {0}={1}", reader.Name, reader.Value);
            }
        }
    }

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="HasValueTopic1"></a><a name="HasValue">HasValue</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the current node can have a  <a href="#Value">XmlValidatingReader.Value</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Boolean.html">bool</a> HasValue {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The following table lists node types that have a value to return.<br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Node Type
                </TH>
<TH>
                  Value
                </TH>
</THEAD>
<TR valign="top">
<TD><b>Attribute</b></TD>
<TD>
                  The value of the attribute.
                </TD>
</TR>
<TR valign="top">
<TD><b>CDATA</b></TD>
<TD>
                  The content of the CDATA section.
                </TD>
</TR>
<TR valign="top">
<TD><b>Comment</b></TD>
<TD>
                  The content of the comment.
                </TD>
</TR>
<TR valign="top">
<TD><b>DocumentType</b></TD>
<TD>
                  The internal subset.
                </TD>
</TR>
<TR valign="top">
<TD><b>ProcessingInstruction</b></TD>
<TD>
                  The entire content, excluding the target.
                </TD>
</TR>
<TR valign="top">
<TD><b>SignificantWhitespace</b></TD>
<TD>
                  The whitespace between markup in a mixed content model.
                </TD>
</TR>
<TR valign="top">
<TD><b>Text</b></TD>
<TD> The content of the text node.</TD>
</TR>
<TR valign="top">
<TD><b>Whitespace</b></TD>
<TD>
                  The whitespace between markup.
                </TD>
</TR>
<TR valign="top">
<TD><b>XmlDeclaration</b></TD>
<TD>
                  The content of the declaration.
                </TD>
</TR>
</table>
</dd>
</dl><b>Example</b><dl>
<dd> The following example reads in XML with various data types and displays each of the nodes.<pre>

using System;
using System.IO;
using System.Xml;

public class Sample
{

  public static void Main()
  {

    //Create the validating reader.
    XmlTextReader txtreader = new XmlTextReader("book1.xml");
    txtreader.WhitespaceHandling = WhitespaceHandling.None;
    XmlValidatingReader reader = new XmlValidatingReader(txtreader);
    reader.ValidationType = ValidationType.None;

    //Parse the file and each node and its value.
    while (reader.Read())
    {
      if (reader.HasValue)
        Console.WriteLine("({0})  {1}={2}", reader.NodeType, reader.Name, reader.Value);
      else
        Console.WriteLine("({0}) {1}", reader.NodeType, reader.Name);
                 
    }

    //Close the reader.
    reader.Close();
    
  }
} // End class


    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="IsDefaultTopic1"></a><a name="IsDefault">IsDefault</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the current node is an attribute that was generated from the default value defined in the DTD or schema.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Boolean.html">bool</a> IsDefault {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This property applies only to an attribute node.</dd>
</dl><b>Example</b><dl>
<dd> The following example displays all attributes nodes on the root element.<pre>
using System;
using System.IO;
using System.Xml;

public class Sample 
{
  public static void Main(){

    //Create the reader.
    XmlTextReader txtreader = new XmlTextReader("book4.xml");
    XmlValidatingReader reader = new XmlValidatingReader(txtreader);

    reader.MoveToContent();

    //Display each of the attribute nodes, including default attributes.
    while (reader.MoveToNextAttribute()){
        if (reader.IsDefault)
          Console.Write("(default attribute) ");
        Console.WriteLine("{0} = {1}", reader.Name, reader.Value);  
    }           
  
    //Close the reader.
    reader.Close();     
  
  }
} // End class

    </pre>
<p> The example uses the following files as input.</p>
<p><b>book4.xml</b></p>
<pre>
&lt;!DOCTYPE book SYSTEM 'book.dtd'&gt;
&lt;book ISBN = '1-861001-57-5'&gt;
  &lt;title&gt;Pride And Prejudice&lt;/title&gt;
  &lt;price&gt;19.95&lt;/price&gt;
&lt;/book&gt;

    </pre><b>book.dtd</b><pre>
&lt;!ELEMENT book (title,price)&gt; 
&lt;!ATTLIST book 
   genre CDATA "novel"
   ISBN CDATA #REQUIRED&gt;
&lt;!ELEMENT title (#PCDATA)&gt;
&lt;!ELEMENT price (#PCDATA)&gt;

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="IsEmptyElementTopic1"></a><a name="IsEmptyElement">IsEmptyElement</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the current node is an empty element (for example, <code>
                &lt;MyElement/&gt;
              </code>).</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Boolean.html">bool</a> IsEmptyElement {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This property enables you to determine the difference between the following: <p><code>
                &lt;item bar="123"/&gt;
              </code> (<b>IsEmptyElement</b> is <b>true</b>).</p>
<p><code>
                &lt;item bar="123"&gt;
              </code> (<b>IsEmptyElement</b> is <b>false</b>).</p>
<p> A corresponding <b>EndElement</b> node is not generated for empty elements.</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following example displays the text content of each element.<pre>
using System;
using System.IO;
using System.Xml;

public class Sample 
{
  public static void Main()
  {
    XmlTextReader txtreader = null;
    XmlValidatingReader reader = null;

    try
    {
       //Implement the readers.
       txtreader = new XmlTextReader("elems.xml");
       reader = new XmlValidatingReader(txtreader);
  
       //Parse the XML and display the text content of each of the elements.
       while (reader.Read()){
         if (reader.IsStartElement()){
           if (reader.IsEmptyElement)
              Console.WriteLine("&lt;{0}/&gt;", reader.Name);
           else{
               Console.Write("&lt;{0}&gt; ", reader.Name);
               reader.Read(); //Read the start tag.
               if (reader.IsStartElement())  //Handle nested elements.
                   Console.Write("\r\n&lt;{0}&gt;", reader.Name);
               Console.WriteLine(reader.ReadString());  //Read the text content of the element.
           }
         }
       } 
       
     } 

     finally 
     {
        if (reader != null)
          reader.Close();
      }
  }
  
} // End class

    </pre> The example uses the file, <b>elems.xml</b>, as input.<pre>
&lt;book&gt;
  &lt;title&gt;Pride And Prejudice&lt;/title&gt;
  &lt;price&gt;19.95&lt;/price&gt;
  &lt;misc/&gt;
&lt;/book&gt;

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Property: <i><a name="ItemTopic1"></a><a name="Item(System.Int32)">Item</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the value of the attribute with the specified index.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/String.html">string</a> this[int i] {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>i</i><br><dl>
<dd>
<param> The index of the attribute.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentOutOfRangeException.html">ArgumentOutOfRangeException</a></td>
<td> The <i>i</i> parameter is less than 0 or greater than or equal to  <a href="#AttributeCount">XmlValidatingReader.AttributeCount</a>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This property does not move the reader.</dd>
</dl><b>Example</b><dl>
<dd> The following example displays all attributes on the current node.<pre>
public void DisplayAttributes(XmlReader reader)
{
    if (reader.HasAttributes)
    {
        Console.WriteLine("Attributes of &lt;" + reader.Name + "&gt;");
        for (int i = 0; i &lt; reader.AttributeCount; i++)
        {
            Console.WriteLine("  {0}", reader[i]);
        }
    }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#GetAttribute(System.Int32)">XmlValidatingReader.GetAttribute</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Property: <i><a name="ItemTopic2"></a><a name="Item(System.String)">Item</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the value of the attribute with the specified name.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/String.html">string</a> this[string name] {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The qualified name of the attribute.
</dd>
</dl>
</p>
</dd>
</dl><b>Remarks</b><dl>
<dd> This property does not move the reader.<p> If the reader is positioned on a <b>DocumentType</b> node, this method can be used to get the PUBLIC and SYSTEM literals, for example, <code>
                reader["PUBLIC"]
              </code></p>
</dd>
</dl><b>Example</b><dl>
<dd> The following example reads the value of the ISBN attribute.<pre>
using System;
using System.IO;
using System.Xml;

public class Sample 
{
  public static void Main()
  {

    //Create the validating reader.
    XmlTextReader txtreader = new XmlTextReader("attrs.xml");
    XmlValidatingReader reader = new XmlValidatingReader(txtreader);

    //Read the ISBN attribute.
    reader.MoveToContent();
    string isbn =reader["ISBN"];
    Console.WriteLine("The ISBN value: " + isbn);

    //Close the reader.
    reader.Close();

  } 
} // End class

    </pre> The example uses the file, <b>attrs.xml</b>, as input.<pre>
&lt;book genre='novel' ISBN='1-861003-78' pubdate='1987'&gt;
&lt;/book&gt;

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#GetAttribute(System.Int32)">XmlValidatingReader.GetAttribute</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Property: <i><a name="ItemTopic3"></a><a name="Item(System.String,System.String)">Item</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the value of the attribute with the specified local name and namespace URI.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/String.html">string</a> this[string name, string namespaceURI] {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The local name of the attribute.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>namespaceURI</i><br><dl>
<dd>
<param> The namespace URI of the attribute.
</dd>
</dl>
</p>
</dd>
</dl><b>Remarks</b><dl>
<dd> This property does not move the reader.</dd>
</dl><b>See also: 
			</b><br> <a href="#GetAttribute(System.Int32)">XmlValidatingReader.GetAttribute</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="LocalNameTopic1"></a><a name="LocalName">LocalName</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the local name of the current node.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/String.html">string</a> LocalName {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd> The following example reads an XML fragment.<pre>
using System;
using System.IO;
using System.Xml;

public class Sample 
{
  public static void Main()
  {
    XmlValidatingReader reader = null;

    try
    {
       //Create the XML fragment to be parsed.
       string xmlFrag ="&lt;book&gt; " +
                       "&lt;title&gt;Pride And Prejudice&lt;/title&gt;" +
                       "&lt;bk:genre&gt;novel&lt;/bk:genre&gt;" +
                       "&lt;/book&gt;"; 

       //Create the XmlNamespaceManager that is used to
       //look up namespace information.
       NameTable nt = new NameTable();
       XmlNamespaceManager nsmgr = new XmlNamespaceManager(nt);
       nsmgr.AddNamespace("bk", "urn:sample");

       //Create the XmlParserContext.
       XmlParserContext context = new XmlParserContext(null, nsmgr, null, XmlSpace.None);

       //Implement the reader. 
       reader = new XmlValidatingReader(xmlFrag, XmlNodeType.Element, context);
  
       //Parse the XML fragment.  If they exist, display the   
       //prefix and namespace URI of each element.
       while (reader.Read()){
         if (reader.IsStartElement()){
           if (reader.Prefix==String.Empty)
              Console.WriteLine("&lt;{0}&gt;", reader.LocalName);
           else{
               Console.Write("&lt;{0}:{1}&gt;", reader.Prefix, reader.LocalName);
               Console.WriteLine(" The namespace URI is " + reader.NamespaceURI);
           }
         }
       }
       

     } 

     finally 
     {
        if (reader != null)
          reader.Close();
      }
  }
} // End class

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="NameTopic1"></a><a name="Name">Name</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the qualified name of the current node.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/String.html">string</a> Name {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd> The following example reads an XML file and displays each of the nodes.<pre>
using System;
using System.IO;
using System.Xml;

public class Sample
{
  private const String filename = "items.xml";

  public static void Main()
  {
     XmlTextReader txtreader = null;
     XmlValidatingReader reader = null;

     try
     {  
        //Load the reader with the data file and ignore all white space nodes.         
        txtreader = new XmlTextReader(filename);
        txtreader.WhitespaceHandling = WhitespaceHandling.None;

        //Implement the validating reader over the text reader. 
        reader = new XmlValidatingReader(txtreader);
        reader.ValidationType = ValidationType.None;

        //Parse the file and display each of the nodes.
        while (reader.Read())
        {
           switch (reader.NodeType)
           {
             case XmlNodeType.Element:
               Console.Write("&lt;{0}&gt;", reader.Name);
               break;
             case XmlNodeType.Text:
               Console.Write(reader.Value);
               break;
             case XmlNodeType.CDATA:
               Console.Write("&lt;![CDATA[{0}]]&gt;", reader.Value);
               break;
             case XmlNodeType.ProcessingInstruction:
               Console.Write("&lt;?{0} {1}?&gt;", reader.Name, reader.Value);
               break;
             case XmlNodeType.Comment:
               Console.Write("&lt;!--{0}--&gt;", reader.Value);
               break;
             case XmlNodeType.XmlDeclaration:
               Console.Write("&lt;?xml version='1.0'?&gt;");
               break;
             case XmlNodeType.Document:
               break;
             case XmlNodeType.DocumentType:
               Console.Write("&lt;!DOCTYPE {0} [{1}]", reader.Name, reader.Value);
               break;
             case XmlNodeType.EntityReference:
               Console.Write(reader.Name);
               break;
             case XmlNodeType.EndElement:
               Console.Write("&lt;/{0}&gt;", reader.Name);
               break;
           }       
        }           
     }

     finally
     {
        if (reader!=null)
          reader.Close();
     }
  }
} // End class

    </pre> The example uses the file, <b>items.xml</b>, as input.<pre>

&lt;?xml version="1.0"?&gt;
&lt;!-- This is a sample XML document --&gt;
&lt;!DOCTYPE Items [&lt;!ENTITY number "123"&gt;]&gt;
&lt;Items&gt;
  &lt;Item&gt;Test with an entity: &amp;number;&lt;/Item&gt;
  &lt;Item&gt;test with a child element &lt;more/&gt; stuff&lt;/Item&gt;
  &lt;Item&gt;test with a CDATA section &lt;![CDATA[&lt;456&gt;]]&gt; def&lt;/Item&gt;
  &lt;Item&gt;Test with a char entity: &amp;#65;&lt;/Item&gt;
  &lt;!-- Fourteen chars in this element.--&gt;
  &lt;Item&gt;1234567890ABCD&lt;/Item&gt;
&lt;/Items&gt;

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="NamespacesTopic1"></a><a name="Namespaces">Namespaces</a></i></b><b><i></i></b><b><font color="#008080"> (read-write)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets or sets a value indicating whether to do namespace support.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> Namespaces {get; set;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="NamespaceURITopic1"></a><a name="NamespaceURI">NamespaceURI</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the namespace URI (as defined in the W3C Namespace specification) of the node on which the reader is positioned.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/String.html">string</a> NamespaceURI {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This property is relevant to <b>Element</b> and <b>Attribute</b> nodes only.</dd>
</dl><b>Example</b><dl>
<dd> The following example reads an XML fragment.<pre>
using System;
using System.IO;
using System.Xml;

public class Sample 
{
  public static void Main()
  {
    XmlValidatingReader reader = null;

    try
    {
       //Create the XML fragment to be parsed.
       string xmlFrag ="&lt;book&gt; " +
                       "&lt;title&gt;Pride And Prejudice&lt;/title&gt;" +
                       "&lt;bk:genre&gt;novel&lt;/bk:genre&gt;" +
                       "&lt;/book&gt;"; 

       //Create the XmlNamespaceManager that is used to
       //look up namespace information.
       NameTable nt = new NameTable();
       XmlNamespaceManager nsmgr = new XmlNamespaceManager(nt);
       nsmgr.AddNamespace("bk", "urn:sample");

       //Create the XmlParserContext.
       XmlParserContext context = new XmlParserContext(null, nsmgr, null, XmlSpace.None);

       //Implement the reader. 
       reader = new XmlValidatingReader(xmlFrag, XmlNodeType.Element, context);
  
       //Parse the XML fragment.  If they exist, display the   
       //prefix and namespace URI of each element.
       while (reader.Read()){
         if (reader.IsStartElement()){
           if (reader.Prefix==String.Empty)
              Console.WriteLine("&lt;{0}&gt;", reader.LocalName);
           else{
               Console.Write("&lt;{0}:{1}&gt;", reader.Prefix, reader.LocalName);
               Console.WriteLine(" The namespace URI is " + reader.NamespaceURI);
           }
         }
       }
       

     } 

     finally 
     {
        if (reader != null)
          reader.Close();
      }
  }
} // End class

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="NameTableTopic1"></a><a name="NameTable">NameTable</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the  <a href="../../System.Xml/types/XmlNameTable.html">XmlNameTable</a> associated with this implementation.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Xml/types/XmlNameTable.html">XmlNameTable</a> NameTable {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> All node and attribute names returned from this class are atomized using the <b>NameTable</b>. When the same name is returned multiple times (for example, <b>Customer</b>), then the same <b>String</b> object will be returned for that name. This makes it possible for you to write efficient code that does object comparisons on these strings instead of expensive string comparisons.</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Xml/types/XmlNameTable.html">XmlNameTable</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="NodeTypeTopic1"></a><a name="NodeType">NodeType</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the type of the current node.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Xml/types/XmlNodeType.html">XmlNodeType</a> NodeType {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This property never returns the following <b>XmlNodeType</b> types: <b>Document</b>, <b>DocumentFragment</b>, <b>Entity</b>, or <b>Notation</b>.</dd>
</dl><b>Example</b><dl>
<dd> The following example reads an XML file and displays each of the nodes.<pre>
using System;
using System.IO;
using System.Xml;

public class Sample
{
  private const String filename = "items.xml";

  public static void Main()
  {
     XmlTextReader txtreader = null;
     XmlValidatingReader reader = null;

     try
     {  
        //Load the reader with the data file and ignore all white space nodes.         
        txtreader = new XmlTextReader(filename);
        txtreader.WhitespaceHandling = WhitespaceHandling.None;

        //Implement the validating reader over the text reader. 
        reader = new XmlValidatingReader(txtreader);
        reader.ValidationType = ValidationType.None;

        //Parse the file and display each of the nodes.
        while (reader.Read())
        {
           switch (reader.NodeType)
           {
             case XmlNodeType.Element:
               Console.Write("&lt;{0}&gt;", reader.Name);
               break;
             case XmlNodeType.Text:
               Console.Write(reader.Value);
               break;
             case XmlNodeType.CDATA:
               Console.Write("&lt;![CDATA[{0}]]&gt;", reader.Value);
               break;
             case XmlNodeType.ProcessingInstruction:
               Console.Write("&lt;?{0} {1}?&gt;", reader.Name, reader.Value);
               break;
             case XmlNodeType.Comment:
               Console.Write("&lt;!--{0}--&gt;", reader.Value);
               break;
             case XmlNodeType.XmlDeclaration:
               Console.Write("&lt;?xml version='1.0'?&gt;");
               break;
             case XmlNodeType.Document:
               break;
             case XmlNodeType.DocumentType:
               Console.Write("&lt;!DOCTYPE {0} [{1}]", reader.Name, reader.Value);
               break;
             case XmlNodeType.EntityReference:
               Console.Write(reader.Name);
               break;
             case XmlNodeType.EndElement:
               Console.Write("&lt;/{0}&gt;", reader.Name);
               break;
           }       
        }           
     }

     finally
     {
        if (reader!=null)
          reader.Close();
     }
  }
} // End class

    </pre> The example uses the file, <b>items.xml</b>, as input.<pre>

&lt;?xml version="1.0"?&gt;
&lt;!-- This is a sample XML document --&gt;
&lt;!DOCTYPE Items [&lt;!ENTITY number "123"&gt;]&gt;
&lt;Items&gt;
  &lt;Item&gt;Test with an entity: &amp;number;&lt;/Item&gt;
  &lt;Item&gt;test with a child element &lt;more/&gt; stuff&lt;/Item&gt;
  &lt;Item&gt;test with a CDATA section &lt;![CDATA[&lt;456&gt;]]&gt; def&lt;/Item&gt;
  &lt;Item&gt;Test with a char entity: &amp;#65;&lt;/Item&gt;
  &lt;!-- Fourteen chars in this element.--&gt;
  &lt;Item&gt;1234567890ABCD&lt;/Item&gt;
&lt;/Items&gt;

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="PrefixTopic1"></a><a name="Prefix">Prefix</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the namespace prefix associated with the current node.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/String.html">string</a> Prefix {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd> The following example reads an XML fragment.<pre>
using System;
using System.IO;
using System.Xml;

public class Sample 
{
  public static void Main()
  {
    XmlValidatingReader reader = null;

    try
    {
       //Create the XML fragment to be parsed.
       string xmlFrag ="&lt;book&gt; " +
                       "&lt;title&gt;Pride And Prejudice&lt;/title&gt;" +
                       "&lt;bk:genre&gt;novel&lt;/bk:genre&gt;" +
                       "&lt;/book&gt;"; 

       //Create the XmlNamespaceManager that is used to
       //look up namespace information.
       NameTable nt = new NameTable();
       XmlNamespaceManager nsmgr = new XmlNamespaceManager(nt);
       nsmgr.AddNamespace("bk", "urn:sample");

       //Create the XmlParserContext.
       XmlParserContext context = new XmlParserContext(null, nsmgr, null, XmlSpace.None);

       //Implement the reader. 
       reader = new XmlValidatingReader(xmlFrag, XmlNodeType.Element, context);
  
       //Parse the XML fragment.  If they exist, display the   
       //prefix and namespace URI of each element.
       while (reader.Read()){
         if (reader.IsStartElement()){
           if (reader.Prefix==String.Empty)
              Console.WriteLine("&lt;{0}&gt;", reader.LocalName);
           else{
               Console.Write("&lt;{0}:{1}&gt;", reader.Prefix, reader.LocalName);
               Console.WriteLine(" The namespace URI is " + reader.NamespaceURI);
           }
         }
       }
       

     } 

     finally 
     {
        if (reader != null)
          reader.Close();
      }
  }
} // End class

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="QuoteCharTopic1"></a><a name="QuoteChar">QuoteChar</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the quotation mark character used to enclose the value of an attribute node.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Char.html">char</a> QuoteChar {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This property applies only to an attribute node.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="ReaderTopic1"></a><a name="Reader">Reader</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the  <a href="../../System.Xml/types/XmlReader.html">XmlReader</a> used to construct this <b>XmlValidatingReader</b>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Xml/types/XmlReader.html">XmlReader</a> Reader {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This property allows the user to access properties specific to the supplied reader. It returns a typed <b>XmlReader</b>. The user should query for the type before casting.<p> Changing the state of the returned reader (for example, calling one of the read methods) can lead to unpredictable results.</p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="ReadStateTopic1"></a><a name="ReadState">ReadState</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the state of the reader.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Xml/types/ReadState.html">ReadState</a> ReadState {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="SchemasTopic1"></a><a name="Schemas">Schemas</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a  <a href="../../System.Xml.Schema/types/XmlSchemaCollection.html">XmlSchemaCollection</a> to use for validation.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Xml.Schema/types/XmlSchemaCollection.html">XmlSchemaCollection</a> Schemas {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The <b>XmlSchemaCollection</b> holds pre-loaded XML-Data Reduced (XDR) and XML Schema definition language (XSD) schemas. This property gives the reader access to the cache of schemas and allows it to validate without having to re-load schemas every time. The reader does not add anything to the <b>XmlSchemaCollection</b>.<p> If the <b>XmlSchemaCollection</b> includes an XML schema (XSD) which contains <b>include</b> or <b>import</b> elements that reference other namespaces, the schemas for these other namespaces are loaded for validation purposes only. Unless these schemas were explicitly added to the schema collection, they will not be accessible using any of the collection methods or properties. For example, if the collection contains the schema file <b>a.xsd</b> which contains a reference to the schema file <b>b.xsd</b>, you must add <b>b.xsd</b> to the schema collection before you can access it using any of the collection methods or properties.</p><br><br><b>Note </b> The schemas must be added to the <b>XmlSchemaCollection</b> before the first <b>Read</b> call.<p> For more information, refer to  the conceptual topic at <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconValidationOfXMLWithXmlValidatingReader.asp">MSDN: validationofxmlwithxmlvalidatingreader</a>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following example validates three XML files using schemas stored in the XmlSchemaCollection.<pre>

 
 
 using System;
 using System.IO;
 using System.Xml;
 using System.Xml.Schema;
 
 public class SchemaCollectionSample
 {
   private const String doc1 = "booksSchema.xml";
   private const String doc2 = "booksSchemaFail.xml";
   private const String doc3 = "newbooks.xml";
   private const String schema = "books.xsd";
   private const String schema1 = "schema1.xdr";
   
   private XmlTextReader reader=null;
   private XmlValidatingReader vreader = null;
   private Boolean m_success = true;
 
   public SchemaCollectionSample ()
   {
     //Load the schema collection.
     XmlSchemaCollection xsc = new XmlSchemaCollection();
     xsc.Add("urn:bookstore-schema", schema);  //XSD schema
     xsc.Add("urn:newbooks-schema", schema1);  //XDR schema
 
     //Validate the files using schemas stored in the collection.
     Validate(doc1, xsc); //Should pass.
     Validate(doc2, xsc); //Should fail.   
     Validate(doc3, xsc); //Should fail. 
 
   }    
 
   public static void Main ()
   {
       SchemaCollectionSample validation = new SchemaCollectionSample();
   }
 
   private void Validate(String filename, XmlSchemaCollection xsc)
   {
    
      m_success = true;
      Console.WriteLine();
      Console.WriteLine("Validating XML file {0}...", filename.ToString());
      reader = new XmlTextReader (filename);
         
      //Create a validating reader.
     vreader = new XmlValidatingReader (reader);

      //Validate using the schemas stored in the schema collection.
      vreader.Schemas.Add(xsc);
  
      //Set the validation event handler
      vreader.ValidationEventHandler += new ValidationEventHandler (ValidationCallBack);
      //Read and validate the XML data.
      while (vreader.Read()){}
      Console.WriteLine ("Validation finished. Validation {0}", (m_success==true ? "successful" : "failed"));
      Console.WriteLine();

      //Close the reader.
      vreader.Close();
 
   } 
 
 
   public void ValidationCallBack (object sender, ValidationEventArgs args)
   {
      m_success = false;
 
      Console.Write("\r\n\tValidation error: " + args.Message);

   }  
 }

    </pre>
<p> The sample uses the following five input files: </p>
<p><b>booksSchema.xml</b></p>
<pre>

&lt;?xml version='1.0'?&gt;
 &lt;bookstore xmlns="urn:bookstore-schema"&gt;
   &lt;book genre="autobiography"&gt;
     &lt;title&gt;The Autobiography of Benjamin Franklin&lt;/title&gt;
     &lt;author&gt;
       &lt;first-name&gt;Benjamin&lt;/first-name&gt;
       &lt;last-name&gt;Franklin&lt;/last-name&gt;
     &lt;/author&gt;
     &lt;price&gt;8.99&lt;/price&gt;
   &lt;/book&gt;
   &lt;book genre="novel"&gt;
     &lt;title&gt;The Confidence Man&lt;/title&gt;
     &lt;author&gt;
       &lt;first-name&gt;Herman&lt;/first-name&gt;
       &lt;last-name&gt;Melville&lt;/last-name&gt;
     &lt;/author&gt;
     &lt;price&gt;11.99&lt;/price&gt;
   &lt;/book&gt;
 &lt;/bookstore&gt;

    </pre>
<p><b>booksSchemaFail.xml</b></p>
<pre>

&lt;?xml version='1.0'?&gt;
 &lt;bookstore xmlns="urn:bookstore-schema"&gt;
   &lt;book&gt;
     &lt;author&gt;
       &lt;first-name&gt;Benjamin&lt;/first-name&gt;
       &lt;last-name&gt;Franklin&lt;/last-name&gt;
     &lt;/author&gt;
   &lt;/book&gt;
   &lt;book genre="novel"&gt;
     &lt;title&gt;The Confidence Man&lt;/title&gt;
     &lt;author&gt;
       &lt;first-name&gt;Herman&lt;/first-name&gt;
       &lt;last-name&gt;Melville&lt;/last-name&gt;
     &lt;/author&gt;
     &lt;price&gt;11.99&lt;/price&gt;
   &lt;/book&gt;
   &lt;book genre="philosophy"&gt;
     &lt;title&gt;The Gorgias&lt;/title&gt;
     &lt;author&gt;
       &lt;name&gt;Plato&lt;/name&gt;
     &lt;/author&gt;
     &lt;price&gt;9.99&lt;/price&gt;
   &lt;/book&gt;
 &lt;/bookstore&gt;

    </pre>
<p><b>newbooks.xml</b></p>
<pre>

&lt;?xml version='1.0'?&gt;
&lt;bookstore xmlns="urn:newbooks-schema"&gt;
  &lt;book genre="novel" style="hardcover"&gt;
    &lt;title&gt;The Handmaid's Tale&lt;/title&gt;
    &lt;author&gt;
      &lt;first-name&gt;Margaret&lt;/first-name&gt;
      &lt;last-name&gt;Atwood&lt;/last-name&gt;
    &lt;/author&gt;
    &lt;price&gt;19.95&lt;/price&gt;
  &lt;/book&gt;
  &lt;book genre="novel" style="other"&gt;
    &lt;title&gt;The Poisonwood Bible&lt;/title&gt;
    &lt;author&gt;
      &lt;first-name&gt;Barbara&lt;/first-name&gt;
      &lt;last-name&gt;Kingsolver&lt;/last-name&gt;
    &lt;/author&gt;
    &lt;price&gt;11.99&lt;/price&gt;
  &lt;/book&gt;
&lt;/bookstore&gt;

    </pre>
<p><b>books.xsd</b></p>
<pre>

&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
     xmlns="urn:bookstore-schema"
     elementFormDefault="qualified"
     targetNamespace="urn:bookstore-schema"&gt;
 
  &lt;xsd:element name="bookstore" type="bookstoreType"/&gt;
 
  &lt;xsd:complexType name="bookstoreType"&gt;
   &lt;xsd:sequence maxOccurs="unbounded"&gt;
    &lt;xsd:element name="book"  type="bookType"/&gt;
   &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
 
  &lt;xsd:complexType name="bookType"&gt;
   &lt;xsd:sequence&gt;
    &lt;xsd:element name="title" type="xsd:string"/&gt;
    &lt;xsd:element name="author" type="authorName"/&gt;
    &lt;xsd:element name="price"  type="xsd:decimal"/&gt;
   &lt;/xsd:sequence&gt;
   &lt;xsd:attribute name="genre" type="xsd:string"/&gt;
  &lt;/xsd:complexType&gt;
 
  &lt;xsd:complexType name="authorName"&gt;
   &lt;xsd:sequence&gt;
    &lt;xsd:element name="first-name"  type="xsd:string"/&gt;
    &lt;xsd:element name="last-name" type="xsd:string"/&gt;
   &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
 
 &lt;/xsd:schema&gt;

    </pre>
<p><b>schema1.xdr</b></p>
<pre>

&lt;?xml version="1.0"?&gt;
&lt;Schema xmlns="urn:schemas-microsoft-com:xml-data"
        xmlns:dt="urn:schemas-microsoft-com:datatypes"&gt;
  &lt;ElementType name="first-name" content="textOnly"/&gt;
  &lt;ElementType name="last-name" content="textOnly"/&gt;
  &lt;ElementType name="name" content="textOnly"/&gt;
  &lt;ElementType name="price" content="textOnly" dt:type="fixed.14.4"/&gt;
  &lt;ElementType name="author" content="eltOnly" order="one"&gt;
    &lt;group order="seq"&gt;
      &lt;element type="name"/&gt;
    &lt;/group&gt;
    &lt;group order="seq"&gt;
      &lt;element type="first-name"/&gt;
      &lt;element type="last-name"/&gt;
    &lt;/group&gt;
  &lt;/ElementType&gt;
  &lt;ElementType name="title" content="textOnly"/&gt;
  &lt;AttributeType name="genre" dt:type="string"/&gt;
  &lt;AttributeType name="style" dt:type="enumeration"
        dt:values="paperback hardcover"/&gt;
  &lt;ElementType name="book" content="eltOnly"&gt;
    &lt;attribute type="genre" required="yes"/&gt;
    &lt;attribute type="style" required="yes"/&gt;
    &lt;element type="title"/&gt;
    &lt;element type="author"/&gt;
    &lt;element type="price"/&gt;
  &lt;/ElementType&gt;
  &lt;ElementType name="bookstore" content="eltOnly"&gt;
    &lt;element type="book"/&gt;
  &lt;/ElementType&gt;
&lt;/Schema&gt;

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="SchemaTypeTopic1"></a><a name="SchemaType">SchemaType</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a schema type object.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Object.html">object</a> SchemaType {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The user needs to test for the returned type. For example <pre>
              object obj = vreader.SchemaType;
              if (obj is XmlSchemaType)
              {
                XmlSchemaType st = (XmlSchemaType)obj;
                // use XmlSchemaType object
              }
              if (obj is XmlSchemaDatatype)
              {
                XmlSchemaDatatype sd = (XmlSchemaDatatype)obj;
                Type vt = sd.ValueType;
                // use XmlSchemaDatatype object
              }
                 
            </pre>
<p> If XML Schema (XSD) validation is being performed then the <b>XmlSchemaType</b> or <b>XmlSchemaDatatype</b> corresponds to the current element being read. If DTD validation is being performed this property returns <b>null</b>.</p>
<p><b>XmlSchemaDatatype</b> is returned if the current element, or attribute, is a simple type which can specify special validation constraints on the simple types, like min and max.</p>
<p><b>XmlSchemaSimpleType</b> is returned if the current element, or attribute, is a user defined simpleType.</p>
<p><b>XmlSchemaComplexType</b> is returned if the current element is a user defined complexType. This type cannot be returned by attributes.</p><br><br><b>Note </b> If  <a href="#ValidationType">XmlValidatingReader.ValidationType</a> has been set to ValidationType.None, no data type information is provided from either schemas or DTDs.</dd>
</dl><b>Example</b><dl>
<dd> The following example displays the type information for each of the elements in the XML document.<pre>
using System;
using System.IO;
using System.Xml;
using System.Xml.Schema;

public class Sample{

  public static void Main(){
  
  XmlTextReader tr = new XmlTextReader("booksSchema.xml");
  XmlValidatingReader vr = new XmlValidatingReader(tr);
 
  vr.Schemas.Add(null, "books.xsd");
  vr.ValidationType = ValidationType.Schema;
  vr.ValidationEventHandler += new ValidationEventHandler (ValidationCallBack);
 
  while(vr.Read()){
    if(vr.NodeType == XmlNodeType.Element){
      if(vr.SchemaType is XmlSchemaComplexType){
        XmlSchemaComplexType sct = (XmlSchemaComplexType)vr.SchemaType;
        Console.WriteLine("{0}({1})", vr.Name, sct.Name);
      }
      else{
        object value = vr.ReadTypedValue();
        Console.WriteLine("{0}({1}):{2}", vr.Name, value.GetType().Name, value);
      }
    }
  }
 }

  public static void ValidationCallBack (object sender, ValidationEventArgs args){
    Console.WriteLine("***Validation error");
    Console.WriteLine("\tSeverity:{0}", args.Severity);
    Console.WriteLine("\tMessage  :{0}", args.Message);
  }
}

    </pre>
<p> The example uses the following input files.</p>
<p><b>booksSchema.xml</b></p>
<pre>
&lt;?xml version='1.0'?&gt;
&lt;bookstore xmlns="urn:bookstore-schema"&gt;
  &lt;book genre="autobiography"&gt;
    &lt;title&gt;The Autobiography of Benjamin Franklin&lt;/title&gt;
    &lt;author&gt;
      &lt;first-name&gt;Benjamin&lt;/first-name&gt;
      &lt;last-name&gt;Franklin&lt;/last-name&gt;
    &lt;/author&gt;
    &lt;price&gt;8.99&lt;/price&gt;
  &lt;/book&gt;
  &lt;book genre="novel"&gt;
    &lt;title&gt;The Confidence Man&lt;/title&gt;
    &lt;author&gt;
      &lt;first-name&gt;Herman&lt;/first-name&gt;
      &lt;last-name&gt;Melville&lt;/last-name&gt;
    &lt;/author&gt;
    &lt;price&gt;11.99&lt;/price&gt;
  &lt;/book&gt;
&lt;/bookstore&gt;

    </pre><b>books.xsd</b><pre>
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns="urn:bookstore-schema"
    elementFormDefault="qualified"
    targetNamespace="urn:bookstore-schema"&gt;

 &lt;xsd:element name="bookstore" type="bookstoreType"/&gt;

 &lt;xsd:complexType name="bookstoreType"&gt;
  &lt;xsd:sequence maxOccurs="unbounded"&gt;
   &lt;xsd:element name="book"  type="bookType"/&gt;
  &lt;/xsd:sequence&gt;
 &lt;/xsd:complexType&gt;

 &lt;xsd:complexType name="bookType"&gt;
  &lt;xsd:sequence&gt;
   &lt;xsd:element name="title" type="xsd:string"/&gt;
   &lt;xsd:element name="author" type="authorName"/&gt;
   &lt;xsd:element name="price"  type="xsd:decimal"/&gt;
  &lt;/xsd:sequence&gt;
  &lt;xsd:attribute name="genre" type="xsd:string"/&gt;
 &lt;/xsd:complexType&gt;

 &lt;xsd:complexType name="authorName"&gt;
  &lt;xsd:sequence&gt;
   &lt;xsd:element name="first-name"  type="xsd:string"/&gt;
   &lt;xsd:element name="last-name" type="xsd:string"/&gt;
  &lt;/xsd:sequence&gt;
 &lt;/xsd:complexType&gt;

&lt;/xsd:schema&gt;

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="ValidationTypeTopic1"></a><a name="ValidationType">ValidationType</a></i></b><b><i></i></b><b><font color="#008080"> (read-write)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value describing what type of validation to perform.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Xml/types/ValidationType.html">ValidationType</a> ValidationType {get; set;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/InvalidOperationException.html">InvalidOperationException</a></td>
<td> Setting the property after a Read has been called.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This property must be set before the first call to  <a href="#Read">XmlValidatingReader.Read</a>. Setting this property to ValidationType.None creates a non-validating reader.<p> If external DTDs or schemas are needed for validation, the  <a href="../../System.Xml/types/XmlResolver.html">XmlResolver</a> is used.</p>
<p> For more information, refer to  the conceptual topic at <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconValidationOfXMLWithXmlValidatingReader.asp">MSDN: validationofxmlwithxmlvalidatingreader</a>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following example validates two files.<pre>
using System;
using System.IO;
using System.Xml;
using System.Xml.Schema;

public class Sample
{
  private const String doc1 = "notValid.xml";
  private const String doc2 = "cdDTD.xml";
  private const String doc3 = "book1.xml";

  private XmlTextReader txtreader = null;
  private XmlValidatingReader reader = null;
  private Boolean m_success = true;

  public Sample ()
  {
      //Parse the files and validate when requested.
      Validate(doc1, ValidationType.XDR);  //Validation should fail.
      Validate(doc2, ValidationType.DTD);  //Validation should fail.
      Validate(doc3, ValidationType.None); //No validation performed.

  }    

  public static void Main ()
  {
      Sample validation = new Sample();
  }

  private void Validate(String filename, ValidationType vt)
  {
    try
    {    
        //Implement the readers.  Set the ValidationType.
        txtreader = new XmlTextReader(filename);
        reader = new XmlValidatingReader(txtreader);
        reader.ValidationType = vt;

        //If the reader is set to validate, set the event handler.
        if (vt==ValidationType.None)
           Console.WriteLine("\nParsing XML file " + filename.ToString());
        else{
           Console.WriteLine("\nValidating XML file " + filename.ToString());
           m_success = true;
           //Set the validation event handler.
           reader.ValidationEventHandler += new ValidationEventHandler (ValidationCallBack);
        }

        // Read XML data
        while (reader.Read()){}

        if (vt==ValidationType.None)
           Console.WriteLine("Finished parsing file.");
        else
          Console.WriteLine ("Validation finished. Validation {0}", (m_success==true ? "successful" : "failed"));
     }

     finally
     {
        //Close the reader.
        if (reader != null)
          reader.Close();
     } 

  }
  
  //Display the validation errors.
  public void ValidationCallBack (object sender, ValidationEventArgs args)
  {
     m_success = false;

     Console.Write("\r\n\tValidation error: " + args.Message);

  }
}

    </pre>
<p> The sample uses the following four input files: </p>
<p><b>notValid.xml</b> (Note: The "x-schema:" prefix identifies the XDR schema for the reader.) </p>
<pre>

&lt;?xml version='1.0'?&gt;
&lt;bookstore xmlns="x-schema:schema1.xdr"&gt;
  &lt;book genre="novel" style="hardcover"&gt;
    &lt;title&gt;The Handmaid's Tale&lt;/title&gt;
    &lt;author&gt;
      &lt;first-name&gt;Margaret&lt;/first-name&gt;
      &lt;last-name&gt;Atwood&lt;/last-name&gt;
    &lt;/author&gt;
    &lt;price&gt;19.95&lt;/price&gt;
  &lt;/book&gt;
  &lt;book genre="novel" style="other"&gt;
    &lt;title&gt;The Poisonwood Bible&lt;/title&gt;
    &lt;author&gt;
      &lt;first-name&gt;Barbara&lt;/first-name&gt;
      &lt;last-name&gt;Kingsolver&lt;/last-name&gt;
    &lt;/author&gt;
    &lt;price&gt;11.99&lt;/price&gt;
  &lt;/book&gt;
&lt;/bookstore&gt;

    </pre>
<p><b>schema1.xdr</b></p>
<pre>

&lt;?xml version="1.0"?&gt;
 &lt;Schema xmlns="urn:schemas-microsoft-com:xml-data"
         xmlns:dt="urn:schemas-microsoft-com:datatypes"&gt;
   &lt;ElementType name="first-name" content="textOnly"/&gt;
   &lt;ElementType name="last-name" content="textOnly"/&gt;
   &lt;ElementType name="name" content="textOnly"/&gt;
   &lt;ElementType name="price" content="textOnly" dt:type="fixed.14.4"/&gt;
   &lt;ElementType name="author" content="eltOnly" order="one"&gt;
     &lt;group order="seq"&gt;
       &lt;element type="name"/&gt;
     &lt;/group&gt;
     &lt;group order="seq"&gt;
       &lt;element type="first-name"/&gt;
       &lt;element type="last-name"/&gt;
     &lt;/group&gt;
   &lt;/ElementType&gt;
   &lt;ElementType name="title" content="textOnly"/&gt;
   &lt;AttributeType name="genre" dt:type="string"/&gt;
   &lt;AttributeType name="style" dt:type="enumeration"
         dt:values="paperback hardcover"/&gt;
   &lt;ElementType name="book" content="eltOnly"&gt;
     &lt;attribute type="genre" required="yes"/&gt;
     &lt;attribute type="style" required="yes"/&gt;
     &lt;element type="title"/&gt;
     &lt;element type="author"/&gt;
     &lt;element type="price"/&gt;
   &lt;/ElementType&gt;
   &lt;ElementType name="bookstore" content="eltOnly"&gt;
     &lt;element type="book"/&gt;
   &lt;/ElementType&gt;
 &lt;/Schema&gt;

    </pre>
<p><b>cdDTD.xml</b></p>
<pre>

&lt;!--XML file using a DTD--&gt;
&lt;!DOCTYPE bookstore [
  &lt;!ELEMENT bookstore (cd)*&gt; 
  &lt;!ELEMENT cd (title,artist,price)&gt;
  &lt;!ATTLIST cd genre CDATA #REQUIRED&gt;
  &lt;!ELEMENT title (#PCDATA)&gt;
  &lt;!ELEMENT artist (#PCDATA)&gt;
  &lt;!ELEMENT price (#PCDATA)&gt;]&gt;
&lt;bookstore&gt;
  &lt;cd genre="alternative"  ISBN="2-3631-4"&gt;
    &lt;title&gt;Americana&lt;/title&gt;
    &lt;artist&gt;Offspring&lt;/artist&gt;
    &lt;price&gt;16.95&lt;/price&gt;
  &lt;/cd&gt;
&lt;/bookstore&gt;

    </pre><b>book1.xml</b><pre>

&lt;?xml version='1.0' ?&gt;
&lt;!DOCTYPE book [&lt;!ENTITY h 'hardcover'&gt;]&gt;
&lt;book&gt;
  &lt;title&gt;Pride And Prejudice&lt;/title&gt;
  &lt;misc&gt;&amp;h;&lt;/misc&gt;
&lt;/book&gt;

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="ValueTopic1"></a><a name="Value">Value</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the text value of the current node.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/String.html">string</a> Value {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd> The following example reads an XML file and displays each node.<pre>
using System;
using System.IO;
using System.Xml;

public class Sample
{
  private const String filename = "items.xml";

  public static void Main()
  {
     XmlTextReader txtreader = null;
     XmlValidatingReader reader = null;

     try
     {  
        //Load the reader with the data file and ignore all white space nodes.         
        txtreader = new XmlTextReader(filename);
        txtreader.WhitespaceHandling = WhitespaceHandling.None;

        //Implement the validating reader over the text reader. 
        reader = new XmlValidatingReader(txtreader);
        reader.ValidationType = ValidationType.None;

        //Parse the file and display each of the nodes.
        while (reader.Read())
        {
           switch (reader.NodeType)
           {
             case XmlNodeType.Element:
               Console.Write("&lt;{0}&gt;", reader.Name);
               break;
             case XmlNodeType.Text:
               Console.Write(reader.Value);
               break;
             case XmlNodeType.CDATA:
               Console.Write("&lt;![CDATA[{0}]]&gt;", reader.Value);
               break;
             case XmlNodeType.ProcessingInstruction:
               Console.Write("&lt;?{0} {1}?&gt;", reader.Name, reader.Value);
               break;
             case XmlNodeType.Comment:
               Console.Write("&lt;!--{0}--&gt;", reader.Value);
               break;
             case XmlNodeType.XmlDeclaration:
               Console.Write("&lt;?xml version='1.0'?&gt;");
               break;
             case XmlNodeType.Document:
               break;
             case XmlNodeType.DocumentType:
               Console.Write("&lt;!DOCTYPE {0} [{1}]", reader.Name, reader.Value);
               break;
             case XmlNodeType.EntityReference:
               Console.Write(reader.Name);
               break;
             case XmlNodeType.EndElement:
               Console.Write("&lt;/{0}&gt;", reader.Name);
               break;
           }       
        }           
     }

     finally
     {
        if (reader!=null)
          reader.Close();
     }
  }
} // End class

    </pre> The example uses the file, <b>items.xml</b>, as input.<pre>

&lt;?xml version="1.0"?&gt;
&lt;!-- This is a sample XML document --&gt;
&lt;!DOCTYPE Items [&lt;!ENTITY number "123"&gt;]&gt;
&lt;Items&gt;
  &lt;Item&gt;Test with an entity: &amp;number;&lt;/Item&gt;
  &lt;Item&gt;test with a child element &lt;more/&gt; stuff&lt;/Item&gt;
  &lt;Item&gt;test with a CDATA section &lt;![CDATA[&lt;456&gt;]]&gt; def&lt;/Item&gt;
  &lt;Item&gt;Test with a char entity: &amp;#65;&lt;/Item&gt;
  &lt;!-- Fourteen chars in this element.--&gt;
  &lt;Item&gt;1234567890ABCD&lt;/Item&gt;
&lt;/Items&gt;

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="XmlLangTopic1"></a><a name="XmlLang">XmlLang</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the current <b>xml:lang</b> scope.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/String.html">string</a> XmlLang {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This property represents the xml:lang scope within which the current node resides. For example, here is an XML fragment with <b>xml:lang</b> set to US English in the root element: <p> &lt;root xml:lang="en-us"&gt; </p>
<p> &lt;name&gt;Fred&lt;/name&gt; </p>
<p> &lt;/root&gt; </p>
<p> When the reader is positioned on the <b>name</b> element, you can use this property to find that it is in the scope of a US English <b>xml:lang</b> attribute.</p>
<p> The string returned is also in  <a href="#NameTable">XmlValidatingReader.NameTable</a>.</p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="XmlResolverTopic1"></a><a name="XmlResolver">XmlResolver</a></i></b><b><i></i></b><b><font color="#008080"> (write-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Sets the  <a href="../../System.Xml/types/XmlResolver.html">XmlResolver</a> used for resolving external DTD and schema location references. The <b>XmlResolver</b> is also used to handle any import or include elements found in XML Schema definition language (XSD) schemas.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            <a href="../../System.Xml/types/XmlResolver.html">XmlResolver</a> XmlResolver {set;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The <b>XmlResolver</b> is used to load any DTDs, entities or schemas needed to complete the validation process.<p> The reader uses the  <a href="../../System.Xml/types/XmlUrlResolver.html">XmlUrlResolver</a> by default. However, if you have implemented a custom <b>XmlResolver</b>, you can specify the use of your custom <b>XmlResolver</b> instead.</p>
<p> This property can be set at any time and takes affect after the next  <a href="#Read">XmlValidatingReader.Read</a> call. If this property is set to <b>null</b>, the reader assumes the user is not interested in resolving external references. In this case, the reader only validates against internal resources, if the resource is present.</p>
<p> When validating using XML-Data Reduced (XDR) or XML Schema (XSD), you can avoid the expensive load process by providing an  <a href="../../System.Xml.Schema/types/XmlSchemaCollection.html">XmlSchemaCollection</a> using the  <a href="#Schemas">XmlValidatingReader.Schemas</a> property.</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following example uses the <b>XmlResolver</b> property to specify the credentials necessary to access the networked DTD file.<pre>
using System;
using System.IO;
using System.Xml;
using System.Net;

public class Sample 
{
  public static void Main(){

    //Create the reader.
    XmlTextReader txtreader = new XmlTextReader("book5.xml");
    XmlValidatingReader reader = new XmlValidatingReader(txtreader);
    txtreader.WhitespaceHandling = WhitespaceHandling.None;

    //Set the credentials necessary to access the DTD file stored on the network.
    XmlUrlResolver resolver = new XmlUrlResolver();
    NetworkCredential nc = new NetworkCredential("username","password","domain");
    resolver.Credentials = nc;
    reader.XmlResolver = resolver;

    //Display each of the element nodes.
    while (reader.Read()){
       switch (reader.NodeType){
         case XmlNodeType.Element:
           Console.Write("&lt;{0}&gt;", reader.Name);
           break;
         case XmlNodeType.Text:
           Console.Write(reader.Value);
           break;
         case XmlNodeType.DocumentType:
           Console.Write("&lt;!DOCTYPE {0} [{1}]", reader.Name, reader.Value);
           break;
         case XmlNodeType.EntityReference:
           Console.Write(reader.Name);
           break;
         case XmlNodeType.EndElement:
           Console.Write("&lt;/{0}&gt;", reader.Name);
           break;
      }        
    }           
  
    //Close the reader.
    reader.Close();       
  }
} // End class

    </pre>
<p> The example uses the following files as input.</p>
<p><b>book5.xml</b></p>
<pre>
&lt;!DOCTYPE book SYSTEM 'http://myServer/DTDs/books.dtd'&gt;
&lt;book ISBN = '1-861001-57-5'&gt;
  &lt;title&gt;Pride And Prejudice&lt;/title&gt;
  &lt;price&gt;19.95&lt;/price&gt;
  &lt;misc&gt;&amp;h;&lt;/misc&gt;
&lt;/book&gt;

    </pre><b>books.dtd</b><pre>
&lt;!ELEMENT book (title,price,misc)&gt; 
&lt;!ATTLIST book 
   genre CDATA "novel"
   ISBN CDATA #REQUIRED&gt;
&lt;!ELEMENT title (#PCDATA)&gt;
&lt;!ELEMENT price (#PCDATA)&gt;
&lt;!ELEMENT misc (#PCDATA)&gt;
&lt;!ENTITY h "hardcover"&gt;
&lt;!ENTITY p "paperback"&gt;

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="XmlSpaceTopic1"></a><a name="XmlSpace">XmlSpace</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the current <b>xml:space</b> scope.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Xml/types/XmlSpace.html">XmlSpace</a> XmlSpace {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="CloseTopic1"></a><a name="Close">Close</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Changes the  <a href="../../System.Xml/types/XmlReader.html#ReadState">XmlReader.ReadState</a> to Closed.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override void Close();</b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This method also releases any resources held while reading. If this reader was constructed using an  <a href="../../System.Xml/types/XmlTextReader.html">XmlTextReader</a>, this method also calls <b>Close</b> on the underlying reader. If this reader was constructed using a stream, this method also calls <b>Close</b> on the underlying stream.<p> If <b>Close</b> has already been called, no action is performed.</p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="EqualsTopic1"></a><a name="Equals(System.Object)">Equals</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>obj</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#Equals(System.Object)">System.Object.Equals</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/Boolean.html">bool</a> Equals(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>obj</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="FinalizeTopic1"></a><a name="Finalize">Finalize</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#Finalize">System.Object.Finalize</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            ~XmlValidatingReader();</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetAttributeTopic1"></a><a name="GetAttribute(System.Int32)">GetAttribute</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Int32.html">int</a> <i>i</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Gets the value of the attribute with the specified index.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/String.html">string</a> GetAttribute(<br>   <font color="#008080"><a href="../../System/types/Int32.html">int</a> <i>i</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>i</i><br><dl>
<dd>
<param> The index of the attribute. The index is zero-based. (The first attribute has index 0.) 
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The value of the specified attribute.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentOutOfRangeException.html">ArgumentOutOfRangeException</a></td>
<td> The <i>i</i> parameter is less than 0 or greater than or equal to  <a href="#AttributeCount">XmlValidatingReader.AttributeCount</a>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This method does not move the reader.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetAttributeTopic2"></a><a name="GetAttribute(System.String)">GetAttribute</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Gets the value of the attribute with the specified name.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/String.html">string</a> GetAttribute(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The qualified name of the attribute.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The value of the specified attribute. If the attribute is not found, String.Empty is returned.</dd>
</dl><b>Remarks</b><dl>
<dd> This method does not move the reader.<p> If the reader is positioned on a <b>DocumentType</b> node, this method can be used to get the PUBLIC and SYSTEM literals, for example, <code>
                reader.GetAttribute("PUBLIC")
              </code></p>
</dd>
</dl><b>Example</b><dl>
<dd> The following example gets the value of the ISBN attribute.<pre>
using System;
using System.IO;
using System.Xml;

public class Sample 
{
  public static void Main()
  {

    //Create the validating reader.
    XmlTextReader txtreader = new XmlTextReader("attrs.xml");
    XmlValidatingReader reader = new XmlValidatingReader(txtreader);

    //Read the ISBN attribute.
    reader.MoveToContent();
    string isbn = reader.GetAttribute("ISBN");
    Console.WriteLine("The ISBN value: " + isbn);

    //Close the reader.
    reader.Close();

  } 
} // End class

    </pre> The example uses the file, <b>attrs.xml</b>, as input.<pre>
&lt;book genre='novel' ISBN='1-861003-78' pubdate='1987'&gt;
&lt;/book&gt;

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetAttributeTopic3"></a><a name="GetAttribute(System.String,System.String)">GetAttribute</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>localName</i>,</font><br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>namespaceURI</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Gets the value of the attribute with the specified local name and namespace URI.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/String.html">string</a> GetAttribute(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>localName</i>,</font><br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>namespaceURI</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>localName</i><br><dl>
<dd>
<param> The local name of the attribute.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>namespaceURI</i><br><dl>
<dd>
<param> The namespace URI of the attribute.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The value of the specified attribute. If the attribute is not found, String.Empty is returned. This method does not move the reader.</dd>
</dl><b>Remarks</b><dl>
<dd> The following XML contains an attribute in a specific namespace: <p><code>
                &lt;test xmlns:dt="urn:datatypes" dt:type="int"/&gt;
              </code></p>
<p> You can lookup the <b>dt:type</b> attribute using one argument (prefix and local name) or two arguments (local name and namespace URI): </p>
<p><code>
                String dt = reader.GetAttribute("dt:type");
              </code></p>
<p><code>
                String dt2 = reader.GetAttribute("type","urn:datatypes");
              </code></p>
<p> To lookup the <b>xmlns:dt</b> attribute, use one of the following arguments: </p>
<p><code>
                String dt3 = reader.GetAttribute("xmlns:dt");
              </code></p>
<p><code>
                String dt4 = reader.GetAttribute("dt",http://www.w3.org/2000/xmlns/);
              </code></p>
<p> You can also get this information using the  <a href="#Prefix">XmlValidatingReader.Prefix</a> property.</p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetHashCodeTopic1"></a><a name="GetHashCode">GetHashCode</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#GetHashCode">System.Object.GetHashCode</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/Int32.html">int</a> GetHashCode();</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetTypeTopic1"></a><a name="GetType">GetType</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#GetType">System.Object.GetType</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Type.html">Type</a> GetType();</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="IsStartElementTopic1"></a><a name="IsStartElement">IsStartElement</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System.Xml/types/XmlReader.html#IsStartElement">System.Xml.XmlReader.IsStartElement</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Calls  <a href="#MoveToContent">XmlReader.MoveToContent</a> and tests if the current content node is a start tag or empty element tag.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/Boolean.html">bool</a> IsStartElement();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if <b>MoveToContent</b> finds a start tag or empty element tag; <b>false</b> if a node type other than <b>XmlNodeType.Element</b> was found.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Xml/types/XmlException.html">XmlException</a></td>
<td> Incorrect XML is encountered in the input stream.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This method skips white space, comments, and processing instructions until the reader is positioned on a content node. The method then tests if the current node is an element.</dd>
</dl><b>Example</b><dl>
<dd> The following example displays the text content of each element.<pre>
using System;
using System.IO;
using System.Xml;

public class Sample 
{
  public static void Main()
  {
    XmlTextReader reader = null;

    try
    {
       //Load the reader with the XML file.
       reader = new XmlTextReader("elems.xml");
  
       //Parse the XML and display the text content of each of the elements.
       while (reader.Read()){
         if (reader.IsStartElement()){
           if (reader.IsEmptyElement)
              Console.WriteLine("&lt;{0}/&gt;", reader.Name);
           else{
               Console.Write("&lt;{0}&gt; ", reader.Name);
               reader.Read(); //Read the start tag.
               if (reader.IsStartElement())  //Handle nested elements.
                 Console.Write("\r\n&lt;{0}&gt;", reader.Name);
               Console.WriteLine(reader.ReadString());  //Read the text content of the element.
           }
         }
       } 
       
     } 

     finally 
     {
        if (reader != null)
          reader.Close();
      }
  }
  
} // End class

    </pre> The example uses the file, <b>elems.xml</b>, as input.<pre>

&lt;book&gt;
  &lt;title&gt;Pride And Prejudice&lt;/title&gt;
  &lt;price&gt;19.95&lt;/price&gt;
  &lt;misc/&gt;
&lt;/book&gt;

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#MoveToContent">XmlReader.MoveToContent</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="IsStartElementTopic2"></a><a name="IsStartElement(System.String)">IsStartElement</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System.Xml/types/XmlReader.html#IsStartElement(System.String)">System.Xml.XmlReader.IsStartElement</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Calls  <a href="#MoveToContent">XmlReader.MoveToContent</a> and tests if the current content node is a start tag or empty element tag and if the  <a href="#Name">XmlReader.Name</a> property of the element found matches the given argument.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/Boolean.html">bool</a> IsStartElement(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The string matched against the <b>Name</b> property of the element found.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the resulting node is an element and the <b>Name</b> property matches the specified string.<b>false</b> if a node type other than <b>XmlNodeType.Element</b> was found or if the element <b>Name</b> property does not match the specified string.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Xml/types/XmlException.html">XmlException</a></td>
<td> Incorrect XML is encountered in the input stream.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This method skips white space, comments, and processing instructions until the reader is positioned on a content node. The method then tests if the current node is an element.</dd>
</dl><b>See also: 
			</b><br> <a href="#MoveToContent">XmlReader.MoveToContent</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="IsStartElementTopic3"></a><a name="IsStartElement(System.String,System.String)">IsStartElement</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>localname</i>,</font><br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>ns</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System.Xml/types/XmlReader.html#IsStartElement(System.String,System.String)">System.Xml.XmlReader.IsStartElement</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Calls  <a href="#MoveToContent">XmlReader.MoveToContent</a> and tests if the current content node is a start tag or empty element tag and if the  <a href="#LocalName">XmlReader.LocalName</a> and  <a href="#NamespaceURI">XmlReader.NamespaceURI</a> properties of the element found match the given strings.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/Boolean.html">bool</a> IsStartElement(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>localname</i>,</font><br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>ns</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>localname</i><br><dl>
<dd>
<param> The string to match against the <b>LocalName</b> property of the element found.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>ns</i><br><dl>
<dd>
<param> The string to match against the <b>NamespaceURI</b> property of the element found.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the resulting node is an element.<b>false</b> if a node type other than <b>XmlNodeType.Element</b> was found or if the <b>LocalName</b> and <b>NamespaceURI</b> properties of the element do not match the specified strings.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Xml/types/XmlException.html">XmlException</a></td>
<td> Incorrect XML is encountered in the input stream.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This method skips white space, comments, and processing instructions until the reader is positioned on a content node. The method then tests if the current node is an element.</dd>
</dl><b>See also: 
			</b><br> <a href="#MoveToContent">XmlReader.MoveToContent</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="LookupNamespaceTopic1"></a><a name="LookupNamespace(System.String)">LookupNamespace</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>prefix</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Resolves a namespace prefix in the current element's scope.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/String.html">string</a> LookupNamespace(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>prefix</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>prefix</i><br><dl>
<dd>
<param> The prefix whose namespace URI you want to resolve. To match the default namespace, pass an empty string. This string does not have to be atomized.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The namespace URI to which the prefix maps or <b>null</b> if no matching prefix is found.</dd>
</dl><b>Remarks</b><dl>
<dd>
<pre>
              &lt;root xmlns:a="urn:456"&gt;
               &lt;item&gt;
               &lt;ref href="a:b"/&gt;
               &lt;/item&gt;
              &lt;/root&gt;
               
            </pre> In the preceding XML, if the reader is positioned on the <b>href</b> attribute, the prefix <code>
                a
              </code> is resolved by calling <code>
                reader.LookupNamesapce("a")
              </code>. The returned string is <code>
                urn:456
              </code>.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="MemberwiseCloneTopic1"></a><a name="MemberwiseClone">MemberwiseClone</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#MemberwiseClone">System.Object.MemberwiseClone</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected <a href="../../System/types/Object.html">object</a> MemberwiseClone();</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="MoveToAttributeTopic1"></a><a name="MoveToAttribute(System.Int32)">MoveToAttribute</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Int32.html">int</a> <i>i</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Moves to the attribute with the specified index.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override void MoveToAttribute(<br>   <font color="#008080"><a href="../../System/types/Int32.html">int</a> <i>i</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>i</i><br><dl>
<dd>
<param> The index of the attribute.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentOutOfRangeException.html">ArgumentOutOfRangeException</a></td>
<td> The <i>i</i> parameter is less than 0 or greater than or equal to  <a href="../../System.Xml/types/XmlReader.html#AttributeCount">XmlReader.AttributeCount</a>.</td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd> The following example reads all the elements on the root node.<pre>
using System;
using System.IO;
using System.Xml;

public class Sample 
{
  public static void Main()
  {
    XmlValidatingReader reader = null;

    try
    {
       //Create the string to parse.
       string xmlFrag="&lt;book genre='novel' ISBN='1-861003-78' pubdate='1987'&gt;&lt;/book&gt; ";

       //Create the XmlNamespaceManager.
       NameTable nt = new NameTable();
       XmlNamespaceManager nsmgr = new XmlNamespaceManager(nt);

       //Create the XmlParserContext.
       XmlParserContext context = new XmlParserContext(null, nsmgr, null, XmlSpace.None);

       //Create the XmlValidatingReader .
       reader = new XmlValidatingReader(xmlFrag, XmlNodeType.Element, context);
  
       //Read the attributes on the root element.
       reader.MoveToContent();
       if (reader.HasAttributes){
         for (int i=0; i&lt;reader.AttributeCount; i++){
            reader.MoveToAttribute(i);
            Console.WriteLine("{0} = {1}", reader.Name, reader.Value);
         }
         //Move the reader back to the node that owns the attribute.
         reader.MoveToElement();
       }

     } 

     finally 
     {
        if (reader != null)
          reader.Close();
      }
  }
} // End class

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="MoveToAttributeTopic2"></a><a name="MoveToAttribute(System.String)">MoveToAttribute</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Moves to the attribute with the specified name.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Boolean.html">bool</a> MoveToAttribute(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The qualified name of the attribute.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the attribute is found; otherwise, <b>false</b>. If <b>false</b>, the position of the reader does not change.</dd>
</dl><b>Remarks</b><dl>
<dd> After calling this method, the  <a href="#Name">XmlValidatingReader.Name</a>,  <a href="#NamespaceURI">XmlValidatingReader.NamespaceURI</a>, and  <a href="#Prefix">XmlValidatingReader.Prefix</a> properties reflect the properties of that attribute.</dd>
</dl><b>Example</b><dl>
<dd> The following example reads an attribute with text and entity reference nodes.<pre>
using System;
using System.IO;
using System.Xml;

public class Sample 
{
  public static void Main()
  {
    XmlValidatingReader reader = null;

    try
    {
       //Create the XML fragment to be parsed.
       string xmlFrag ="&lt;book genre='novel' misc='sale-item &amp;h; 1987'&gt;&lt;/book&gt;";

       //Create the XmlParserContext.
       XmlParserContext context;
       string subset = "&lt;!ENTITY h 'hardcover'&gt;";
       context = new XmlParserContext(null, null, "book", null, null, subset, "", "", XmlSpace.None);
        
       //Create the reader and set it to not expand general entities. 
       reader = new XmlValidatingReader(xmlFrag, XmlNodeType.Element, context);
       reader.ValidationType = ValidationType.None;
       reader.EntityHandling = EntityHandling.ExpandCharEntities;
  
       //Read the misc attribute. Because EntityHandling is set to
       //ExpandCharEntities, the attribute is parsed into multiple text
       //and entity reference nodes.
       reader.MoveToContent();
       reader.MoveToAttribute("misc");
       while (reader.ReadAttributeValue()){
          if (reader.NodeType==XmlNodeType.EntityReference)
            //To expand the entity, call ResolveEntity.
            Console.WriteLine("{0} {1}", reader.NodeType, reader.Name);
          else
             Console.WriteLine("{0} {1}", reader.NodeType, reader.Value);
        } 
     } 
     finally 
     {
        if (reader != null)
          reader.Close();
      }
  }
} // End class

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="MoveToAttributeTopic3"></a><a name="MoveToAttribute(System.String,System.String)">MoveToAttribute</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>localName</i>,</font><br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>namespaceURI</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Moves to the attribute with the specified local name and namespace URI.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Boolean.html">bool</a> MoveToAttribute(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>localName</i>,</font><br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>namespaceURI</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>localName</i><br><dl>
<dd>
<param> The local name of the attribute.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>namespaceURI</i><br><dl>
<dd>
<param> The namespace URI of the attribute.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the attribute is found; otherwise, <b>false</b>. If <b>false</b>, the position of the reader does not change.</dd>
</dl><b>Remarks</b><dl>
<dd> After calling this method, the  <a href="#Name">XmlValidatingReader.Name</a>,  <a href="#NamespaceURI">XmlValidatingReader.NamespaceURI</a>, and  <a href="#Prefix">XmlValidatingReader.Prefix</a> properties reflect the properties of that attribute.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="MoveToContentTopic1"></a><a name="MoveToContent">MoveToContent</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System.Xml/types/XmlReader.html#MoveToContent">System.Xml.XmlReader.MoveToContent</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Checks whether the current node is a content (non-white space text, <b>CDATA</b>, <b>Element</b>, <b>EndElement</b>, <b>EntityReference</b>, or <b>EndEntity</b>) node. If the node is not a content node, the reader skips ahead to the next content node or end of file. It skips over nodes of the following type: <b>ProcessingInstruction</b>, <b>DocumentType</b>, <b>Comment</b>, <b>Whitespace</b>, or <b>SignificantWhitespace</b>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System.Xml/types/XmlNodeType.html">XmlNodeType</a> MoveToContent();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The  <a href="#NodeType">XmlReader.NodeType</a><b></b> of the current node found by the method or <b>XmlNodeType.None</b> if the reader has reached the end of the input stream.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Xml/types/XmlException.html">XmlException</a></td>
<td> Incorrect XML encountered in the input stream.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> If the current node is an attribute node, this method moves the reader back to the element that owns the attribute.</dd>
</dl><b>Example</b><dl>
<dd> This is useful when you want to write code that can skip over random XML markup without breaking. For example, suppose you have the following code: <pre>
if (reader.MoveToContent() == XmlNodeType.Element &amp;&amp; reader.Name == "price") 
 {
    _price = reader.ReadString();
 }

    </pre>
<p> This code can handle the following inputs without breaking: </p>
<p><code>
                &lt;price&gt;123.4&lt;/price&gt;
              </code></p>
<p> and </p>
<p><code>
                &lt;?xml version="1.0"&gt;&lt;!DOCTYPE price SYSTEM
                "abc"&gt;&lt;price&gt;123.4&lt;/price&gt;
              </code></p>
<p> and </p>
<p><code>
                &lt;?xml version="1.0"&gt;&lt;!DOCTYPE price SYSTEM "abc"
                [&lt;!ENTTIY p
                "123.4"&gt;]&gt;&lt;price&gt;&amp;p;&lt;/price&gt;
              </code></p>
<p> and </p>
<p><code>
                &lt;!-- some test comment --&gt;&lt;?processing
                instruction?&gt;&lt;price&gt;123.4&lt;/price&gt;
              </code></p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="MoveToElementTopic1"></a><a name="MoveToElement">MoveToElement</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Moves to the element that contains the current attribute node.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Boolean.html">bool</a> MoveToElement();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the reader is positioned on an attribute (the reader moves to the element that owns the attribute); <b>false</b> if the reader is not positioned on an attribute (the position of the reader does not change).</dd>
</dl><b>Remarks</b><dl>
<dd> Use this method to return to an element after navigating through its attributes. This method moves the reader to one of the following node types: <b>Element</b>, <b>DocumentType</b>, or <b>XmlDeclaration</b>.</dd>
</dl><b>Example</b><dl>
<dd> The following example reads all the elements on the root node.<pre>
using System;
using System.IO;
using System.Xml;

public class Sample 
{
  public static void Main()
  {
    XmlValidatingReader reader = null;

    try
    {
       //Create the string to parse.
       string xmlFrag="&lt;book genre='novel' ISBN='1-861003-78' pubdate='1987'&gt;&lt;/book&gt; ";

       //Create the XmlNamespaceManager.
       NameTable nt = new NameTable();
       XmlNamespaceManager nsmgr = new XmlNamespaceManager(nt);

       //Create the XmlParserContext.
       XmlParserContext context = new XmlParserContext(null, nsmgr, null, XmlSpace.None);

       //Create the XmlValidatingReader .
       reader = new XmlValidatingReader(xmlFrag, XmlNodeType.Element, context);
  
       //Read the attributes on the root element.
       reader.MoveToContent();
       if (reader.HasAttributes){
         for (int i=0; i&lt;reader.AttributeCount; i++){
            reader.MoveToAttribute(i);
            Console.WriteLine("{0} = {1}", reader.Name, reader.Value);
         }
         //Move the reader back to the node that owns the attribute.
         reader.MoveToElement();
       }

     } 

     finally 
     {
        if (reader != null)
          reader.Close();
      }
  }
} // End class

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="MoveToFirstAttributeTopic1"></a><a name="MoveToFirstAttribute">MoveToFirstAttribute</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Moves to the first attribute.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Boolean.html">bool</a> MoveToFirstAttribute();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if an attribute exists (the reader moves to the first attribute); otherwise, <b>false</b> (the position of the reader does not change).</dd>
</dl><b>Example</b><dl>
<dd> The following example reads an XML fragment.<pre>
using System;
using System.IO;
using System.Xml;

public class Sample 
{
  public static void Main()
  {

    //Create the validating reader.
    XmlTextReader txtreader = new XmlTextReader("attrs.xml");
    XmlValidatingReader reader = new XmlValidatingReader(txtreader);

    //Read the genre attribute.
    reader.MoveToFirstAttribute();
    string genre=reader.Value;
    Console.WriteLine("The genre value: " + genre);

    //Close the reader.
    reader.Close();

  } 
} // End class

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="MoveToNextAttributeTopic1"></a><a name="MoveToNextAttribute">MoveToNextAttribute</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Moves to the next attribute.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Boolean.html">bool</a> MoveToNextAttribute();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if there is a next attribute; <b>false</b> if there are no more attributes.</dd>
</dl><b>Remarks</b><dl>
<dd> If the current node is an element node, this method is equivalent to  <a href="#MoveToFirstAttribute">XmlValidatingReader.MoveToFirstAttribute</a>. If <b>MoveToNextAttribute</b> returns <b>true</b>, the reader moves to the next attribute; otherwise, the position of the reader does not change.</dd>
</dl><b>Example</b><dl>
<dd> The following example reads an XML fragment.<pre>
using System;
using System.IO;
using System.Xml;

public class Sample 
{
  public static void Main()
  {

    //Create the validating reader.
    XmlTextReader txtreader = new XmlTextReader("attrs.xml");
    XmlValidatingReader reader = new XmlValidatingReader(txtreader);

    //Read the genre attribute.
    reader.MoveToFirstAttribute();
    string genre=reader.Value;
    Console.WriteLine("The genre value: " + genre);

    //Close the reader.
    reader.Close();

  } 
} // End class

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="ReadTopic1"></a><a name="Read">Read</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Reads the next node from the stream.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Boolean.html">bool</a> Read();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the next node was read successfully; <b>false</b> if there are no more nodes to read.</dd>
</dl><b>Remarks</b><dl>
<dd> When a reader is first created and initialized, there is no information available. You must call <b>Read</b> to read the first node.</dd>
</dl><b>Example</b><dl>
<dd> The following example reads an XML file and displays each node.<pre>
using System;
using System.IO;
using System.Xml;

public class Sample
{
  private const String filename = "items.xml";

  public static void Main()
  {
     XmlTextReader txtreader = null;
     XmlValidatingReader reader = null;

     try
     {  
        //Load the reader with the data file and ignore all white space nodes.         
        txtreader = new XmlTextReader(filename);
        txtreader.WhitespaceHandling = WhitespaceHandling.None;

        //Implement the validating reader over the text reader. 
        reader = new XmlValidatingReader(txtreader);
        reader.ValidationType = ValidationType.None;

        //Parse the file and display each of the nodes.
        while (reader.Read())
        {
           switch (reader.NodeType)
           {
             case XmlNodeType.Element:
               Console.Write("&lt;{0}&gt;", reader.Name);
               break;
             case XmlNodeType.Text:
               Console.Write(reader.Value);
               break;
             case XmlNodeType.CDATA:
               Console.Write("&lt;![CDATA[{0}]]&gt;", reader.Value);
               break;
             case XmlNodeType.ProcessingInstruction:
               Console.Write("&lt;?{0} {1}?&gt;", reader.Name, reader.Value);
               break;
             case XmlNodeType.Comment:
               Console.Write("&lt;!--{0}--&gt;", reader.Value);
               break;
             case XmlNodeType.XmlDeclaration:
               Console.Write("&lt;?xml version='1.0'?&gt;");
               break;
             case XmlNodeType.Document:
               break;
             case XmlNodeType.DocumentType:
               Console.Write("&lt;!DOCTYPE {0} [{1}]", reader.Name, reader.Value);
               break;
             case XmlNodeType.EntityReference:
               Console.Write(reader.Name);
               break;
             case XmlNodeType.EndElement:
               Console.Write("&lt;/{0}&gt;", reader.Name);
               break;
           }       
        }           
     }

     finally
     {
        if (reader!=null)
          reader.Close();
     }
  }
} // End class

    </pre> The example uses the file, <b>items.xml</b>, as input.<pre>

&lt;?xml version="1.0"?&gt;
&lt;!-- This is a sample XML document --&gt;
&lt;!DOCTYPE Items [&lt;!ENTITY number "123"&gt;]&gt;
&lt;Items&gt;
  &lt;Item&gt;Test with an entity: &amp;number;&lt;/Item&gt;
  &lt;Item&gt;test with a child element &lt;more/&gt; stuff&lt;/Item&gt;
  &lt;Item&gt;test with a CDATA section &lt;![CDATA[&lt;456&gt;]]&gt; def&lt;/Item&gt;
  &lt;Item&gt;Test with a char entity: &amp;#65;&lt;/Item&gt;
  &lt;!-- Fourteen chars in this element.--&gt;
  &lt;Item&gt;1234567890ABCD&lt;/Item&gt;
&lt;/Items&gt;

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="ReadAttributeValueTopic1"></a><a name="ReadAttributeValue">ReadAttributeValue</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Parses the attribute value into one or more <b>Text</b>, <b>EntityReference</b>, or <b>EndEntity</b> nodes.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Boolean.html">bool</a> ReadAttributeValue();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if there are nodes to return.<p><b>false</b> if the reader is not positioned on an attribute node when the initial call is made or if all the attribute values have been read.</p>
<p> An empty attribute, such as, <code>
                misc=""
              </code>, returns <b>true</b> with a single node with a value of String.Empty.</p>
</dd>
</dl><b>Remarks</b><dl>
<dd> Use this method after calling  <a href="#MoveToAttribute(System.String)">XmlValidatingReader.MoveToAttribute</a> to read through the text or entity reference nodes that make up the attribute value. The  <a href="../../System.Xml/types/XmlReader.html#Depth">XmlReader.Depth</a> of the attribute value nodes is one plus the depth of the attribute node. The <b>Depth</b> increments and decrements by one when you step into and out of general entity references.<p> For example, suppose you have the following XML: <code>
                &lt;test name="a &amp;b;
                c"/&gt;
              </code></p>
<p> where the entity <b>b</b> is defined in the DTD as follows: <code>
                &lt;!ENTITY b "123"&gt;
              </code></p>
<p> If  <a href="#EntityHandling">XmlValidatingReader.EntityHandling</a> is set to <b>ExpandCharEntities</b>, the following C# code returns the attribute value as two text nodes and one entity reference node: </p>
<pre>
              reader.MoveToAttribute("name");
               while (reader.ReadAttributeValue())
               {
               if (reader.NodeType == XmlNodeType.Text)
               {
               // at this point reader.Text == "a " or " c"
               }
               else if (reader.NodeType == XmlNodeType.EntityReference)
               {
               // at this point reader.Name == "b"
               reader.ResolveEntity();
               while (reader.ReadAttributeValue() &amp;&amp;
               reader.NodeType != XmlNodeType.EndEntity)
               {
               // reader.Text == "123"
               }
               }
               }
            </pre>
</dd>
</dl><b>Example</b><dl>
<dd> The following example reads an attribute with text and entity reference nodes.<pre>
using System;
using System.IO;
using System.Xml;

public class Sample 
{
  public static void Main()
  {
    XmlValidatingReader reader = null;

    try
    {
       //Create the XML fragment to be parsed.
       string xmlFrag ="&lt;book genre='novel' misc='sale-item &amp;h; 1987'&gt;&lt;/book&gt;";

       //Create the XmlParserContext.
       XmlParserContext context;
       string subset = "&lt;!ENTITY h 'hardcover'&gt;";
       context = new XmlParserContext(null, null, "book", null, null, subset, "", "", XmlSpace.None);
        
       //Create the reader and set it to not expand general entities. 
       reader = new XmlValidatingReader(xmlFrag, XmlNodeType.Element, context);
       reader.ValidationType = ValidationType.None;
       reader.EntityHandling = EntityHandling.ExpandCharEntities;
  
       //Read the misc attribute. Because EntityHandling is set to
       //ExpandCharEntities, the attribute is parsed into multiple text
       //and entity reference nodes.
       reader.MoveToContent();
       reader.MoveToAttribute("misc");
       while (reader.ReadAttributeValue()){
          if (reader.NodeType==XmlNodeType.EntityReference)
            //To expand the entity, call ResolveEntity.
            Console.WriteLine("{0} {1}", reader.NodeType, reader.Name);
          else
             Console.WriteLine("{0} {1}", reader.NodeType, reader.Value);
        } 
     } 
     finally 
     {
        if (reader != null)
          reader.Close();
      }
  }
} // End class

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="ReadElementStringTopic1"></a><a name="ReadElementString">ReadElementString</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System.Xml/types/XmlReader.html#ReadElementString">System.Xml.XmlReader.ReadElementString</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Reads a text-only element.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/String.html">string</a> ReadElementString();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The text contained in the element that was read. An empty string if the element is empty (<code>
                &lt;item&gt;&lt;/item&gt;
              </code> or <code>
                &lt;item/&gt;
              </code>).</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Xml/types/XmlException.html">XmlException</a></td>
<td> The next content node is not a start tag; or the element found does not contain a simple text value.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This is a helper method for reading simple text-only elements. It calls  <a href="#MoveToContent">XmlReader.MoveToContent</a> to find the next content node and then parses its value as a simple string.<p> Using the XML, <code>
                &lt;name&gt;Arlene Huff&lt;/name&gt;
              </code>, <b>ReadElementString</b> consumes the element and returns the string <b>Arlene Huff</b>.</p>
<p> This method cannot handle any markup (child elements, comments, processing instructions, and so on) inside the <b>name</b> element, but it can concatenate multiple adjacent text and CDATA blocks.</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following example uses <b>ReadElementString</b> to read the contents of the element nodes.<pre>
using System;
using System.IO;
using System.Xml;

//Reads an XML fragment

public class Sample
{
  private const String filename = "book.xml";

  public static void Main()
  {
    XmlTextReader reader = null;

    try
    {           
      //Load the file and ignore all whitespace.
      reader = new XmlTextReader(filename);
      reader.WhitespaceHandling = WhitespaceHandling.None;

      //Moves the reader to the root element.
      reader.MoveToContent();

      //Read the title and price elements.
      Console.WriteLine("Content of the title element: {0}", reader.ReadElementString());
      Console.WriteLine("Content of the price element: {0}", reader.ReadElementString());; 
         
    }
    finally
    {
      if (reader!=null)
        reader.Close();
    }
  }
} // End class

    </pre> The example uses the data file <b>book.xml</b>: <pre>

&lt;!--sample XML fragment--&gt;
&lt;book genre='novel' ISBN='1-861003-78' misc='sale-item'&gt;
  &lt;title&gt;The Handmaid's Tale&lt;/title&gt;
  &lt;price&gt;14.95&lt;/price&gt;
&lt;/book&gt;

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="ReadElementStringTopic2"></a><a name="ReadElementString(System.String)">ReadElementString</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System.Xml/types/XmlReader.html#ReadElementString(System.String)">System.Xml.XmlReader.ReadElementString</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Checks that the  <a href="#Name">XmlReader.Name</a> property of the element found matches the given string before reading a text-only element.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/String.html">string</a> ReadElementString(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The name to check.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The text contained in the element that was read. An empty string if the element is empty (<code>
                &lt;item&gt;&lt;/item&gt;
              </code> or <code>
                &lt;item/&gt;
              </code>).</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Xml/types/XmlException.html">XmlException</a></td>
<td> If the next content node is not a start tag; if the element <b>Name</b> does not match the given argument; or if the element found does not contain a simple text value.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This is a helper method for reading simple text-only elements. It calls  <a href="#MoveToContent">XmlReader.MoveToContent</a> to find the next content node and then parses its value as a simple string.<p> Using the XML, <code>
                &lt;name&gt;Arlene
                Huff&lt;/name&gt;
              </code>, <b>ReadElementString</b> consumes the element and returns the string <b>Arlene Huff</b>.</p>
<p> This method cannot handle any markup (child elements, comments, processing instructions, and so on) inside the <b>name</b> element, but it can concatenate multiple adjacent text and CDATA blocks.</p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="ReadElementStringTopic3"></a><a name="ReadElementString(System.String,System.String)">ReadElementString</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>localname</i>,</font><br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>ns</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System.Xml/types/XmlReader.html#ReadElementString(System.String,System.String)">System.Xml.XmlReader.ReadElementString</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Checks that the  <a href="#LocalName">XmlReader.LocalName</a> and  <a href="#NamespaceURI">XmlReader.NamespaceURI</a> properties of the element found matches the given strings before reading a text-only element.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/String.html">string</a> ReadElementString(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>localname</i>,</font><br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>ns</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>localname</i><br><dl>
<dd>
<param> The local name to check.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>ns</i><br><dl>
<dd>
<param> The namespace URI to check.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The text contained in the element that was read. An empty string if the element is empty (<code>
                &lt;item&gt;&lt;/item&gt;
              </code> or <code>
                &lt;item/&gt;
              </code>).</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Xml/types/XmlException.html">XmlException</a></td>
<td> If the next content node is not a start tag; if the element <b>LocalName</b> or <b>NamespaceURI</b> do not match the given arguments; or if the element found does not contain a simple text value.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This is a helper method for reading simple text-only elements. It calls  <a href="#MoveToContent">XmlReader.MoveToContent</a> to find the next content node and then parses its value as a simple string.<p> Using the XML, <code>
                &lt;name&gt;Arlene
                Huff&lt;/name&gt;
              </code>, <b>ReadElementString</b> consumes the element and returns the string <b>Arlene Huff</b>.</p>
<p> This method cannot handle any markup (child elements, comments, processing instructions, and so on) inside the <b>name</b> element, but it can concatenate multiple adjacent text and CDATA blocks.</p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="ReadEndElementTopic1"></a><a name="ReadEndElement">ReadEndElement</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System.Xml/types/XmlReader.html#ReadEndElement">System.Xml.XmlReader.ReadEndElement</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Checks that the current content node is an end tag and advances the reader to the next node.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual void ReadEndElement();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Xml/types/XmlException.html">XmlException</a></td>
<td> The current node is not an end tag or if incorrect XML is encountered in the input stream.</td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd> The following example reads an XML document using the  <a href="#ReadStartElement">XmlReader.ReadStartElement</a> and <b>ReadEndElement</b> methods.<pre>
using System;
using System.IO;
using System.Xml;

public class Sample 
{
  public static void Main()
  {

     //Create the reader.
     XmlTextReader  reader = new XmlTextReader("book3.xml");

     //Parse the XML document.  ReadString is used to 
     //read the text content of the elements.
     reader.Read(); 
     reader.ReadStartElement("book");  
     reader.ReadStartElement("title");   
     Console.Write("The content of the title element:  ");
     Console.WriteLine(reader.ReadString());
     reader.ReadEndElement();
     reader.ReadStartElement("price");
     Console.Write("The content of the price element:  ");
     Console.WriteLine(reader.ReadString());
     reader.ReadEndElement();
     reader.ReadEndElement();

     //Close the reader.
     reader.Close();
     
  }
} // End class

    </pre> The example uses the file, <b>book3.xml</b>, as input.<pre>
&lt;book&gt;
  &lt;title&gt;Pride And Prejudice&lt;/title&gt;
  &lt;price&gt;19.95&lt;/price&gt;
&lt;/book&gt;

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#ReadStartElement">XmlReader.ReadStartElement</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="ReadInnerXmlTopic1"></a><a name="ReadInnerXml">ReadInnerXml</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Reads all the content, including markup, as a string.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/String.html">string</a> ReadInnerXml();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> All the XML content, including markup, in the current node. If the current node has no children, an empty string is returned.<p> If the current node is neither an element nor attribute, an empty string is returned.</p>
</dd>
</dl><b>Remarks</b><dl>
<dd> This method returns all the content of the current node including the markup. The current node (start tag) and corresponding end node (end tag) are not returned. For example, if you had the following: <pre>
              &lt;node&gt;
               this &lt;child id="123"/&gt;
              &lt;/node&gt;
               
            </pre>
<p><b>ReadInnerXml</b> returns <code>
                this &lt;child id="123"/&gt;
              </code></p>
<p> This method handles element and attribute nodes in the following way: </p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Node Type
                </TH>
<TH>
                  Child Content
                </TH>
<TH>
                  Return Value
                </TH>
<TH>
                  Position After the Call
                </TH>
</THEAD>
<TR valign="top">
<TD><b>Element</b></TD>
<TD>
                  &lt;item&gt;text&lt;/item&gt;
                </TD>
<TD>
                  text
                </TD>
<TD>
                  After the end tag.
                </TD>
</TR>
<TR valign="top">
<TD><b>Attribute</b></TD>
<TD>
                  &lt;item attr1="val1" attr2="val2"&gt;text&lt;/item&gt;
                </TD>
<TD>
                  val1
                </TD>
<TD>
                  Remains on the attribute node
                  <b>attr1</b>
                  .
                </TD>
</TR>
</table>
<p> If the reader is positioned on a leaf node, calling <b>ReadInnerXml</b> is equivalent to calling  <a href="#Read">XmlValidatingReader.Read</a>.</p>
<p> This method also checks for well-formed XML.</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following example compares the <b>ReadInnerXml</b> and  <a href="#ReadOuterXml">XmlValidatingReader.ReadOuterXml</a> methods.<pre>
using System;
using System.IO;
using System.Xml;

public class Sample
{
  private const String filename = "2books.xml";

  public static void Main()
  {
    XmlTextReader txtReader = null;
    XmlValidatingReader reader = null;

    try
    {
       txtReader = new XmlTextReader(filename);
       txtReader.WhitespaceHandling = WhitespaceHandling.None;
        
       reader = new XmlValidatingReader(txtReader);

       //Moves the reader to the root element.
       reader.MoveToContent();

       reader.Read(); //moves to book node

       //Note that ReadInnerXml only returns the markup of the node's children
       //so the book's attributes are not returned.
       Console.WriteLine("Read the first book using ReadInnerXml...");
       Console.WriteLine(reader.ReadInnerXml());

       //ReadOuterXml returns the markup for the current node and its children
       //so the book's attributes are also returned.
       Console.WriteLine("\r\nRead the second book using ReadOuterXml...");
       Console.WriteLine(reader.ReadOuterXml());            
        

    }
    finally
    {
      if (reader!=null)
        reader.Close();
    }
  }
} // End class

    </pre> The example uses the file, <b>2books.xml</b>, as input.<pre>

&lt;!--sample XML fragment--&gt;
&lt;bookstore&gt;
  &lt;book genre='novel' ISBN='10-861003-324'&gt;
    &lt;title&gt;The Handmaid's Tale&lt;/title&gt;
    &lt;price&gt;19.95&lt;/price&gt;
  &lt;/book&gt;
  &lt;book genre='novel' ISBN='1-861001-57-5'&gt;
    &lt;title&gt;Pride And Prejudice&lt;/title&gt;
    &lt;price&gt;24.95&lt;/price&gt;
  &lt;/book&gt;
&lt;/bookstore&gt;

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="ReadOuterXmlTopic1"></a><a name="ReadOuterXml">ReadOuterXml</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Reads the content, including markup, representing this node and all its children.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/String.html">string</a> ReadOuterXml();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> If the reader is positioned on an element or an attribute node, this method returns all the XML content, including markup, of the current node and all its children; otherwise, it returns an empty string.</dd>
</dl><b>Remarks</b><dl>
<dd> This method is similar to  <a href="#ReadInnerXml">XmlValidatingReader.ReadInnerXml</a> except it also returns the start and end tags.<p> This method handles element and attribute nodes in the following manner: </p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Node Type
                </TH>
<TH>
                  Child Content
                </TH>
<TH>
                  Return Value
                </TH>
<TH>
                  Position After the Call
                </TH>
</THEAD>
<TR valign="top">
<TD><b>Element</b></TD>
<TD>
                  &lt;item&gt;text&lt;/item&gt;
                </TD>
<TD>
                  &lt;item&gt;text&lt;/item&gt;
                </TD>
<TD>
                  After the end tag.
                </TD>
</TR>
<TR valign="top">
<TD><b>Attribute</b></TD>
<TD>
                  &lt;item attr1="val1" attr2="val2"&gt;text&lt;/item&gt;
                </TD>
<TD>
                  attr="val1"
                </TD>
<TD>
                  Remains on the attribute node
                  <b>attr1</b>
                  .
                </TD>
</TR>
</table>
<p> If the reader is positioned on a leaf node, calling <b>ReadOuterXml</b> is equivalent to calling  <a href="#Read">XmlValidatingReader.Read</a>.</p>
<p> This method checks for well-formed XML and also validates the returned content.</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following example compares the  <a href="#ReadInnerXml">XmlValidatingReader.ReadInnerXml</a> and <b>ReadOuterXml</b> methods.<pre>
using System;
using System.IO;
using System.Xml;

public class Sample
{
  private const String filename = "2books.xml";

  public static void Main()
  {
    XmlTextReader txtReader = null;
    XmlValidatingReader reader = null;

    try
    {
       txtReader = new XmlTextReader(filename);
       txtReader.WhitespaceHandling = WhitespaceHandling.None;
        
       reader = new XmlValidatingReader(txtReader);

       //Moves the reader to the root element.
       reader.MoveToContent();

       reader.Read(); //moves to book node

       //Note that ReadInnerXml only returns the markup of the node's children
       //so the book's attributes are not returned.
       Console.WriteLine("Read the first book using ReadInnerXml...");
       Console.WriteLine(reader.ReadInnerXml());

       //ReadOuterXml returns the markup for the current node and its children
       //so the book's attributes are also returned.
       Console.WriteLine("\r\nRead the second book using ReadOuterXml...");
       Console.WriteLine(reader.ReadOuterXml());            
        

    }
    finally
    {
      if (reader!=null)
        reader.Close();
    }
  }
} // End class

    </pre> The example uses the file, <b>2books.xml</b>, as input.<pre>

&lt;!--sample XML fragment--&gt;
&lt;bookstore&gt;
  &lt;book genre='novel' ISBN='10-861003-324'&gt;
    &lt;title&gt;The Handmaid's Tale&lt;/title&gt;
    &lt;price&gt;19.95&lt;/price&gt;
  &lt;/book&gt;
  &lt;book genre='novel' ISBN='1-861001-57-5'&gt;
    &lt;title&gt;Pride And Prejudice&lt;/title&gt;
    &lt;price&gt;24.95&lt;/price&gt;
  &lt;/book&gt;
&lt;/bookstore&gt;

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="ReadStartElementTopic1"></a><a name="ReadStartElement">ReadStartElement</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System.Xml/types/XmlReader.html#ReadStartElement">System.Xml.XmlReader.ReadStartElement</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Checks that the current node is an element and advances the reader to the next node.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual void ReadStartElement();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Xml/types/XmlException.html">XmlException</a></td>
<td> <a href="#IsStartElement">XmlReader.IsStartElement</a> returns <b>false</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This method calls  <a href="#IsStartElement">XmlReader.IsStartElement</a> followed by  <a href="#Read">XmlReader.Read</a> to position you on the content of that element found in the input stream.</dd>
</dl><b>See also: 
			</b><br> <a href="#ReadEndElement">XmlReader.ReadEndElement</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="ReadStartElementTopic2"></a><a name="ReadStartElement(System.String)">ReadStartElement</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System.Xml/types/XmlReader.html#ReadStartElement(System.String)">System.Xml.XmlReader.ReadStartElement</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Checks that the current content node is an element with the given  <a href="#Name">XmlReader.Name</a> and advances the reader to the next node.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual void ReadStartElement(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The qualified name of the element.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Xml/types/XmlException.html">XmlException</a></td>
<td> <a href="#IsStartElement">XmlReader.IsStartElement</a> returns <b>false</b> or if the  <a href="#Name">XmlReader.Name</a> of the element does not match the given <i>name</i>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> A call to this method corresponds to a call to  <a href="#IsStartElement">XmlReader.IsStartElement</a> followed by a call to  <a href="#Read">XmlReader.Read</a>.</dd>
</dl><b>Example</b><dl>
<dd> The following example parses an XML document using the <b>ReadStartElement</b> and  <a href="#ReadEndElement">XmlReader.ReadEndElement</a> methods.<pre>
using System;
using System.IO;
using System.Xml;

public class Sample 
{
  public static void Main()
  {

     //Create the reader.
     XmlTextReader  reader = new XmlTextReader("book3.xml");

     //Parse the XML document.  ReadString is used to 
     //read the text content of the elements.
     reader.Read(); 
     reader.ReadStartElement("book");  
     reader.ReadStartElement("title");   
     Console.Write("The content of the title element:  ");
     Console.WriteLine(reader.ReadString());
     reader.ReadEndElement();
     reader.ReadStartElement("price");
     Console.Write("The content of the price element:  ");
     Console.WriteLine(reader.ReadString());
     reader.ReadEndElement();
     reader.ReadEndElement();

     //Close the reader.
     reader.Close();
     
  }
} // End class

    </pre> The example uses the file, <b>book3.xml</b>, as input.<pre>
&lt;book&gt;
  &lt;title&gt;Pride And Prejudice&lt;/title&gt;
  &lt;price&gt;19.95&lt;/price&gt;
&lt;/book&gt;

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#ReadEndElement">XmlReader.ReadEndElement</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="ReadStartElementTopic3"></a><a name="ReadStartElement(System.String,System.String)">ReadStartElement</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>localname</i>,</font><br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>ns</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System.Xml/types/XmlReader.html#ReadStartElement(System.String,System.String)">System.Xml.XmlReader.ReadStartElement</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Checks that the current content node is an element with the given  <a href="#LocalName">XmlReader.LocalName</a> and  <a href="#NamespaceURI">XmlReader.NamespaceURI</a> and advances the reader to the next node.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual void ReadStartElement(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>localname</i>,</font><br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>ns</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>localname</i><br><dl>
<dd>
<param> The local name of the element.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>ns</i><br><dl>
<dd>
<param> The namespace URI of the element.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Xml/types/XmlException.html">XmlException</a></td>
<td> <a href="#IsStartElement">XmlReader.IsStartElement</a> returns <b>false</b>, or the  <a href="#LocalName">XmlReader.LocalName</a> and  <a href="#NamespaceURI">XmlReader.NamespaceURI</a> properties of the element found do not match the given arguments.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> A call to this method corresponds to a call to  <a href="#IsStartElement">XmlReader.IsStartElement</a> followed by a call to  <a href="#Read">XmlReader.Read</a>.</dd>
</dl><b>See also: 
			</b><br> <a href="#ReadEndElement">XmlReader.ReadEndElement</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="ReadStringTopic1"></a><a name="ReadString">ReadString</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Reads the contents of an element or text node as a string.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/String.html">string</a> ReadString();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The contents of the element or text node. This can be an empty string if the reader is positioned on something other than an element or text node, or if there is no more text content to return in the current context.<p><b>Note:</b> The text node can be either an element or an attribute text node.</p>
</dd>
</dl><b>Remarks</b><dl>
<dd> If positioned on an element, <b>ReadString</b> concatenates all text, significant whitespace, whitespace and CData section node types together and returns the concatenated data as the element content. The reader stops when any markup is encountered. This could occur in a mixed content model, or when an element end tag is read.<p> If positioned on a text node, <b>ReadString</b> performs the same concatenation from the text node to the element end tag. If the reader is positioned on an attribute text node, <b>ReadString</b> has the same functionality as if the reader were position on the element start tag. It returns all the concatenated element text nodes.</p>
<p> The  <a href="#EntityHandling">XmlValidatingReader.EntityHandling</a> property determines how <b>ReadString</b> works as follows: </p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Value
                </TH>
<TH>
                  Description
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  ExpandEntities
                </TD>
<TD>
                  Returns expanded character and general entities. This is the
                  default.
                </TD>
</TR>
<TR valign="top">
<TD>
                  ExpandCharEntities
                </TD>
<TD>
                  Returns the text content up to but not including a
                  general entity reference. This means a general entity causes ReadString to
                  stop. You must call
                  <b>Read</b>
                  to step over the entity
                  reference.
                </TD>
</TR>
</table>
</dd>
</dl><b>Example</b><dl>
<dd> The following example displays the text content of each of the elements.<pre>
using System;
using System.IO;
using System.Xml;

public class Sample 
{
  public static void Main()
  {
    XmlTextReader txtreader = null;
    XmlValidatingReader reader = null;

    try
    {
       //Implement the readers.
       txtreader = new XmlTextReader("elems.xml");
       reader = new XmlValidatingReader(txtreader);
  
       //Parse the XML and display the text content of each of the elements.
       while (reader.Read()){
         if (reader.IsStartElement()){
           if (reader.IsEmptyElement)
              Console.WriteLine("&lt;{0}/&gt;", reader.Name);
           else{
               Console.Write("&lt;{0}&gt; ", reader.Name);
               reader.Read(); //Read the start tag.
               if (reader.IsStartElement())  //Handle nested elements.
                   Console.Write("\r\n&lt;{0}&gt;", reader.Name);
               Console.WriteLine(reader.ReadString());  //Read the text content of the element.
           }
         }
       } 
       
     } 

     finally 
     {
        if (reader != null)
          reader.Close();
      }
  }
  
} // End class

    </pre> The example uses the file, <b>elems.xml</b>, as input.<pre>
&lt;book&gt;
  &lt;title&gt;Pride And Prejudice&lt;/title&gt;
  &lt;price&gt;19.95&lt;/price&gt;
  &lt;misc/&gt;
&lt;/book&gt;

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="ReadTypedValueTopic1"></a><a name="ReadTypedValue">ReadTypedValue</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Gets the common language runtime type for the specified XML Schema definition language (XSD) type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Object.html">object</a> ReadTypedValue();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The common language runtime type for the specified XML Schema (XSD) type.</dd>
</dl><b>Remarks</b><dl>
<dd> For example, if the type is defined as <b>xsd:int</b> the the runtime type <b>int32</b> is returned for the object. This can be tested using the  <a href="../../System/types/Object.html#GetType">Object.GetType</a> method and cast accordingly. This property always return a subclassed type of object. An object of the type object is never returned. If the reader is positioned on an attribute, this method returns the runtime typed object, but does not change the position of the reader. If the reader is positioned on an element, <b>ReadTypedValue</b> reads any CDATA, text, whitespace, significant whitespace, and comment nodes, returns the runtime typed object and positions the reader on the end tag. Any types that do not have a direct mapping, for example <b>NMTOKENS</b>, are returned as strings.<br><br><b>Note </b> If  <a href="#ValidationType">XmlValidatingReader.ValidationType</a> has been set to ValidationType.None, data type information is not provided from either schemas or DTDs.</dd>
</dl><b>Example</b><dl>
<dd> The following example displays the type information for each of the elements in the XML document.<pre>
using System;
using System.IO;
using System.Xml;
using System.Xml.Schema;

public class Sample{

  public static void Main(){
  
  XmlTextReader tr = new XmlTextReader("booksSchema.xml");
  XmlValidatingReader vr = new XmlValidatingReader(tr);
 
  vr.Schemas.Add(null, "books.xsd");
  vr.ValidationType = ValidationType.Schema;
  vr.ValidationEventHandler += new ValidationEventHandler (ValidationCallBack);
 
  while(vr.Read()){
    if(vr.NodeType == XmlNodeType.Element){
      if(vr.SchemaType is XmlSchemaComplexType){
        XmlSchemaComplexType sct = (XmlSchemaComplexType)vr.SchemaType;
        Console.WriteLine("{0}({1})", vr.Name, sct.Name);
      }
      else{
        object value = vr.ReadTypedValue();
        Console.WriteLine("{0}({1}):{2}", vr.Name, value.GetType().Name, value);
      }
    }
  }
 }

  public static void ValidationCallBack (object sender, ValidationEventArgs args){
    Console.WriteLine("***Validation error");
    Console.WriteLine("\tSeverity:{0}", args.Severity);
    Console.WriteLine("\tMessage  :{0}", args.Message);
  }
}

    </pre>
<p> The example uses the following input files.</p>
<p><b>booksSchema.xml</b></p>
<pre>
&lt;?xml version='1.0'?&gt;
&lt;bookstore xmlns="urn:bookstore-schema"&gt;
  &lt;book genre="autobiography"&gt;
    &lt;title&gt;The Autobiography of Benjamin Franklin&lt;/title&gt;
    &lt;author&gt;
      &lt;first-name&gt;Benjamin&lt;/first-name&gt;
      &lt;last-name&gt;Franklin&lt;/last-name&gt;
    &lt;/author&gt;
    &lt;price&gt;8.99&lt;/price&gt;
  &lt;/book&gt;
  &lt;book genre="novel"&gt;
    &lt;title&gt;The Confidence Man&lt;/title&gt;
    &lt;author&gt;
      &lt;first-name&gt;Herman&lt;/first-name&gt;
      &lt;last-name&gt;Melville&lt;/last-name&gt;
    &lt;/author&gt;
    &lt;price&gt;11.99&lt;/price&gt;
  &lt;/book&gt;
&lt;/bookstore&gt;

    </pre><b>books.xsd</b><pre>
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns="urn:bookstore-schema"
    elementFormDefault="qualified"
    targetNamespace="urn:bookstore-schema"&gt;

 &lt;xsd:element name="bookstore" type="bookstoreType"/&gt;

 &lt;xsd:complexType name="bookstoreType"&gt;
  &lt;xsd:sequence maxOccurs="unbounded"&gt;
   &lt;xsd:element name="book"  type="bookType"/&gt;
  &lt;/xsd:sequence&gt;
 &lt;/xsd:complexType&gt;

 &lt;xsd:complexType name="bookType"&gt;
  &lt;xsd:sequence&gt;
   &lt;xsd:element name="title" type="xsd:string"/&gt;
   &lt;xsd:element name="author" type="authorName"/&gt;
   &lt;xsd:element name="price"  type="xsd:decimal"/&gt;
  &lt;/xsd:sequence&gt;
  &lt;xsd:attribute name="genre" type="xsd:string"/&gt;
 &lt;/xsd:complexType&gt;

 &lt;xsd:complexType name="authorName"&gt;
  &lt;xsd:sequence&gt;
   &lt;xsd:element name="first-name"  type="xsd:string"/&gt;
   &lt;xsd:element name="last-name" type="xsd:string"/&gt;
  &lt;/xsd:sequence&gt;
 &lt;/xsd:complexType&gt;

&lt;/xsd:schema&gt;

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="ResolveEntityTopic1"></a><a name="ResolveEntity">ResolveEntity</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Resolves the entity reference for <b>EntityReference</b> nodes.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override void ResolveEntity();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/InvalidOperationException.html">InvalidOperationException</a></td>
<td> The reader is not positioned on an <b>EntityReference</b> node.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> If the reader is positioned on an <b>EntityReference</b> node (<b>XmlNodeType.EntityReference</b>), if  <a href="#Read">XmlValidatingReader.Read</a> is called after calling this method, the entity replacement text is parsed. When the entity replacement text is finished, an <b>EndEntity</b> node is returned to close the entity reference scope.<br><br><b>Note </b> After calling this method, if the entity is part of an attribute value, you must call  <a href="#ReadAttributeValue">XmlValidatingReader.ReadAttributeValue</a> to step into the entity.</dd>
</dl><b>Example</b><dl>
<dd> The following example uses <b>ResolveEntity</b> to expand a general entity.<pre>
using System;
using System.IO;
using System.Xml;

public class Sample
{
  public static void Main()
  {
     XmlValidatingReader reader = null;
     XmlTextReader txtreader = null;

     try
     {
       //Create and load the XmlTextReader with the XML file. 
       txtreader = new XmlTextReader("book1.xml");
       txtreader.WhitespaceHandling = WhitespaceHandling.None;

       //Create the XmlValidatingReader over the XmlTextReader.
       //Set the reader to not expand general entities.
       reader = new XmlValidatingReader(txtreader);
       reader.ValidationType = ValidationType.None;
       reader.EntityHandling = EntityHandling.ExpandCharEntities;

       reader.MoveToContent();  //Move to the root element.
       reader.Read();  //Move to title start tag.
       reader.Skip();  //Skip the title element.
      
       //Read the misc start tag.  The reader is now positioned on
       //the entity reference node.
       reader.ReadStartElement(); 

       //Because EntityHandling is set to ExpandCharEntities, you must call 
       //ResolveEntity to expand the entity.  The entity replacement text is 
       //then parsed and returned as a child node.  
       
       Console.WriteLine("Expand the entity...");
       reader.ResolveEntity();  

       Console.WriteLine("The entity replacement text is returned as a text node.");
       reader.Read();  
       Console.WriteLine("NodeType: {0} Value: {1}", reader.NodeType ,reader.Value);

       Console.WriteLine("An EndEntity node closes the entity reference scope.");
       reader.Read();
       Console.WriteLine("NodeType: {0} Name: {1}", reader.NodeType,reader.Name);
     
    }
    finally
    {
       if (reader != null)
         reader.Close();
    }
  }
}

    </pre> The example uses the file, <b>book1.xml</b>, as input.<pre>

&lt;?xml version='1.0' ?&gt;
&lt;!DOCTYPE book [&lt;!ENTITY h 'hardcover'&gt;]&gt;
&lt;book&gt;
  &lt;title&gt;Pride And Prejudice&lt;/title&gt;
  &lt;misc&gt;&amp;h;&lt;/misc&gt;
&lt;/book&gt;

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Xml/types/EntityHandling.html">EntityHandling</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="SkipTopic1"></a><a name="Skip">Skip</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System.Xml/types/XmlReader.html#Skip">System.Xml.XmlReader.Skip</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Skips the children of the current node.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual void Skip();</b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> In the following XML input if the reader is positioned on the <code>
                &lt;a&gt;
              </code> node or any of its attributes, calling <b>Skip</b> positions the reader to the <code>
                &lt;b&gt;
              </code> node.<p> If the reader is positioned on a leaf node already (such as the <code>
                &lt;x&gt;
              </code> node or the text node <code>
                abc
              </code>), calling <b>Skip</b> is the same as calling  <a href="#Read">XmlReader.Read</a>.</p>
<pre>
              &lt;a name="bob" age="123"&gt;
               &lt;x/&gt;abc&lt;y/&gt;
               &lt;/a&gt;
               &lt;b&gt;
               ...
               &lt;/b&gt;
            </pre>
<p> This method checks for well-formed XML.</p>
<p> If the reader is an  <a href="../../System.Xml/types/XmlValidatingReader.html">XmlValidatingReader</a>, this method also validates the skipped content.</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following example parses an XML file starting on the second book node.<pre>
using System;
using System.IO;
using System.Xml;

public class Sample 
{
  public static void Main()
  {
    XmlTextReader reader = null;

    try
    {

       //Load the XmlTextReader 
       reader = new XmlTextReader("2books.xml");
       reader.WhitespaceHandling = WhitespaceHandling.None;

       //Move the reader to the second book node.
       reader.MoveToContent(); 
       reader.Read();
       reader.Skip(); //Skip the first book.
  

        //Parse the file starting with the second book node.
        while (reader.Read())
        {
           switch (reader.NodeType)
           {
             case XmlNodeType.Element:
               Console.Write("&lt;{0}", reader.Name);
               while (reader.MoveToNextAttribute()){
                 Console.Write(" {0}='{1}'", reader.Name, reader.Value);
               }
               Console.Write("&gt;");
               break;
             case XmlNodeType.Text:
               Console.Write(reader.Value);
               break;
             case XmlNodeType.EndElement:
               Console.Write("&lt;/{0}&gt;", reader.Name);
               break;
           }       
         }           

     } 
     finally 
     {
        if (reader != null)
          reader.Close();
      }
  } 
} // End class

    </pre> The example uses the file, <b>2books.xml</b>, as input.<pre>

&lt;!--sample XML fragment--&gt;
&lt;bookstore&gt;
  &lt;book genre='novel' ISBN='10-861003-324'&gt;
    &lt;title&gt;The Handmaid's Tale&lt;/title&gt;
    &lt;price&gt;19.95&lt;/price&gt;
  &lt;/book&gt;
  &lt;book genre='novel' ISBN='1-861001-57-5'&gt;
    &lt;title&gt;Pride And Prejudice&lt;/title&gt;
    &lt;price&gt;24.95&lt;/price&gt;
  &lt;/book&gt;
&lt;/bookstore&gt;

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="ToStringTopic1"></a><a name="ToString">ToString</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#ToString">System.Object.ToString</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual string ToString();</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Event: <i><a name="ValidationEventHandlerTopic1"></a><a name="ValidationEventHandler">ValidationEventHandler</a></i></b><b><i></i></b><dl>
<dt><b>Summary</b></dt>
<dd> Sets an event handler for receiving information about DTD, XML-Data Reduced (XDR) schema, and XML Schema definition language (XSD) schema validation errors.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public event ValidationEventHandler ValidationEventHandler;
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> These events occur during  <a href="#Read">XmlValidatingReader.Read</a> and only if a  <a href="#ValidationType">XmlValidatingReader.ValidationType</a> of DTD, XDR, Schema, or Auto is specified.<p> If no event handler is provided an  <a href="../../System.Xml/types/XmlException.html">XmlException</a> is thrown on the first validation error (Severity is equal to XmlSeverityType.Error).</p><br><br><b>Note </b> If an element reports a validation error, the rest of the content model for that element is not validated, however, its children are validated. The reader only reports the first error for a given element.<p> The callback handler can use the  <a href="../../System.Xml.Schema/types/ValidationEventArgs.html#Severity">ValidationEventArgs.Severity</a> property to guarantee that an XML instance document is validated against a schema. The <b>Severity</b> property allows you to distinguish between validation errors (Severity is equal to XmlSeverityType.Error) thatindicates a fatal error, and validation warnings (Severity is equal to XmlSeverityType.Warning) that indicates that no schema information is available.</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following example validates a file against an XML Schema (XSD).<pre>
using System;
using System.IO;
using System.Xml;
using System.Xml.Schema;

public class Sample
{

  private XmlTextReader txtreader = null;
  private XmlValidatingReader reader = null;
  private Boolean m_success = true;

  public Sample ()
  {
        //Validate file against the XSD schema. 
        //The validation should fail.
        Validate("notValidXSD.xml"); 
  }    

  public static void Main ()
  {
      Sample validation = new Sample();
  }

  private void Validate(String filename)
  {    
     try
     {
        Console.WriteLine("Validating XML file " + filename.ToString());
        txtreader = new XmlTextReader (filename);
        reader = new XmlValidatingReader (txtreader);

        // Set the validation event handler
        reader.ValidationEventHandler += new ValidationEventHandler (this.ValidationEventHandle);

        // Read XML data
        while (reader.Read()){}
        Console.WriteLine ("Validation finished. Validation {0}", (m_success==true ? "successful" : "failed"));
     }

     finally
     {
        //Close the reader.
        if (reader != null)
          reader.Close();
     } 
  }

  //Display the validation error.
  public void ValidationEventHandle (object sender, ValidationEventArgs args)
  {
     m_success = false;
     Console.WriteLine("\r\n\tValidation error: " + args.Message );
  }
}

    </pre>
<p> The sample uses the following two input files: </p>
<p><b>notValidXSD.xml</b> (The <b>xsi:schemaLocation</b> attribute identifies the XML Schema (XSD) for the reader.) </p>
<pre>

&lt;?xml version='1.0'?&gt;
&lt;bookstore xmlns="urn:bookstore-schema"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="urn:bookstore-schema books.xsd"&gt;
  &lt;book&gt;
    &lt;author&gt;
      &lt;first-name&gt;Benjamin&lt;/first-name&gt;
      &lt;last-name&gt;Franklin&lt;/last-name&gt;
    &lt;/author&gt;
  &lt;/book&gt;
  &lt;book genre="novel"&gt;
    &lt;title&gt;The Confidence Man&lt;/title&gt;
    &lt;author&gt;
      &lt;first-name&gt;Herman&lt;/first-name&gt;
      &lt;last-name&gt;Melville&lt;/last-name&gt;
    &lt;/author&gt;
    &lt;price&gt;11.99&lt;/price&gt;
  &lt;/book&gt;
&lt;/bookstore&gt;

    </pre>
<p><b>books.xsd</b></p>
<pre>

&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns="urn:bookstore-schema"
    elementFormDefault="qualified"
    targetNamespace="urn:bookstore-schema"&gt;

 &lt;xsd:element name="bookstore" type="bookstoreType"/&gt;

 &lt;xsd:complexType name="bookstoreType"&gt;
  &lt;xsd:sequence maxOccurs="unbounded"&gt;
   &lt;xsd:element name="book"  type="bookType"/&gt;
  &lt;/xsd:sequence&gt;
 &lt;/xsd:complexType&gt;

 &lt;xsd:complexType name="bookType"&gt;
  &lt;xsd:sequence&gt;
   &lt;xsd:element name="title" type="xsd:string"/&gt;
   &lt;xsd:element name="author" type="authorName"/&gt;
   &lt;xsd:element name="price"  type="xsd:decimal"/&gt;
  &lt;/xsd:sequence&gt;
  &lt;xsd:attribute name="genre" type="xsd:string"/&gt;
 &lt;/xsd:complexType&gt;

 &lt;xsd:complexType name="authorName"&gt;
  &lt;xsd:sequence&gt;
   &lt;xsd:element name="first-name"  type="xsd:string"/&gt;
   &lt;xsd:element name="last-name" type="xsd:string"/&gt;
  &lt;/xsd:sequence&gt;
 &lt;/xsd:complexType&gt;

&lt;/xsd:schema&gt;

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Xml.Schema/types/XmlSeverityType.html">XmlSeverityType</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite">
<h3 align="center"><a href="#TopOfPage">
					Top of page
				</a></h3><i><a href="../../documentation_license.txt">
				  Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
				</a></i></body>
</html>
