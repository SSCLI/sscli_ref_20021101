<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../refdoc.css">
<title>Type: System.Reflection.Emit.EnumBuilder</title>
</head>
<body><a name="TopOfPage"></a><h2>System.Reflection.Emit.EnumBuilder Class</h2><b>Assembly: </b>Mscorlib.dll<br><b>Namespace: </b>System.Reflection.Emit<br><dl>
<dt><b>Summary</b></dt>
<dd> Describes and represents an enumeration type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
        public sealed class EnumBuilder : Type
      </b></code></td>
</tr>
</table>
</dd>
</dl><b>Thread Safety</b><br><dl>
<dd> Reflection Emit is thread-safe when using assemblies that were created with the  <a href="../../System/types/AppDomain.html#DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">AppDomain.DefineDynamicAssembly</a> method with the Boolean parameter <i>isSynchronized</i> set to <b>true</b>.</dd>
</dl><b>See also: </b><dl>
<dd> <a href="../../System.Reflection.Emit/System.Reflection.Emit.html">System.Reflection.Emit Namespace</a></dd>
</dl>
<h3>System.Reflection.Emit.EnumBuilder Member List: </h3>
<dl>
<dt><b>Public Properties</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#Assembly">Assembly</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Retrieves the dynamic assembly that contains this enum definition.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#AssemblyQualifiedName">AssemblyQualifiedName</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Returns the full path of this enum qualified by the display name of the parent assembly.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Attributes">Attributes</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#Attributes">System.Type.Attributes</a></font></b><br><br><br> Gets the attributes associated with the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#BaseType">BaseType</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Returns the parent  <a href="../../System/types/Type.html">Type</a> of this type which is always  <a href="../../System/types/Enum.html">Enum</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#DeclaringType">DeclaringType</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Returns the type that declared this  <a href="../../System.Reflection.Emit/types/EnumBuilder.html">EnumBuilder</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#FullName">FullName</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Returns the full path of this enum.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GUID">GUID</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Returns the GUID of this enum.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#HasElementType">HasElementType</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#HasElementType">System.Type.HasElementType</a></font></b><br><br><br> Gets a value indicating whether the current  <a href="../../System/types/Type.html">Type</a> encompasses or refers to another type; that is, whether the current  <a href="../../System/types/Type.html">Type</a> is an array, a pointer, or is passed by reference.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsAbstract">IsAbstract</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsAbstract">System.Type.IsAbstract</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is abstract and must be overridden.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsAnsiClass">IsAnsiClass</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsAnsiClass">System.Type.IsAnsiClass</a></font></b><br><br><br> Gets a value indicating whether the string format attribute <b>AnsiClass</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsArray">IsArray</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsArray">System.Type.IsArray</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is an array.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsAutoClass">IsAutoClass</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsAutoClass">System.Type.IsAutoClass</a></font></b><br><br><br> Gets a value indicating whether the string format attribute <b>AutoClass</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsAutoLayout">IsAutoLayout</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsAutoLayout">System.Type.IsAutoLayout</a></font></b><br><br><br> Gets a value indicating whether the class layout attribute <b>AutoLayout</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsByRef">IsByRef</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsByRef">System.Type.IsByRef</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is passed by reference.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsClass">IsClass</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsClass">System.Type.IsClass</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is a class; that is, not a value type or interface.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsCOMObject">IsCOMObject</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsCOMObject">System.Type.IsCOMObject</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is a COM object.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsContextful">IsContextful</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsContextful">System.Type.IsContextful</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> can be hosted in a context.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsEnum">IsEnum</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsEnum">System.Type.IsEnum</a></font></b><br><br><br> Gets a value indicating whether the current  <a href="../../System/types/Type.html">Type</a> represents an enumeration.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsExplicitLayout">IsExplicitLayout</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsExplicitLayout">System.Type.IsExplicitLayout</a></font></b><br><br><br> Gets a value indicating whether the class layout attribute <b>ExplicitLayout</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsImport">IsImport</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsImport">System.Type.IsImport</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> was imported from another class.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsInterface">IsInterface</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsInterface">System.Type.IsInterface</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is an interface; that is, not a class or a value type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsLayoutSequential">IsLayoutSequential</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsLayoutSequential">System.Type.IsLayoutSequential</a></font></b><br><br><br> Gets a value indicating whether the class layout attribute <b>SequentialLayout</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsMarshalByRef">IsMarshalByRef</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsMarshalByRef">System.Type.IsMarshalByRef</a></font></b><br><br><br> Gets a value indicating whether the Type is marshaled by reference.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsNestedAssembly">IsNestedAssembly</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsNestedAssembly">System.Type.IsNestedAssembly</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is nested and visible only within its own assembly.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsNestedFamANDAssem">IsNestedFamANDAssem</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsNestedFamANDAssem">System.Type.IsNestedFamANDAssem</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is nested and visible only to classes that belong to both its own family and its own assembly.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsNestedFamily">IsNestedFamily</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsNestedFamily">System.Type.IsNestedFamily</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is nested and visible only within its own family.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsNestedFamORAssem">IsNestedFamORAssem</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsNestedFamORAssem">System.Type.IsNestedFamORAssem</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is nested and visible only to classes that belong to either its own family or to its own assembly.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsNestedPrivate">IsNestedPrivate</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsNestedPrivate">System.Type.IsNestedPrivate</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is nested and declared private.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsNestedPublic">IsNestedPublic</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsNestedPublic">System.Type.IsNestedPublic</a></font></b><br><br><br> Gets a value indicating whether a class is nested and declared public.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsNotPublic">IsNotPublic</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsNotPublic">System.Type.IsNotPublic</a></font></b><br><br><br> Gets a value indicating whether the top-level  <a href="../../System/types/Type.html">Type</a> is not declared public.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsPointer">IsPointer</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsPointer">System.Type.IsPointer</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is a pointer.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsPrimitive">IsPrimitive</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsPrimitive">System.Type.IsPrimitive</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is one of the primitive types.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsPublic">IsPublic</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsPublic">System.Type.IsPublic</a></font></b><br><br><br> Gets a value indicating whether the top-level  <a href="../../System/types/Type.html">Type</a> is declared public.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsSealed">IsSealed</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsSealed">System.Type.IsSealed</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is declared sealed.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsSerializable">IsSerializable</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsSerializable">System.Type.IsSerializable</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is serializable.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsSpecialName">IsSpecialName</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsSpecialName">System.Type.IsSpecialName</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> has a name that requires special handling.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsUnicodeClass">IsUnicodeClass</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsUnicodeClass">System.Type.IsUnicodeClass</a></font></b><br><br><br> Gets a value indicating whether the string format attribute <b>UnicodeClass</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsValueType">IsValueType</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsValueType">System.Type.IsValueType</a></font></b><br><br><br> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is a value type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#MemberType">MemberType</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#MemberType">System.Type.MemberType</a></font></b><br><br><br> Gets a bitmask indicating the member type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Module">Module</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Retrieves the dynamic module that contains this  <a href="../../System.Reflection.Emit/types/EnumBuilder.html">EnumBuilder</a> definition.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Name">Name</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Returns the name of this enum.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Namespace">Namespace</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br></td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ReflectedType">ReflectedType</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Returns the type that was used to obtain this  <a href="../../System.Reflection.Emit/types/EnumBuilder.html">EnumBuilder</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#TypeHandle">TypeHandle</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Retrieves the internal handle for this enum.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#TypeInitializer">TypeInitializer</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Read-only</b><br><br><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#TypeInitializer">System.Type.TypeInitializer</a></font></b><br><br><br> Gets the initializer for the  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#TypeToken">TypeToken</a></td>
<td width="55%"><b>Read-only</b><br><br> Returns the internal metadata type token of this enum.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#UnderlyingField">UnderlyingField</a></td>
<td width="55%"><b>Read-only</b><br><br> Returns the underlying field for this enum.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#UnderlyingSystemType">UnderlyingSystemType</a></td>
<td width="55%"><b>Read-only</b><br><br><b>Overridden: </b><br> Returns the underlying system type for this enum.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Public Methods</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#CreateType">CreateType</a></td>
<td width="55%"> Creates a  <a href="../../System/types/Type.html">Type</a> object for this enum.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#DefineLiteral(System.String,System.Object)">DefineLiteral</a></td>
<td width="55%"> Defines the named static field in an enumeration type with the specified constant value.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Equals(System.Object)">Equals</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>Equals(object o)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#Equals(System.Object)">System.Type.Equals</a></font></b><br><br><br> Determines if the underlying system type of the current  <a href="../../System/types/Type.html">Type</a> is the same as the underlying system type of the specified  <a href="../../System/types/Object.html">Object</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#Equals(System.Type)">Equals</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>Equals(Type o)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#Equals(System.Type)">System.Type.Equals</a></font></b><br><br><br> Determines if the underlying system type of the current  <a href="../../System/types/Type.html">Type</a> is the same as the underlying system type of the specified  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#FindInterfaces(System.Reflection.TypeFilter,System.Object)">FindInterfaces</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#FindInterfaces(System.Reflection.TypeFilter,System.Object)">System.Type.FindInterfaces</a></font></b><br><br><br> Returns an array of  <a href="../../System/types/Type.html">Type</a> objects representing a filtered list of interfaces implemented or inherited by the current  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">FindMembers</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">System.Type.FindMembers</a></font></b><br><br><br> Returns a filtered array of  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> objects of the specified member type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetArrayRank">GetArrayRank</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetArrayRank">System.Type.GetArrayRank</a></font></b><br><br><br> Gets the number of dimensions in an  <a href="../../System/types/Array.html">Array</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetConstructor(System.Type[])">GetConstructor</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetConstructor(Type[] types)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetConstructor(System.Type[])">System.Type.GetConstructor</a></font></b><br><br><br> Searches for a public instance constructor whose parameters match the types in the specified array.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">GetConstructor</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">System.Type.GetConstructor</a></font></b><br><br><br> Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">GetConstructor</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetConstructor(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">System.Type.GetConstructor</a></font></b><br><br><br> Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetConstructors">GetConstructors</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetConstructors()<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetConstructors">System.Type.GetConstructors</a></font></b><br><br><br> Returns all the public constructors defined for the current  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetConstructors(System.Reflection.BindingFlags)">GetConstructors</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetConstructors(BindingFlags bindingAttr)<br><br></code><b>Overridden: </b><br> Returns an array of  <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> objects representing the public and non-public constructors defined for this class, as specified.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetCustomAttributes(System.Boolean)">GetCustomAttributes</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetCustomAttributes(bool inherit)<br><br></code><b>Overridden: </b><br> Returns all the custom attributes defined for this constructor.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetCustomAttributes(System.Type,System.Boolean)">GetCustomAttributes</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetCustomAttributes(Type attributeType, bool inherit)<br><br></code><b>Overridden: </b><br> Returns the custom attributes identified by the given type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetDefaultMembers">GetDefaultMembers</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetDefaultMembers">System.Type.GetDefaultMembers</a></font></b><br><br><br> Searches for the members defined for the current  <a href="../../System/types/Type.html">Type</a> whose  <a href="../../System.Reflection/types/DefaultMemberAttribute.html">DefaultMemberAttribute</a> is set.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetElementType">GetElementType</a></td>
<td width="55%"><b>Overridden: </b><br> Calling this method always throws  <a href="../../System/types/NotSupportedException.html">NotSupportedException</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetEvent(System.String)">GetEvent</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetEvent(string name)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetEvent(System.String)">System.Type.GetEvent</a></font></b><br><br><br> Returns the  <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> object representing the specified event.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetEvent(System.String,System.Reflection.BindingFlags)">GetEvent</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetEvent(string name, BindingFlags bindingAttr)<br><br></code><b>Overridden: </b><br> Returns the event with the specified name.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetEvents">GetEvents</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetEvents()<br><br></code><b>Overridden: </b><br> Returns the events for the public events declared or inherited by this type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetEvents(System.Reflection.BindingFlags)">GetEvents</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetEvents(BindingFlags bindingAttr)<br><br></code><b>Overridden: </b><br> Returns the public and non-public events that are declared by this type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetField(System.String)">GetField</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetField(string name)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetField(System.String)">System.Type.GetField</a></font></b><br><br><br> Searches for the field with the specified name.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetField(System.String,System.Reflection.BindingFlags)">GetField</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetField(string name, BindingFlags bindingAttr)<br><br></code><b>Overridden: </b><br> Returns the field specified by the given name.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetFields">GetFields</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetFields()<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetFields">System.Type.GetFields</a></font></b><br><br><br> Returns all the public fields of the current  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetFields(System.Reflection.BindingFlags)">GetFields</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetFields(BindingFlags bindingAttr)<br><br></code><b>Overridden: </b><br> Returns the public and non-public fields that are declared by this type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetHashCode">GetHashCode</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetHashCode">System.Type.GetHashCode</a></font></b><br><br><br> Returns the hash code for this instance.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetInterface(System.String)">GetInterface</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetInterface(string name)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetInterface(System.String)">System.Type.GetInterface</a></font></b><br><br><br> Searches for the interface with the specified name.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetInterface(System.String,System.Boolean)">GetInterface</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetInterface(string name, bool ignoreCase)<br><br></code><b>Overridden: </b><br> Returns the interface implemented (directly or indirectly) by this class with the fully-qualified name matching the given interface name.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetInterfaceMap(System.Type)">GetInterfaceMap</a></td>
<td width="55%"><b>Overridden: </b><br> Returns an interface mapping for the interface requested.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetInterfaces">GetInterfaces</a></td>
<td width="55%"><b>Overridden: </b><br> Returns an array of all the interfaces implemented on this a class and its base classes.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMember(System.String)">GetMember</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMember(string name)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetMember(System.String)">System.Type.GetMember</a></font></b><br><br><br> Searches for the members with the specified name.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMember(System.String,System.Reflection.BindingFlags)">GetMember</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMember(string name, BindingFlags bindingAttr)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetMember(System.String,System.Reflection.BindingFlags)">System.Type.GetMember</a></font></b><br><br><br> Searches for the specified members, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">GetMember</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMember(string name, MemberTypes type, BindingFlags bindingAttr)<br><br></code><b>Overridden: </b><br> Returns all the public and non-public members declared or inherited by this type, as specified.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMembers">GetMembers</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMembers()<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetMembers">System.Type.GetMembers</a></font></b><br><br><br> Returns all the public members of the current  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMembers(System.Reflection.BindingFlags)">GetMembers</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMembers(BindingFlags bindingAttr)<br><br></code><b>Overridden: </b><br> Returns all the public and non-public members declared or inherited by this type, as specified.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMethod(System.String)">GetMethod</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMethod(string name)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetMethod(System.String)">System.Type.GetMethod</a></font></b><br><br><br> Searches for the public method with the specified name.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMethod(System.String,System.Reflection.BindingFlags)">GetMethod</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMethod(string name, BindingFlags bindingAttr)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetMethod(System.String,System.Reflection.BindingFlags)">System.Type.GetMethod</a></font></b><br><br><br> Searches for the specified method, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMethod(System.String,System.Type[])">GetMethod</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMethod(string name, Type[] types)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetMethod(System.String,System.Type[])">System.Type.GetMethod</a></font></b><br><br><br> Searches for the specified public method whose parameters match the specified argument types.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">GetMethod</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMethod(string name, Type[] types, ParameterModifier[] modifiers)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">System.Type.GetMethod</a></font></b><br><br><br> Searches for the specified public method whose parameters match the specified argument types and modifiers.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">GetMethod</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">System.Type.GetMethod</a></font></b><br><br><br> Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">GetMethod</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">System.Type.GetMethod</a></font></b><br><br><br> Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMethods">GetMethods</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMethods()<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetMethods">System.Type.GetMethods</a></font></b><br><br><br> Returns all the public methods of the current  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMethods(System.Reflection.BindingFlags)">GetMethods</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetMethods(BindingFlags bindingAttr)<br><br></code><b>Overridden: </b><br> Returns all the public and non-public methods declared or inherited by this type, as specified.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetNestedType(System.String)">GetNestedType</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetNestedType(string name)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetNestedType(System.String)">System.Type.GetNestedType</a></font></b><br><br><br> Searches for the nested type with the specified name.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetNestedType(System.String,System.Reflection.BindingFlags)">GetNestedType</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetNestedType(string name, BindingFlags bindingAttr)<br><br></code><b>Overridden: </b><br> Returns the public and non-public nested types that are declared by this type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetNestedTypes">GetNestedTypes</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetNestedTypes()<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetNestedTypes">System.Type.GetNestedTypes</a></font></b><br><br><br> Returns all the types nested within the current  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetNestedTypes(System.Reflection.BindingFlags)">GetNestedTypes</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetNestedTypes(BindingFlags bindingAttr)<br><br></code><b>Overridden: </b><br> Returns the public and non-public nested types that are declared or inherited by this type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetProperties">GetProperties</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetProperties()<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetProperties">System.Type.GetProperties</a></font></b><br><br><br> Returns all the public properties of the current  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetProperties(System.Reflection.BindingFlags)">GetProperties</a></td>
<td width="55%"><b>Overloaded:</b><br><code>GetProperties(BindingFlags bindingAttr)<br><br></code><b>Overridden: </b><br> Returns all the public and non-public properties declared or inherited by this type, as specified.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetProperty(System.String)">GetProperty</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetProperty(string name)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetProperty(System.String)">System.Type.GetProperty</a></font></b><br><br><br> Searches for the public property with the specified name.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetProperty(System.String,System.Reflection.BindingFlags)">GetProperty</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetProperty(string name, BindingFlags bindingAttr)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetProperty(System.String,System.Reflection.BindingFlags)">System.Type.GetProperty</a></font></b><br><br><br> Searches for the specified property, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetProperty(System.String,System.Type)">GetProperty</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetProperty(string name, Type returnType)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetProperty(System.String,System.Type)">System.Type.GetProperty</a></font></b><br><br><br> Searches for the public property with the specified name and return type.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetProperty(System.String,System.Type[])">GetProperty</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetProperty(string name, Type[] types)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetProperty(System.String,System.Type[])">System.Type.GetProperty</a></font></b><br><br><br> Searches for the specified public property whose parameters match the specified argument types.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetProperty(System.String,System.Type,System.Type[])">GetProperty</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetProperty(string name, Type returnType, Type[] types)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetProperty(System.String,System.Type,System.Type[])">System.Type.GetProperty</a></font></b><br><br><br> Searches for the specified public property whose parameters match the specified argument types.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">GetProperty</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetProperty(string name, Type returnType, Type[] types, ParameterModifier[] modifiers)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">System.Type.GetProperty</a></font></b><br><br><br> Searches for the specified public property whose parameters match the specified argument types and modifiers.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">GetProperty</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">System.Type.GetProperty</a></font></b><br><br><br> Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetType">GetType</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#GetType">System.Object.GetType</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">InvokeMember</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">System.Type.InvokeMember</a></font></b><br><br><br> Invokes the specified member, using the specified binding constraints and matching the specified argument list.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">InvokeMember</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b>Overloaded:</b><br><code>InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, CultureInfo culture)<br><br></code><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">System.Type.InvokeMember</a></font></b><br><br><br> Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">InvokeMember</a></td>
<td width="55%"><b>Overloaded:</b><br><code>InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters)<br><br></code><b>Overridden: </b><br> Invokes the specified member. The method that is to be invoked must be accessible and provide the most specific match with the specified argument list, under the contraints of the specified binder and invocation attributes.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsAssignableFrom(System.Type)">IsAssignableFrom</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsAssignableFrom(System.Type)">System.Type.IsAssignableFrom</a></font></b><br><br><br> Determines whether an instance of the current  <a href="../../System/types/Type.html">Type</a> can be assigned from an instance of the specified <b>Type</b>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsDefined(System.Type,System.Boolean)">IsDefined</a></td>
<td width="55%"><b>Overridden: </b><br> Checks if the specified custom attribute type is defined.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsInstanceOfType(System.Object)">IsInstanceOfType</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsInstanceOfType(System.Object)">System.Type.IsInstanceOfType</a></font></b><br><br><br> Determines whether the specified object is an instance of the current  <a href="../../System/types/Type.html">Type</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsSubclassOf(System.Type)">IsSubclassOf</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsSubclassOf(System.Type)">System.Type.IsSubclassOf</a></font></b><br><br><br> Determines whether the current  <a href="../../System/types/Type.html">Type</a> derives from the specified <b>Type</b>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">SetCustomAttribute</a></td>
<td width="55%"><b>Overloaded:</b><br><code>SetCustomAttribute(CustomAttributeBuilder customBuilder)<br><br></code> Sets a custom attribute using a custom attribute builder.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">SetCustomAttribute</a></td>
<td width="55%"><b>Overloaded:</b><br><code>SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute)<br><br></code> Sets a custom attribute using a specified custom attribute blob.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ToString">ToString</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#ToString">System.Type.ToString</a></font></b><br><br><br> Returns a <b>String</b> representing the name of the current <b>Type</b>.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Protected Methods</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#Finalize">Finalize</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#Finalize">System.Object.Finalize</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetAttributeFlagsImpl">GetAttributeFlagsImpl</a></td>
<td width="55%"><b>Overridden: </b><br> Gets the implementation attribute flags.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">GetConstructorImpl</a></td>
<td width="55%"><b>Overridden: </b><br> Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">GetMethodImpl</a></td>
<td width="55%"><b>Overridden: </b><br> Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">GetPropertyImpl</a></td>
<td width="55%"><b>Overridden: </b><br> Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#HasElementTypeImpl">HasElementTypeImpl</a></td>
<td width="55%"><b>Overridden: </b><br> Calling this method always throws  <a href="../../System/types/NotSupportedException.html">NotSupportedException</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsArrayImpl">IsArrayImpl</a></td>
<td width="55%"><b>Overridden: </b><br></td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsByRefImpl">IsByRefImpl</a></td>
<td width="55%"><b>Overridden: </b><br> Returns <b>false</b>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsCOMObjectImpl">IsCOMObjectImpl</a></td>
<td width="55%"><b>Overridden: </b><br></td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsContextfulImpl">IsContextfulImpl</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsContextfulImpl">System.Type.IsContextfulImpl</a></font></b><br><br><br> Implements the  <a href="#IsContextful">Type.IsContextful</a> property and determines whether the  <a href="../../System/types/Type.html">Type</a> can be hosted in a context.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsMarshalByRefImpl">IsMarshalByRefImpl</a><br>(inherited from <b>System.Type)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Type.html#IsMarshalByRefImpl">System.Type.IsMarshalByRefImpl</a></font></b><br><br><br> Implements the  <a href="#IsMarshalByRef">Type.IsMarshalByRef</a> property and determines whether the  <a href="../../System/types/Type.html">Type</a> is marshalled by reference.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsPointerImpl">IsPointerImpl</a></td>
<td width="55%"><b>Overridden: </b><br> Returns <b>false</b>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsPrimitiveImpl">IsPrimitiveImpl</a></td>
<td width="55%"><b>Overridden: </b><br></td>
</tr>
<tr valign="top">
<td width="35%"><a href="#IsValueTypeImpl">IsValueTypeImpl</a></td>
<td width="55%"><b>Overridden: </b><br></td>
</tr>
<tr valign="top">
<td width="35%"><a href="#MemberwiseClone">MemberwiseClone</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#MemberwiseClone">System.Object.MemberwiseClone</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
</table>
</dd>
</dl>
<p><b>Hierarchy:</b><ul class="none">
<li><a href="../../System/types/Object.html">System.Object</a></li>
<ul class="none">
<li><a href="../../System.Reflection/types/MemberInfo.html">System.Reflection.MemberInfo</a></li>
<ul class="none">
<li><a href="../../System/types/Type.html">System.Type</a></li>
<ul class="none">
<li><b>System.Reflection.Emit.EnumBuilder</b></li>
</ul>
</ul>
</ul>
</ul>
</p>
<hr>
<h3>System.Reflection.Emit.EnumBuilder Member Details</h3><b>Overridden Property: <i><a name="AssemblyTopic1"></a><a name="Assembly">Assembly</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Retrieves the dynamic assembly that contains this enum definition.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Reflection/types/Assembly.html">Assembly</a> Assembly {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="AssemblyQualifiedNameTopic1"></a><a name="AssemblyQualifiedName">AssemblyQualifiedName</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns the full path of this enum qualified by the display name of the parent assembly.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/String.html">string</a> AssemblyQualifiedName {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> If  <a href="#CreateType">EnumBuilder.CreateType</a> has not been called previously.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The format of the returned string is: <p> &lt;FullTypeName&gt;, &lt;AssemblyDisplayName&gt; </p>
<p> See  <a href="../../System.Reflection/types/AssemblyName.html">AssemblyName</a> for a description of the format of the display name of an assembly.</p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="AttributesTopic1"></a><a name="Attributes">Attributes</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#Attributes">System.Type.Attributes</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the attributes associated with the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> Attributes {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd></dd>
</dl><b>See also: 
			</b><br> <a href="#GetAttributeFlagsImpl">Type.GetAttributeFlagsImpl</a> |  <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="BaseTypeTopic1"></a><a name="BaseType">BaseType</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns the parent  <a href="../../System/types/Type.html">Type</a> of this type which is always  <a href="../../System/types/Enum.html">Enum</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Type.html">Type</a> BaseType {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="DeclaringTypeTopic1"></a><a name="DeclaringType">DeclaringType</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns the type that declared this  <a href="../../System.Reflection.Emit/types/EnumBuilder.html">EnumBuilder</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Type.html">Type</a> DeclaringType {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="FullNameTopic1"></a><a name="FullName">FullName</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns the full path of this enum.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/String.html">string</a> FullName {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The returned format is "enclosingTypeFullName+nestedTypeName" for nested types and "typeName" for non-nested types.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="GUIDTopic1"></a><a name="GUID">GUID</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns the GUID of this enum.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Guid.html">Guid</a> GUID {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not currently supported in types that are not complete.</td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="HasElementTypeTopic1"></a><a name="HasElementType">HasElementType</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#HasElementType">System.Type.HasElementType</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the current  <a href="../../System/types/Type.html">Type</a> encompasses or refers to another type; that is, whether the current  <a href="../../System/types/Type.html">Type</a> is an array, a pointer, or is passed by reference.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> HasElementType {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> For example, Type.GetType("Int32[]").HasElementType returns <b>true</b>, but Type.GetType("Int32").HasElementType returns <b>false</b>. HasElementType also returns <b>true</b> for "Int32*" and "Int32&amp;".</dd>
</dl><b>Example</b><dl>
<dd>
<pre>

public class MyClass 
{
}

public class Type_HasElementType
{
   public static void Main()
   {
      try
      {
         // An non array or pointer or reference element. 
         MyClass myObject1 = new MyClass();
         Object myObject2 = myObject1 ; 

         // An object of array type. 
         MyClass[] myObject3 = new MyClass[5];
         Object myObject4 = myObject3 ; 

         Object[] myObjects = new Object[] { myObject1, myObject2, myObject3, myObject4 };
         
         Console.WriteLine("\nCheck whether the object refers to array or pointer or reference type.\n");                     
         for(int i = 0; i &lt; myObjects.Length; i++)
         {
            if(myObjects[i].GetType().HasElementType)
               Console.WriteLine("'myObject{0}' refers to an array or pointer or reference", i);
            else
               Console.WriteLine("'myObject{0}' does not refer to an array or pointer or reference", i);
         }
      }
      catch( Exception e )
      {
         Console.WriteLine( "Exception: {0} \n", e.Message ) ; 
      }	
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#HasElementTypeImpl">Type.HasElementTypeImpl</a> |  <a href="#IsArray">Type.IsArray</a> |  <a href="#IsPointer">Type.IsPointer</a> |  <a href="#IsByRef">Type.IsByRef</a> |  <a href="#GetElementType">Type.GetElementType</a> |  <a href="#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsAbstractTopic1"></a><a name="IsAbstract">IsAbstract</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsAbstract">System.Type.IsAbstract</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is abstract and must be overridden.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsAbstract {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>

public abstract class MyAbstractClass 
{
}

public class MyClass
{
}

public class Type_IsAbstract
{
   public static void Main()
   {
      try
      {
         Console.WriteLine("\nChecking whether the type is abstract\n"); 

         // Check whether the return Type is abstract or not.
         Console.WriteLine("'MyAbstractClass' is {0}", 
            (typeof(MyAbstractClass).IsAbstract) ? 
            "an abstract class" :
            "not an abstract class" );

         // Check whether the return Type is abstract or not.
         Console.WriteLine("'MyClass' is {0}",
            (typeof(MyClass).IsAbstract) ?
            "an abstract class" : 
            "not an abstract class" );
			
      }
      catch( Exception e )
      {
         Console.WriteLine( "Exception: {0} \n", e.Message ); 
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsAnsiClassTopic1"></a><a name="IsAnsiClass">IsAnsiClass</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsAnsiClass">System.Type.IsAnsiClass</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the string format attribute <b>AnsiClass</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsAnsiClass {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#StringFormatMask">TypeAttributes.StringFormatMask</a> selects the string format attributes. The string format attributes enhance interoperability by defining how strings should be interpreted.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
public class MyClass
{
   protected string myField = "A sample protected field" ;
}

public class MyType_IsAnsiClass
{
   public static void Main()
   {
      try
      {
         MyClass myObject = new MyClass();
       
         // Get the type of the 'MyClass'.
         Type myType = typeof(MyClass);

         // Get the field information and the attributes associated with 'MyClass'.
         FieldInfo myFieldInfo = myType.GetField("myField",
            BindingFlags.NonPublic|BindingFlags.Instance);
    
         Console.WriteLine( "\nChecking for AnsiClass attribute for a field\n"); 
         // Get and display the name, field, and the AnsiClass attribute.
         Console.WriteLine("Name of Class: {0} \nValue of Field: {1} \nIsAnsiClass = {2}",
            myType.FullName, myFieldInfo.GetValue(myObject),
            myType.IsAnsiClass);
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception : {0}",e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsUnicodeClass">Type.IsUnicodeClass</a> |  <a href="#IsAutoClass">Type.IsAutoClass</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsArrayTopic1"></a><a name="IsArray">IsArray</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsArray">System.Type.IsArray</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is an array.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsArray {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System/types/Array.html">Array</a> class returns <b>false</b> because it is not an array.<p> This property is read-only.</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following example demonstrates using the <b>IsArray</b> property.<pre>
using System;
class TestIsArray 
{
   public static void Main() 
   {
   int [] array = {1,2,3,4};
   Type at = typeof(Array);
   Type t = array.GetType();
   Console.WriteLine("Type is {0}. IsArray? {1}", at, at.IsArray);
   Console.WriteLine("Type is {0}. IsArray? {1}", t, t.IsArray);
   }
}

    </pre>
<p> This code produces the following output: </p>
<pre>
              				Type is System.Array. IsArray? False
              				Type is System.Int32[]. IsArray? True
              			
            </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#IsArrayImpl">Type.IsArrayImpl</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsAutoClassTopic1"></a><a name="IsAutoClass">IsAutoClass</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsAutoClass">System.Type.IsAutoClass</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the string format attribute <b>AutoClass</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsAutoClass {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#StringFormatMask">TypeAttributes.StringFormatMask</a> selects the string format attributes. The string format attributes enhance interoperability by defining how strings should be interpreted.</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsAnsiClass">Type.IsAnsiClass</a> |  <a href="#IsUnicodeClass">Type.IsUnicodeClass</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsAutoLayoutTopic1"></a><a name="IsAutoLayout">IsAutoLayout</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsAutoLayout">System.Type.IsAutoLayout</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the class layout attribute <b>AutoLayout</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsAutoLayout {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#LayoutMask">TypeAttributes.LayoutMask</a> is used to select the class layout attributes. The class layout attributes (<b>AutoLayout</b><i>,</i><b>SequentialLayout</b> and <b>ExplicitLayout</b>) define how the fields of the class instance are laid out in memory.<p> Use the <b>AutoLayout</b> attribute to let the runtime engine decide the best way to layout the objects of the class. Classes marked with the <b>AutoLayout</b> attribute indicate that the loader will choose the appropriate way to lay out the class; any layout information that may have been specified is ignored.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
// The MyDemoAttribute class is selected as AutoLayout.
[StructLayoutAttribute(LayoutKind.Auto)]
public class MyDemoAttribute
{
}

public class MyTypeClass
{
   public static void Main(string[] args)
   { 
      MyAutoLayoutMethod("MyDemoAttribute");    
   }

    public static void MyAutoLayoutMethod(string typeName)
   {
      try
      {
         // Create an object of 'Type' class using the 'GetType' method.
         Type  myType=Type.GetType(typeName);
         // Get and display the 'IsAutoLayout' property of the 
         // 'MyDemoAttribute' instance.
         Console.WriteLine("\n The 'Autolayout' property for the 'MyDemoAttribute' is: {0}.",myType.IsAutoLayout); 
      }
      catch(Exception e)
      {
         Console.WriteLine("\nThe following exception is raised: {0}." ,e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsLayoutSequential">Type.IsLayoutSequential</a> |  <a href="#IsExplicitLayout">Type.IsExplicitLayout</a> | <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconmetadataoverview.asp">MSDN: metadataoverview</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsByRefTopic1"></a><a name="IsByRef">IsByRef</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsByRef">System.Type.IsByRef</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is passed by reference.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsByRef {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>See also: 
			</b><br> <a href="#IsByRefImpl">Type.IsByRefImpl</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsClassTopic1"></a><a name="IsClass">IsClass</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsClass">System.Type.IsClass</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is a class; that is, not a value type or interface.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsClass {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This property returns <b>true</b> for <b>Type</b> instances representing  <a href="../../System/types/Enum.html">Enum</a> and  <a href="../../System/types/ValueType.html">ValueType</a>.<p> The  <a href="../../System.Reflection/types/TypeAttributes.html#ClassSemanticsMask">TypeAttributes.ClassSemanticsMask</a> distinguishes a type declaration as class, interface, or value type.</p>
<p> This property is read-only.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
public  class MyDemoClass
{
   
}

public class MyTypeClass
{
   public static void Main(string[] args)
   {
      try
      {
         Type  myType=Type.GetType("MyDemoClass");
         // Get and display the 'IsClass' property of the 'MyDemoClass' instance.
         Console.WriteLine("\n'MyDemoClass' is of type 'Class': {0}.", myType.IsClass); 
      }
      catch(Exception e)
      {
         Console.WriteLine("\nThe following exception is raised: {0}." ,e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsInterface">Type.IsInterface</a> |  <a href="#IsValueType">Type.IsValueType</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsCOMObjectTopic1"></a><a name="IsCOMObject">IsCOMObject</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsCOMObject">System.Type.IsCOMObject</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is a COM object.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsCOMObject {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This method returns <b>false</b> for COM interfaces because they are not objects. COM interfaces can be implemented by Microsoft .NET Framework objects.<p> You can also load a COM class and get a <b>Type</b> object for that COM class by using the  tool.</p>
</dd>
</dl><b>See also: 
			</b><br> <a href="#IsCOMObjectImpl">Type.IsCOMObjectImpl</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsContextfulTopic1"></a><a name="IsContextful">IsContextful</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsContextful">System.Type.IsContextful</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> can be hosted in a context.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsContextful {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> A context intercepts calls to the class members and enforces policies that are applied to the class, such as synchronization. For more detailed information on remoting contexts, see  <a href="../../System.Runtime.Remoting.Contexts/types/Context.html">Context</a>.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>

public class MyContextBoundClass: ContextBoundObject
{
   public string myString = "This class demonstrates the isContextful and isMarshalByRef properties.";
}

public class MyTypeDemoClass
{
   public static void Main()
   {
      try
      {
         // Check if the types can be hosted in a Context.
         Console.WriteLine ("The Contextful property for the '{0}' type is: {1}", typeof(MyTypeDemoClass).Name, typeof(MyTypeDemoClass).IsContextful);
         Console.WriteLine ("The Contextful property for the '{0}' type is: {1}", typeof(MyContextBoundClass).Name, typeof(MyContextBoundClass).IsContextful);

         // Check if the types are marshalled by reference.
         Console.WriteLine ("The MarshalByRef property of '{0}' is: {1} ", typeof(MyTypeDemoClass).Name, typeof(MyTypeDemoClass).IsMarshalByRef);
         Console.WriteLine ("The MarshalByRef property of '{0}' is: {1} ", typeof(MyContextBoundClass).Name, typeof(MyContextBoundClass).IsMarshalByRef);
         // Check if the types are primitive datatypes.
         Console.WriteLine ("'{0}' is a primitive datatype : {1} ", typeof(int).Name, typeof(int).IsPrimitive);
         Console.WriteLine ("'{0}' is a primitive datatype : {1} ", typeof(string).Name, typeof(string).IsPrimitive);
      } 
      catch (Exception e)
      {
         Console.WriteLine("The following exception is raised : " + e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#IsContextfulImpl">Type.IsContextfulImpl</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsEnumTopic1"></a><a name="IsEnum">IsEnum</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsEnum">System.Type.IsEnum</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the current  <a href="../../System/types/Type.html">Type</a> represents an enumeration.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsEnum {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This property returns <b>true</b> for an enumeration, but not for the  <a href="../../System/types/Enum.html">Enum</a> type itself, which is a class.<p> This property is read-only.</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following example demonstrates using the <b>IsEnum</b> property.<pre>
using System;
public enum Color 
{
Red, Blue, Green
}
class TestIsEnum 
{
   public static void Main() 
   {
   Type colorType = typeof(Color);
   Type enumType = typeof(Enum);
   Console.WriteLine("Color is enum? {0}", colorType.IsEnum);
   Console.WriteLine("Color is valueType? {0}", colorType.IsValueType);
   Console.WriteLine("Enum is enum Type? {0}", enumType.IsEnum);
   Console.WriteLine("Enum is value? {0}", enumType.IsValueType);
   }
}

    </pre>
<p> This code produces the following output: </p>
<pre>
              				Color is enum? True
              				Color is valueType? True
              				Enum is enum Type? False
              				Enum is value? False
              			
            </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsExplicitLayoutTopic1"></a><a name="IsExplicitLayout">IsExplicitLayout</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsExplicitLayout">System.Type.IsExplicitLayout</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the class layout attribute <b>ExplicitLayout</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsExplicitLayout {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#LayoutMask">TypeAttributes.LayoutMask</a> is used to select the class layout attributes. The class layout attributes (<b>AutoLayout</b><i>,</i><b>SequentialLayout</b> and <b>ExplicitLayout</b>) define how the fields of the class instance are laid out in memory.<p> Classes marked with the <b>ExplicitLayout</b> attribute cause the loader to ignore field sequence and to use the explicit layout rules provided, in the form of field offsets, overall class size and alignment, or all of these.</p>
<p> Use the <b>ExplicitLayout</b> attribute to specify the offsets at which each field starts, or to specify the overall size and, optionally, the packing size of the objects of the class. The packing size is the empty memory space between fields and must be 1, 2, 4, 8 or 16 bytes.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
//The class is selected for the ExplicitLayout.
[StructLayoutAttribute(LayoutKind.Explicit)]
public class MyDemoAttribute
{
}

public class MyTypeClass
{
   public static void Main(string[] args)
   {
      MyIsExplicitLayoutMethod("MyDemoAttribute");     
   }
   public static void MyIsExplicitLayoutMethod(string typeName)
   {
     try
      {
         // Create an object of 'Type' class using the 'GetType' method.
         Type  myType=Type.GetType(typeName);
         // Get and display the 'IsExplicitLayout' property.
         Console.WriteLine("\n'MyDemoAttribute' instance's 'IsExplicitLayout' property is: {0}.",myType.IsExplicitLayout); 
      }
      catch(Exception e)
      {
         Console.WriteLine("\nThe following exception is raised: {0}." ,e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsAutoLayout">Type.IsAutoLayout</a> |  <a href="#IsLayoutSequential">Type.IsLayoutSequential</a> | <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconmetadataoverview.asp">MSDN: metadataoverview</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsImportTopic1"></a><a name="IsImport">IsImport</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsImport">System.Type.IsImport</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> was imported from another class.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsImport {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsInterfaceTopic1"></a><a name="IsInterface">IsInterface</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsInterface">System.Type.IsInterface</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is an interface; that is, not a class or a value type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsInterface {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#ClassSemanticsMask">TypeAttributes.ClassSemanticsMask</a> distinguishes a type declaration as class, interface or value type.<p> This property is read-only.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
// Interface declaration.
interface myIFace
{

}

class MyIsInterface 
{
   public static void Main(string []args)
   {
      try
      {
         // Get the attribute IsInterface for myIFace.
         bool myBool1 = typeof(myIFace).IsInterface;    
         //Display the IsInterface attribute for myIFace.
         Console.WriteLine("The type mentioned is an interface: {0}",myBool1);
         // Get the attribute IsInterface for MyIsInterface.
         bool myBool2 = typeof(MyIsInterface).IsInterface;    
         //Display the IsInterface attribute for MyIsInterface.
         Console.WriteLine("The type mentioned is an interface: {0}",myBool2);         
      }
      catch(Exception e)
      {
         Console.WriteLine("\nThe following exception is raised : {0}",e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsClass">Type.IsClass</a> |  <a href="#IsValueType">Type.IsValueType</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsLayoutSequentialTopic1"></a><a name="IsLayoutSequential">IsLayoutSequential</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsLayoutSequential">System.Type.IsLayoutSequential</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the class layout attribute <b>SequentialLayout</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsLayoutSequential {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#LayoutMask">TypeAttributes.LayoutMask</a> is used to select the class layout attributes. The class layout attributes (<b>AutoLayout</b><i>,</i><b>SequentialLayout</b> and <b>ExplicitLayout</b>) define how the fields of the class instance are laid out in memory.<p> Classes marked with the <b>SequentialLayout</b> attribute guides the loader to preserve field order as emitted, but otherwise the specific offsets are calculated based on the common language runtime type of the field; these may be shifted by explicit offset, padding, or alignment information.</p>
<p> Use the <b>SequentialLayout</b> attribute to layout the objects of the class sequentially and to specify the packing size between adjacent fields. The packing size is the empty memory space between fields and must be 1, 2, 4, 8 or 16 bytes. A field will be aligned to its natural size or to the packing size, whichever results in a smaller offset.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
// MyTypeSequential1 class declaration.
class MyTypeSequential1
{
}

[StructLayoutAttribute(LayoutKind.Sequential)]
class MyTypeSequential2
{
   public static void Main(string []args)
   {
      try
      {
         // Create an instance of 'myTypeSeq1' class.
         MyTypeSequential1 myObj1 = new MyTypeSequential1();
         Type myTypeObj1 = myObj1.GetType();
         // Check and displays the attribute 'SequentialLayout'.
         Console.WriteLine("\nThe object myObj1 has 'IsLayoutSequential': {0}", myObj1.GetType().IsLayoutSequential);
         // Create an instance of 'myTypeSeq2' class.
         MyTypeSequential2 myObj2 = new MyTypeSequential2();
         Type myTypeObj2 = myObj2.GetType();
         // Check and displays the attribute 'SequentialLayout'.
         Console.WriteLine("\nThe object myObj2 has 'IsLayoutSequential': {0}", myObj2.GetType().IsLayoutSequential);
      }
      catch(Exception e)
      {
         Console.WriteLine("\nThe following exception is raised: {0}",e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsAutoLayout">Type.IsAutoLayout</a> |  <a href="#IsExplicitLayout">Type.IsExplicitLayout</a> | <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconmetadataoverview.asp">MSDN: metadataoverview</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsMarshalByRefTopic1"></a><a name="IsMarshalByRef">IsMarshalByRef</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsMarshalByRef">System.Type.IsMarshalByRef</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the Type is marshaled by reference.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsMarshalByRef {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>

public class MyContextBoundClass: ContextBoundObject
{
   public string myString = "This class demonstrates the isContextful and isMarshalByRef properties.";
}

public class MyTypeDemoClass
{
   public static void Main()
   {
      try
      {
         // Check if the types can be hosted in a Context.
         Console.WriteLine ("The Contextful property for the '{0}' type is: {1}", typeof(MyTypeDemoClass).Name, typeof(MyTypeDemoClass).IsContextful);
         Console.WriteLine ("The Contextful property for the '{0}' type is: {1}", typeof(MyContextBoundClass).Name, typeof(MyContextBoundClass).IsContextful);

         // Check if the types are marshalled by reference.
         Console.WriteLine ("The MarshalByRef property of '{0}' is: {1} ", typeof(MyTypeDemoClass).Name, typeof(MyTypeDemoClass).IsMarshalByRef);
         Console.WriteLine ("The MarshalByRef property of '{0}' is: {1} ", typeof(MyContextBoundClass).Name, typeof(MyContextBoundClass).IsMarshalByRef);
         // Check if the types are primitive datatypes.
         Console.WriteLine ("'{0}' is a primitive datatype : {1} ", typeof(int).Name, typeof(int).IsPrimitive);
         Console.WriteLine ("'{0}' is a primitive datatype : {1} ", typeof(string).Name, typeof(string).IsPrimitive);
      } 
      catch (Exception e)
      {
         Console.WriteLine("The following exception is raised : " + e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#IsMarshalByRefImpl">Type.IsMarshalByRefImpl</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsNestedAssemblyTopic1"></a><a name="IsNestedAssembly">IsNestedAssembly</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsNestedAssembly">System.Type.IsNestedAssembly</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is nested and visible only within its own assembly.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsNestedAssembly {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#VisibilityMask">TypeAttributes.VisibilityMask</a> selects the visibility attributes.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
// Enclose a class.
class MyClassA
{
   // Internal nested class.
   internal class MyClassB
   {
   }
}
class MyTestClass
{
   public static void Main(string[] args)
   {  
      // Get the Type of the nested class.
      Type myTypeB = typeof(MyClassA.MyClassB);
      // Get the 'IsNestedAssembly' property  of the nested class
      // 'Type'.
      Console.WriteLine("\nThe nested class has the property 'IsNestedAssembly' value: "+ 
                         myTypeB.IsNestedAssembly.ToString());
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsNestedFamANDAssemTopic1"></a><a name="IsNestedFamANDAssem">IsNestedFamANDAssem</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsNestedFamANDAssem">System.Type.IsNestedFamANDAssem</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is nested and visible only to classes that belong to both its own family and its own assembly.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsNestedFamANDAssem {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#VisibilityMask">TypeAttributes.VisibilityMask</a> selects the visibility attributes.<p> A  <a href="../../System/types/Type.html">Type</a> object's family is defined as all objects of the exact same  <a href="../../System/types/Type.html">Type</a> and of its subtypes.</p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsNestedFamilyTopic1"></a><a name="IsNestedFamily">IsNestedFamily</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsNestedFamily">System.Type.IsNestedFamily</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is nested and visible only within its own family.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsNestedFamily {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#VisibilityMask">TypeAttributes.VisibilityMask</a> selects the visibility attributes.<p> A  <a href="../../System/types/Type.html">Type</a> object's family is defined as all objects of the exact same  <a href="../../System/types/Type.html">Type</a> and of its subtypes.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
// Enclose a class.
class MyClassA
{
   // Protected nested class.
   protected class MyClassB
   {
   }   
}
class MyTestClass : MyClassA
{
   public static void Main(string[] args)
   {  
      // Get the Type of the nested class.
      Type myTypeB = typeof(MyClassA.MyClassB);
      // Get the 'IsNestedFamily' property the of the nested class
      // 'Type'.
      Console.WriteLine("\nThe nested class has the property 'IsNestedFamily' value: "+
                        myTypeB.IsNestedFamily.ToString());      
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsNestedFamORAssemTopic1"></a><a name="IsNestedFamORAssem">IsNestedFamORAssem</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsNestedFamORAssem">System.Type.IsNestedFamORAssem</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is nested and visible only to classes that belong to either its own family or to its own assembly.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsNestedFamORAssem {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#VisibilityMask">TypeAttributes.VisibilityMask</a> selects the visibility attributes.<p> A  <a href="../../System/types/Type.html">Type</a> object's family is defined as all objects of the exact same  <a href="../../System/types/Type.html">Type</a> and of its subtypes.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
// Enclose a class.
class MyClassA
{
   // Protected internal nested class.
   protected internal class MyClassB
   {
   }
}
class MyTestClass 
{
   public static void Main(string[] args)
   {        
      // Get the Type of the nested class.
      Type myTypeB = typeof(MyClassA.MyClassB);
      // Get the 'IsNestedFamORAssem' property of the nested class 
      // 'Type'.
      Console.WriteLine("\nThe nested class has the property 'IsNestedFamORAssem' value: "+
                        myTypeB.IsNestedFamORAssem.ToString()); 
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsNestedPrivateTopic1"></a><a name="IsNestedPrivate">IsNestedPrivate</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsNestedPrivate">System.Type.IsNestedPrivate</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is nested and declared private.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsNestedPrivate {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#VisibilityMask">TypeAttributes.VisibilityMask</a> selects the visibility attributes.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
// Outer class.
public class MyClassA
{
   // Private nested class.
   private class MyClassB
   {
   }
   public static void Main(string[] args)
   {	
      // Get the Type of the nested class.
      Type myTypeB = typeof(MyClassA.MyClassB);
      // Get the 'IsNestedPrivate' property of the nested class 'Type'.
      Console.WriteLine("\nThe nested class has the property 'IsNestedPrivate'value: "+
                        myTypeB.IsNestedPrivate.ToString());	
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsNestedPublicTopic1"></a><a name="IsNestedPublic">IsNestedPublic</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsNestedPublic">System.Type.IsNestedPublic</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether a class is nested and declared public.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsNestedPublic {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#VisibilityMask">TypeAttributes.VisibilityMask</a> selects the visibility attributes.</dd>
</dl><b>Example</b><dl>
<dd> The following example demonstrates the <b>IsNestedPublic</b> property. A nested class MyClassB is declared as public and the <b>IsNestedPublic</b> property value is displayed.<pre>

using System;

// Enclose a class.
public class MyClassA
{
   // Public nested class.
   public class MyClassB
   {
   }
   public static void Main(string[] args)
   {	
      // Get the Type of the nested class.
      Type myTypeB = typeof(MyClassA.MyClassB);
      // Get the 'IsNestedPublic' property of the nested class
      // 'Type'.
      Console.WriteLine("\nThe nested class has the property 'IsNestedPublic' value: "+
                        myTypeB.IsNestedPublic.ToString());			
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsNotPublicTopic1"></a><a name="IsNotPublic">IsNotPublic</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsNotPublic">System.Type.IsNotPublic</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the top-level  <a href="../../System/types/Type.html">Type</a> is not declared public.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsNotPublic {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd><b>IsPublic</b> and <b>IsNotPublic</b> get the visibility of the top-level type only.<p> <a href="../../System.Reflection/types/TypeAttributes.html#VisibilityMask">TypeAttributes.VisibilityMask</a> selects the visibility attributes.</p>
</dd>
</dl><b>Example</b><dl>
<dd> This example shows the use of <b>IsNotPublic</b> to get the visibility of the top-level type.<pre>
 using System;
 using System.IO;
 using System.Reflection;
 
 class MyMemberInfo { 
 
   public static void Main(string[] args) { 
 
    Console.WriteLine ("\nReflection.MemberInfo");
 
    //Get the Type and MemberInfo 
 
    Type MyType =Type.GetType("System.IO.File");
 
    MemberInfo[] Mymemberinfoarray = MyType.GetMembers();
 
    //Get and display the DeclaringType method
 
    Console.WriteLine("\nThere are {0} members in {1}.",
       Mymemberinfoarray.Length, MyType.FullName);
 
    Console.WriteLine("Is {0} public? {1}", MyType.FullName,
       MyType.IsPublic.ToString());
   }
 }

    </pre>
<p> This code produces the following output: </p>
<p> There are 27 members in System.IO.File.</p>
<p> Is System.IO.File public? False </p>
<p> The following code example demonstrates why you cannot use <b>IsPublic</b> and <b>IsNotPublic</b> for nested classes.</p>
<pre>
public class A {
   public class B { }
   private class C { }
}

    </pre>
<p> For nested classes, ignore the results of <b>IsPublic</b> and <b>IsNotPublic</b> and pay attention only to the results of <b>IsNestedPublic</b> and <b>IsNestedPrivate</b>. The reflection output for this code fragment would be as follows: </p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Class
                </TH>
<TH>
                  IsNotPublic
                </TH>
<TH>
                  IsPublic
                </TH>
<TH>
                  IsNestedPublic
                </TH>
<TH>
                  IsNestedPrivate
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  A
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  TRUE
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  FALSE
                </TD>
</TR>
<TR valign="top">
<TD>
                  B
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  TRUE
                </TD>
<TD>
                  FALSE
                </TD>
</TR>
<TR valign="top">
<TD>
                  C
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  TRUE
                </TD>
</TR>
</table>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsPointerTopic1"></a><a name="IsPointer">IsPointer</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsPointer">System.Type.IsPointer</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is a pointer.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsPointer {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This property is read-only.</dd>
</dl><b>See also: 
			</b><br> <a href="#IsPointerImpl">Type.IsPointerImpl</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsPrimitiveTopic1"></a><a name="IsPrimitive">IsPrimitive</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsPrimitive">System.Type.IsPrimitive</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is one of the primitive types.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsPrimitive {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The primitive types are  <a href="../../System/types/Boolean.html">Boolean</a>,  <a href="../../System/types/Byte.html">Byte</a>,  <a href="../../System/types/SByte.html">SByte</a>,  <a href="../../System/types/Int16.html">Int16</a>,  <a href="../../System/types/UInt16.html">UInt16</a>,  <a href="../../System/types/Int32.html">Int32</a>,  <a href="../../System/types/UInt32.html">UInt32</a>,  <a href="../../System/types/Int64.html">Int64</a>,  <a href="../../System/types/UInt64.html">UInt64</a>,  <a href="../../System/types/Char.html">Char</a>,  <a href="../../System/types/Double.html">Double</a>, and  <a href="../../System/types/Single.html">Single</a>.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
         // Check if the types are primitive datatypes.
         Console.WriteLine ("'{0}' is a primitive datatype : {1} ", typeof(int).Name, typeof(int).IsPrimitive);
         Console.WriteLine ("'{0}' is a primitive datatype : {1} ", typeof(string).Name, typeof(string).IsPrimitive);

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/Boolean.html">Boolean</a> |  <a href="../../System/types/Byte.html">Byte</a> |  <a href="../../System/types/SByte.html">SByte</a> |  <a href="../../System/types/Int16.html">Int16</a> |  <a href="../../System/types/UInt16.html">UInt16</a> |  <a href="../../System/types/Int32.html">Int32</a> |  <a href="../../System/types/UInt32.html">UInt32</a> |  <a href="../../System/types/Int64.html">Int64</a> |  <a href="../../System/types/UInt64.html">UInt64</a> |  <a href="../../System/types/Char.html">Char</a> |  <a href="../../System/types/Double.html">Double</a> |  <a href="../../System/types/Single.html">Single</a> |  <a href="#IsPrimitiveImpl">Type.IsPrimitiveImpl</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsPublicTopic1"></a><a name="IsPublic">IsPublic</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsPublic">System.Type.IsPublic</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the top-level  <a href="../../System/types/Type.html">Type</a> is declared public.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsPublic {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd><b>IsPublic</b> and <b>IsNotPublic</b> get the visibility of the top-level type only.<p> <a href="../../System.Reflection/types/TypeAttributes.html#VisibilityMask">TypeAttributes.VisibilityMask</a> selects the visibility attributes.</p>
</dd>
</dl><b>Example</b><dl>
<dd> This example shows the use of <b>IsPublic</b> to get the visibility of the top-level type.<pre>
 using System;
 using System.IO;
 using System.Reflection;
 
 class MyMemberInfo { 
 
   public static void Main(string[] args) { 
 
    Console.WriteLine ("\nReflection.MemberInfo");
 
    //Get the Type and MemberInfo 
 
    Type MyType =Type.GetType("System.IO.File");
 
    MemberInfo[] Mymemberinfoarray = MyType.GetMembers();
 
    //Get and display the DeclaringType method
 
    Console.WriteLine("\nThere are {0} members in {1}.",
       Mymemberinfoarray.Length, MyType.FullName);
 
    Console.WriteLine("Is {0} public? {1}", MyType.FullName,
       MyType.IsPublic.ToString());
   }
 }

    </pre>
<p> This code produces the following output: </p>
<p> There are 27 members in System.IO.File.</p>
<p> Is System.IO.File public? True </p>
<p> The following code example demonstrates why you cannot use <b>IsPublic</b> and <b>IsNotPublic</b> for nested classes.</p>
<pre>
public class A {
   public class B { }
   private class C { }
}

    </pre>
<p> For nested classes, ignore the results of <b>IsPublic</b> and <b>IsNotPublic</b> and pay attention only to the results of <b>IsNestedPublic</b> and <b>IsNestedPrivate</b>. The reflection output for this code fragment would be as follows: </p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Class
                </TH>
<TH>
                  IsNotPublic
                </TH>
<TH>
                  IsPublic
                </TH>
<TH>
                  IsNestedPublic
                </TH>
<TH>
                  IsNestedPrivate
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  A
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  TRUE
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  FALSE
                </TD>
</TR>
<TR valign="top">
<TD>
                  B
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  TRUE
                </TD>
<TD>
                  FALSE
                </TD>
</TR>
<TR valign="top">
<TD>
                  C
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  FALSE
                </TD>
<TD>
                  TRUE
                </TD>
</TR>
</table>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsSealedTopic1"></a><a name="IsSealed">IsSealed</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsSealed">System.Type.IsSealed</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is declared sealed.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsSealed {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
      // Declare class 'MyTestClass' as sealed.
      sealed public class MyTestClass
      {
      }
      public static void Main(string []args)
      {
         try
         {
            bool myBool = false;
            MyTestClass myTestClassInstance = new MyTestClass();
            // Get Type of 'myTestClassInstance'.
            Type   myType = myTestClassInstance.GetType();
            // Get the 'IsSealed' property of the 'MyTestClass' instance.
            myBool = myType.IsSealed;
            Console.WriteLine("\n{0} class is Sealed: {1}.",myType.FullName,myBool.ToString ());
         }
         catch (Exception e)
         {
            Console.WriteLine("\nThe following exception is raised: {0}",e.Message);
         }
      }

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsSerializableTopic1"></a><a name="IsSerializable">IsSerializable</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsSerializable">System.Type.IsSerializable</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is serializable.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsSerializable {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
      // Declare a class as public with [Serializable] attribute.
      [Serializable] public class MyTestClass 
      {
      }
      public static void Main(string []args)
      {
         try
         {
            bool myBool = false;
            MyTestClass myTestClassInstance = new MyTestClass();
            // Get Type of 'myTestClassInstance'.
            Type myType = myTestClassInstance.GetType();
            // Get the 'IsSerializable' property of the 'MyTestClass' instance.
            myBool = myType.IsSerializable;
            Console.WriteLine("\n{0} class is Serializable: {1}.",myType.FullName,myBool.ToString ());
         }
         catch (Exception e)
         {
            Console.WriteLine("\nThe following exception is raised: {0}",e.Message);
         }
      }

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="../../System.Runtime.Serialization/types/ISerializable.html">ISerializable</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsSpecialNameTopic1"></a><a name="IsSpecialName">IsSpecialName</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsSpecialName">System.Type.IsSpecialName</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> has a name that requires special handling.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsSpecialName {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of types that might require special treatment by some compilers.</dd>
</dl><b>Example</b><dl>
<dd> This example shows a use of <b>IsSpecialName</b> to filter internal or private members out of a list.<pre>
private void DumpMethods(Type aType)
 {
 if (!ShowMethods)
 return;
 MethodInfo[] mInfo = aType.GetMethods();
 myWriter.WriteLine("Methods"); 
 bool found = false;            
 
   if (mInfo.Length != 0)
   {
    for ( int i=0; i &lt; mInfo.Length; i++ )
    {
    // Only display methods declared in this type. Also 
    // filter out any methods with special names, because these
    // cannot be generally called by the user. That is, their 
    // functionality is usually exposed in other ways, for example,
    // property get/set methods are exposed as properties.
             
     if (mInfo[i].DeclaringType == aType &amp;&amp; !mInfo[i].IsSpecialName)
     {        
      found = true;
      StringBuilder modifiers = new StringBuilder();
      if (mInfo[i].IsStatic)   {modifiers.Append("static ");}     
      if (mInfo[i].IsPublic)   {modifiers.Append("public ");}     
      if (mInfo[i].IsFamily)   {modifiers.Append("protected ");}     
      if (mInfo[i].IsAssembly) {modifiers.Append("internal ");}     
      if (mInfo[i].IsPrivate)  {modifiers.Append("private ");}     
    myWriter.WriteLine("{0} {1}", modifiers, mInfo[i]);
      }
    }                      
  }                    
      if (!found)
      {
       myWriter.WriteLine("(none)");
      }
 }

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsUnicodeClassTopic1"></a><a name="IsUnicodeClass">IsUnicodeClass</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsUnicodeClass">System.Type.IsUnicodeClass</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the string format attribute <b>UnicodeClass</b> is selected for the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsUnicodeClass {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The  <a href="../../System.Reflection/types/TypeAttributes.html#StringFormatMask">TypeAttributes.StringFormatMask</a> is used to select the string format attributes. The string format attributes enhance interoperability by defining how strings should be interpreted.</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsAnsiClass">Type.IsAnsiClass</a> |  <a href="#IsAutoClass">Type.IsAutoClass</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="IsValueTypeTopic1"></a><a name="IsValueType">IsValueType</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsValueType">System.Type.IsValueType</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a value indicating whether the  <a href="../../System/types/Type.html">Type</a> is a value type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> IsValueType {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Value types are those that are represented as sequences of bits; value types are not classes or interfaces. These are referred to as "structs" in some programming languages. Enums are a special case of value types.<p> This property returns true for enumerations, but not for the  <a href="../../System/types/Enum.html">Enum</a> type itself, which is a class. For an example that demonstrates this behavior, see  <a href="#IsEnum">Type.IsEnum</a>.</p>
<p> This property is read-only.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
      // Declare enum type.
      enum MyEnum
      {
         One,
         Two
      }
      public static void Main(string []args)
      {
         try
         {
            bool myBool = false;
            MyEnum myTestEnum = MyEnum.One;
            // Get Type of 'myTestEnum'.
            Type   myType = myTestEnum.GetType();
            // Get the 'IsValueType' property of the 'MyTestEnum' 
            // of variable.
            myBool = myType.IsValueType;
            Console.WriteLine("\n {0} is value type: {1}.",myType.FullName,myBool.ToString());
         }
         catch (Exception e)
         {
            Console.WriteLine("\nThe following exception is raised: {0}",e.Message);
         }
      }

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsClass">Type.IsClass</a> |  <a href="#IsInterface">Type.IsInterface</a> |  <a href="../../System/types/ValueType.html">ValueType</a> |  <a href="#IsValueTypeImpl">Type.IsValueTypeImpl</a> |  <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> |  <a href="#IsClass">Type.IsClass</a> |  <a href="#IsInterface">Type.IsInterface</a> |  <a href="../../System/types/ValueType.html">ValueType</a> |  <a href="#IsValueTypeImpl">Type.IsValueTypeImpl</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="MemberTypeTopic1"></a><a name="MemberType">MemberType</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#MemberType">System.Type.MemberType</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets a bitmask indicating the member type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Reflection/types/MemberTypes.html">MemberTypes</a> MemberType {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd> The following code example shows the <b>MemberType</b> field as a parameter to the <b>GetMember</b> method: <pre>
MemberInfo[] others = t.GetMember(mi.Name, mi.MemberType, BindingFlags.Public |
BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Instance);

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MemberTypes.html">MemberTypes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="ModuleTopic1"></a><a name="Module">Module</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Retrieves the dynamic module that contains this  <a href="../../System.Reflection.Emit/types/EnumBuilder.html">EnumBuilder</a> definition.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Reflection/types/Module.html">Module</a> Module {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="NameTopic1"></a><a name="Name">Name</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns the name of this enum.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/String.html">string</a> Name {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="NamespaceTopic1"></a><a name="Namespace">Namespace</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns the namespace of this enum.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/String.html">string</a> Namespace {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="ReflectedTypeTopic1"></a><a name="ReflectedType">ReflectedType</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns the type that was used to obtain this  <a href="../../System.Reflection.Emit/types/EnumBuilder.html">EnumBuilder</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Type.html">Type</a> ReflectedType {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="TypeHandleTopic1"></a><a name="TypeHandle">TypeHandle</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Retrieves the internal handle for this enum.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/RuntimeTypeHandle.html">RuntimeTypeHandle</a> TypeHandle {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This property is not currently supported.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> You can retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.<p> Use this handle to access the underlying metadata handle.</p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="TypeInitializerTopic1"></a><a name="TypeInitializer">TypeInitializer</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#TypeInitializer">System.Type.TypeInitializer</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the initializer for the  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> TypeInitializer {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Class initializers are available through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>, and  <a href="#GetConstructors">Type.GetConstructors</a>.</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="TypeTokenTopic1"></a><a name="TypeToken">TypeToken</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns the internal metadata type token of this enum.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection.Emit/types/TypeToken.html">TypeToken</a> TypeToken {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Property: <i><a name="UnderlyingFieldTopic1"></a><a name="UnderlyingField">UnderlyingField</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns the underlying field for this enum.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection.Emit/types/FieldBuilder.html">FieldBuilder</a> UnderlyingField {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Property: <i><a name="UnderlyingSystemTypeTopic1"></a><a name="UnderlyingSystemType">UnderlyingSystemType</a></i></b><b><i></i></b><b><font color="#008080"> (read-only)</font></b><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns the underlying system type for this enum.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Type.html">Type</a> UnderlyingSystemType {get;}
          </b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#UnderlyingSystemType">IReflect.UnderlyingSystemType</a></dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="CreateTypeTopic1"></a><a name="CreateType">CreateType</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Creates a  <a href="../../System/types/Type.html">Type</a> object for this enum.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Type.html">Type</a> CreateType();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System/types/Type.html">Type</a> object for this enum.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/InvalidOperationException.html">InvalidOperationException</a></td>
<td> This type has been previously created.<p> -or- </p>
<p> The enclosing type has not been created.</p>
</td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="DefineLiteralTopic1"></a><a name="DefineLiteral(System.String,System.Object)">DefineLiteral</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>literalName</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>literalValue</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Defines the named static field in an enumeration type with the specified constant value.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection.Emit/types/FieldBuilder.html">FieldBuilder</a> DefineLiteral(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>literalName</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>literalValue</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>literalName</i><br><dl>
<dd>
<param> The name of the static field.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>literalValue</i><br><dl>
<dd>
<param> The constant value of the literal.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The defined field.</dd>
</dl><b>Remarks</b><dl>
<dd> The defined field will have the field attributes  <a href="../../System.Reflection/types/FieldAttributes.html#Public">FieldAttributes.Public</a>,  <a href="../../System.Reflection/types/FieldAttributes.html#Static">FieldAttributes.Static</a>, and  <a href="../../System.Reflection/types/FieldAttributes.html#Literal">FieldAttributes.Literal</a> set.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="EqualsTopic1"></a><a name="Equals(System.Object)">Equals</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>o</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#Equals(System.Object)">System.Type.Equals</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Determines if the underlying system type of the current  <a href="../../System/types/Type.html">Type</a> is the same as the underlying system type of the specified  <a href="../../System/types/Object.html">Object</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Boolean.html">bool</a> Equals(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>o</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>o</i><br><dl>
<dd>
<param> The  <a href="../../System/types/Object.html">Object</a> whose underlying system type is to be compared with the underlying system type of the current  <a href="../../System/types/Type.html">Type</a>.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the underlying system type of <i>o</i> is the same as the underlying system type of the current  <a href="../../System/types/Type.html">Type</a>; otherwise, <b>false</b>. This method also returns <b>false</b> if the object specified by the <i>o</i> parameter is not a <b>Type</b>.</dd>
</dl><b>Remarks</b><dl>
<dd> This method overrides  <a href="../../System/types/Object.html#Equals(System.Object)">Object.Equals</a>.</dd>
</dl><b>Example</b><dl>
<dd> The following example uses <b>Equals</b> to compare two <b>Object</b> instances.<pre>
using System;
 using System.Reflection;
 
 class EqType
 {
   public static void Main(String[] args)
   {
    Type a = typeof(EqType);
    Type b = typeof(Type);
    Console.WriteLine("{0}", a.Equals(b).ToString());
    b = (new EqType()).GetType();
    Console.WriteLine("{0}", a.Equals(b).ToString());
   }
 }
 
 //This code produces the following output:
 //False
 //True

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#UnderlyingSystemType">Type.UnderlyingSystemType</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="EqualsTopic2"></a><a name="Equals(System.Type)">Equals</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>o</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#Equals(System.Type)">System.Type.Equals</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Determines if the underlying system type of the current  <a href="../../System/types/Type.html">Type</a> is the same as the underlying system type of the specified  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Boolean.html">bool</a> Equals(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>o</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>o</i><br><dl>
<dd>
<param> The  <a href="../../System/types/Type.html">Type</a> whose underlying system type is to be compared with the underlying system type of the current  <a href="../../System/types/Type.html">Type</a>.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the underlying system type of <i>o</i> is the same as the underlying system type of the current  <a href="../../System/types/Type.html">Type</a>; otherwise, <b>false</b>.</dd>
</dl><b>Example</b><dl>
<dd> The following example uses <b>Equals</b> to compare two types.<pre>
 using System;
 using System.Reflection;
 
 class EqType
 {
   public static void Main(String[] args)
   {
    int a = 1;
    float b = 1;
    Console.WriteLine("{0}", a.Equals(b).ToString());
    b=a;
    Console.WriteLine("{0}", a.Equals(b).ToString());
   }
 }
 
 //This code produces the following output:
 //False
 //False

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#UnderlyingSystemType">Type.UnderlyingSystemType</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="FinalizeTopic1"></a><a name="Finalize">Finalize</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#Finalize">System.Object.Finalize</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            ~EnumBuilder();</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="FindInterfacesTopic1"></a><a name="FindInterfaces(System.Reflection.TypeFilter,System.Object)">FindInterfaces</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/TypeFilter.html">TypeFilter</a> <i>filter</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>filterCriteria</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#FindInterfaces(System.Reflection.TypeFilter,System.Object)">System.Type.FindInterfaces</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns an array of  <a href="../../System/types/Type.html">Type</a> objects representing a filtered list of interfaces implemented or inherited by the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/Type.html">Type[]</a> FindInterfaces(<br>   <font color="#008080"><a href="../../System.Reflection/types/TypeFilter.html">TypeFilter</a> <i>filter</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>filterCriteria</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>filter</i><br><dl>
<dd>
<param> The  <a href="../../System.Reflection/types/TypeFilter.html">TypeFilter</a> delegate that compares the interfaces against <i>filterCriteria</i>. The  <a href="../../System.Reflection/types/TypeFilter.html">TypeFilter</a> delegate that compares the interfaces against <i>filterCriteria</i>.</dd>
</dl>
</p>
</dd>
<dd>
<p><i>filterCriteria</i><br><dl>
<dd>
<param> The search criteria that determines whether an interface should be included in the returned array.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System/types/Type.html">Type</a> objects representing a filtered list of the interfaces implemented or inherited by the current  <a href="../../System/types/Type.html">Type</a>.<p> -or- </p>
<p> An empty array of type  <a href="../../System/types/Type.html">Type</a>, if no interfaces matching the filter are implemented or inherited by the current  <a href="../../System/types/Type.html">Type</a>.</p>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>filter</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/TargetInvocationException.html">TargetInvocationException</a></td>
<td> A static initializer is invoked and throws an exception.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This method can be overridden by a derived class.<p> The  <a href="../../System.Reflection/types/Module.html#FilterTypeName">Module.FilterTypeName</a> and  <a href="../../System.Reflection/types/Module.html#FilterTypeNameIgnoreCase">Module.FilterTypeNameIgnoreCase</a> delegates supplied by the  <a href="../../System.Reflection/types/Module.html">Module</a> class may also be used, in lieu of the  <a href="../../System.Reflection/types/TypeFilter.html">TypeFilter</a> delegate.</p>
<p> All of the interfaces implemented by this class are considered during the search, whether declared by a base class or this class itself.</p>
<p> This method searches the base class hierarchy, returning each of the matching interfaces each class implements as well as all the matching interfaces each of those interfaces implements (that is, the transitive closure of the matching interfaces is returned). No duplicate interfaces are returned.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
using System;
using System.Xml;
using System.Reflection;

public class MyFindInterfacesSample 
{
   public static void Main()
   {
      try
      {
         XmlDocument myXMLDoc = new XmlDocument();
         myXMLDoc.LoadXml("&lt;book genre='novel' ISBN='1-861001-57-5'&gt;" +
            "&lt;title&gt;Pride And Prejudice&lt;/title&gt;" + "&lt;/book&gt;");
         Type myType = myXMLDoc.GetType();

         // Specify the TypeFilter delegate that compares the interfaces against filter criteria.
         TypeFilter myFilter = new TypeFilter(MyInterfaceFilter);
         String[] myInterfaceList = new String[2] {"System.Collections.IEnumerable",
             "System.Collections.ICollection"};

         for(int index=0; index &lt; myInterfaceList.Length; index++)
         {
            Type[] myInterfaces = myType.FindInterfaces(myFilter, myInterfaceList[index]);
				
            if (myInterfaces.Length &gt; 0) 
            {
               Console.WriteLine("\nThe {0} implements the interface {1}", myType, myInterfaceList[index]);	
               for(int j =0;j &lt; myInterfaces.Length;j++)
                  Console.WriteLine("Interfaces supported #{0} : {1}",j,myInterfaces[j].ToString());
            }
            else
               Console.WriteLine("\nThe {0} does not implement the interface {1}",myType,myInterfaceList[index]);	
         }
      }
      catch(ArgumentNullException e)
      {
         Console.WriteLine("ArgumentNullException : " + e.Message);
      }
      catch(TargetInvocationException e)
      {
         Console.WriteLine("TargetInvocationException : " + e.Message);
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception : " + e.Message);
      }
   }
      
	public static bool MyInterfaceFilter(Type typeObj,Object criteriaObj)
	{
		if(typeObj.ToString() == criteriaObj.ToString())
		   return true;
		else
		   return false;
	}
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/Module.html">Module</a> |  <a href="../../System.Reflection/types/TypeFilter.html">TypeFilter</a> |  <a href="#GetInterface(System.String)">Type.GetInterface</a> |  <a href="#GetInterfaces">Type.GetInterfaces</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="FindMembersTopic1"></a><a name="FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">FindMembers</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/MemberTypes.html">MemberTypes</a> <i>memberType</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/MemberFilter.html">MemberFilter</a> <i>filter</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>filterCriteria</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">System.Type.FindMembers</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns a filtered array of  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> objects of the specified member type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo[]</a> FindMembers(<br>   <font color="#008080"><a href="../../System.Reflection/types/MemberTypes.html">MemberTypes</a> <i>memberType</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/MemberFilter.html">MemberFilter</a> <i>filter</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>filterCriteria</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>memberType</i><br><dl>
<dd>
<param> A <b>MemberTypes</b> object indicating the type of member to search for.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>filter</i><br><dl>
<dd>
<param> The delegate that does the comparisons, returning <b>true</b> if the member currently being inspected matches the <i>filterCriteria</i> and <b>false</b> otherwise. You can use the <b>FilterAttribute</b>, <b>FilterName</b>, and <b>FilterNameIgnoreCase</b> delegates supplied by this class. The first uses the fields of <b>FieldAttributes</b>, <b>MethodAttributes</b>, and <b>MethodImplAttributes</b> as search criteria, and the other two delegates use <b>String</b> objects as the search criteria.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>filterCriteria</i><br><dl>
<dd>
<param> The search criteria that determines whether a member is returned in the array of <b>MemberInfo</b> objects.<p> The fields of <b>FieldAttributes</b>, <b>MethodAttributes</b>, and <b>MethodImplAttributes</b> can be used in conjunction with the <b>FilterAttribute</b> delegate supplied by this class.</p> The search criteria that determines whether a member is returned in the array of <b>MemberInfo</b> objects.<p> The fields of <b>FieldAttributes</b>, <b>MethodAttributes</b>, and <b>MethodImplAttributes</b> can be used in conjunction with the <b>FilterAttribute</b> delegate supplied by this class.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A filtered array of  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> objects of the specified member type.<p> -or- </p>
<p> An empty array of type  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a>, if the current  <a href="../../System/types/Type.html">Type</a> does not have members of type <i>memberType</i> that match the filter criteria.</p>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>filter</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This method can be overridden by a derived class.<p> Members include properties, methods, fields, events, and so on. If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which members to include in the search: </p>
<UL>
<li><i>Instance</i> to include instance members in the search.</li>
<li><i>Static</i> to include static members in the search.</li>
<li><i>Public</i> to include public members in the search.</li>
<li><i>NonPublic</i> to include non-public members (that is, private and protected members) in the search.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><i>DeclaredOnly</i> to search only the members declared on the  <a href="../../System/types/Type.html">Type</a>, not members that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> Valid values for MemberType are defined in MemberInfo. If no such members are found, an empty array is returned.</p>
<p> Class initializers are available through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>, and  <a href="#GetConstructors">Type.GetConstructors</a>.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre></pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMember(System.String)">Type.GetMember</a> |  <a href="#GetMembers">Type.GetMembers</a> |  <a href="#GetDefaultMembers">Type.GetDefaultMembers</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetArrayRankTopic1"></a><a name="GetArrayRank">GetArrayRank</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetArrayRank">System.Type.GetArrayRank</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Gets the number of dimensions in an  <a href="../../System/types/Array.html">Array</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/Int32.html">int</a> GetArrayRank();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An  <a href="../../System/types/Int32.html">Int32</a> containing the number of dimensions in the current <b>Type</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> The functionality of this method is unsupported in the base class and must be implemented in a derived class instead.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td> The current <b>Type</b> is not an array.</td>
</tr>
</table>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
using System;

class MyArrayRankSample
{
   public static void Main()
   {
      try
      {
         int[,,] myArray = new int[,,] {{{12,2,35},{300,78,33}},{{92,42,135},{30,7,3}}};
         Type myType = myArray.GetType();

         Console.WriteLine("Contents of myArray: {{{12,2,35},{300,78,33}},{{92,42,135},{30,7,3}}}");
         Console.WriteLine("The rank for myArray is: {0}", myType.GetArrayRank());
      }
      catch(NotSupportedException e)
      {
         Console.WriteLine("NotSupportedException raised.");
         Console.WriteLine("Source: " + e.Source);
         Console.WriteLine("Message: " + e.Message);
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception raised.");
         Console.WriteLine("Source: " + e.Source);
         Console.WriteLine("Message: " + e.Message);
      }      
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/Array.html">Array</a> |  <a href="../../System/types/Array.html#Rank">Array.Rank</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="GetAttributeFlagsImplTopic1"></a><a name="GetAttributeFlagsImpl">GetAttributeFlagsImpl</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Gets the implementation attribute flags.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected override <a href="../../System.Reflection/types/TypeAttributes.html">TypeAttributes</a> GetAttributeFlagsImpl();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The implementation attribute flags.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetConstructorTopic1"></a><a name="GetConstructor(System.Type[])">GetConstructor</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetConstructor(System.Type[])">System.Type.GetConstructor</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for a public instance constructor whose parameters match the types in the specified array.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> GetConstructor(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the constructor to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> to get a constructor that takes no parameters.</p>
<p> -or- </p>
<p> <a href="#EmptyTypes">Type.EmptyTypes</a>.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the constructor to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> to get a constructor that takes no parameters.</p>
<p> -or- </p>
<p> <a href="#EmptyTypes">Type.EmptyTypes</a>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> object representing the public instance constructor whose parameters match the types in the parameter type array, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>types</i> is <b>null</b>.<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> <a href="#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetConstructor</a> looks for public instance constructors and cannot be used to obtain a class initializer. Class initializers are available through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>,  <a href="#GetConstructors">Type.GetConstructors</a>, and  <a href="#TypeInitializer">Type.TypeInitializer</a>.<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p><br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>

using System;
using System.Reflection;
using System.Security;

public class MyClass1
{
   public MyClass1(){}
   public MyClass1(int i){}

   public static void Main()
   {
      try
      {
         Type myType = typeof(MyClass1);
         Type[] types = new Type[1];
         types[0] = typeof(int);
         // Get the constructor that takes an integer as a parameter.
         ConstructorInfo constructorInfoObj = myType.GetConstructor(types);
         if (constructorInfoObj != null)
         {
            Console.WriteLine("The constructor of the class MyClass1 that takes an " + 
               "integer as a parameter is: "); 
            Console.WriteLine(constructorInfoObj.ToString());
         }
         else
         {
            Console.WriteLine("The constructor of the class MyClass1 that takes an integer " +
               "as a parameter is not available."); 
         }
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception caught.");
         Console.WriteLine("Source: " + e.Source);
         Console.WriteLine("Message: " + e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetConstructorImpl</a> |  <a href="#GetConstructors">Type.GetConstructors</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetConstructorTopic2"></a><a name="GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">GetConstructor</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">System.Type.GetConstructor</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> GetConstructor(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the constructor to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</p>
<p> -or- </p>
<p> <a href="#EmptyTypes">Type.EmptyTypes</a>.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the constructor to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</p>
<p> -or- </p>
<p> <a href="#EmptyTypes">Type.EmptyTypes</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the parameter type array. The default binder does not process this parameter.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> object representing the constructor that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>types</i> is <b>null</b>.<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.<p> -or- </p>
<p><i>modifiers</i> is multidimensional.</p>
<p> -or- </p>
<p><i>types</i> and <i>modifiers</i> do not have the same length.</p>
</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The <i>types</i> array and the <i>modifiers</i> array have the same length. A parameter specified in the <i>types</i> array can have the following attributes, which are specified in the <i>modifiers</i> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.<p> If an exact match does not exist, the <i>binder</i> will attempt to coerce the parameter types specified in the <i>types</i> array in order to select a match. If the <i>binder</i> is unable to select a match, then <b>null</b> is returned.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which constructors to include in the search: </p>
<UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public constructors in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public constructors (that is, private and protected constructors) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static members up the hierarchy.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p> <a href="#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetConstructor</a> cannot be used to obtain a class initializer. Class initializers are available through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>,  <a href="#GetConstructors">Type.GetConstructors</a>, and  <a href="#TypeInitializer">Type.TypeInitializer</a>.<br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
using System;
using System.Reflection;
using System.Security;


public class MyClass1
{
   public MyClass1(int i){}

   public static void Main()
   {
      try
      {
         Type myType = typeof(MyClass1);
         Type[] types = new Type[1];
         types[0] = typeof(int);
         // Get the constructor that is public and takes an integer parameter.
         ConstructorInfo constructorInfoObj = myType.GetConstructor(
            BindingFlags.Instance | BindingFlags.Public, null, types, null);
         if (constructorInfoObj != null )
         {
            Console.WriteLine("The constructor of the MyClass1 class that is public " +
               "and takes an integer as a parameter is:");
            Console.WriteLine(constructorInfoObj.ToString());
         }
         else
         {
            Console.WriteLine("The constructor of the MyClass1 class that is public " +
               "and takes an integer as a parameter is not available.");
         }
      }
      catch(ArgumentNullException e)
      {
         Console.WriteLine("ArgumentNullException: " + e.Message);
      }
      catch(ArgumentException e)
      {
         Console.WriteLine("ArgumentException: " + e.Message);
      }
      catch(SecurityException e)
      {
         Console.WriteLine("SecurityException: " + e.Message);
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception: " + e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="../../System.Reflection/types/Binder.html">Binder</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetConstructorImpl</a> |  <a href="#GetConstructors">Type.GetConstructors</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetConstructorTopic3"></a><a name="GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">GetConstructor</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">System.Type.GetConstructor</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> GetConstructor(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>callConvention</i><br><dl>
<dd>
<param> The  <a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the constructor to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the constructor to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <i>types</i> array. The default binder does not process this parameter.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> object representing the constructor that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>types</i> is <b>null</b>.<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.<p> -or- </p>
<p><i>modifiers</i> is multidimensional.</p>
<p> -or- </p>
<p><i>types</i> and <i>modifiers</i> do not have the same length.</p>
</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Although the default binder does not process  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> (the <i>modifiers</i> parameter), you can use the abstract  <a href="../../System.Reflection/types/Binder.html">Binder</a> class to write a custom binder that does process <i>modifiers</i>.<b>ParameterModifier</b> is only used when calling through COM interop, and only parameters that are passed by reference are handled.<p> The <i>types</i> array and the <i>modifiers</i> array have the same length. A parameter specified in the <i>types</i> array can have the following attributes, which are specified in the <i>modifiers</i> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.</p>
<p> If an exact match does not exist, the <i>binder</i> will attempt to coerce the parameter types specified in the <i>types</i> array in order to select a match. If the <i>binder</i> is unable to select a match, then <b>null</b> is returned.</p>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which constructors to include in the search: </p>
<UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public constructors in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public constructors (that is, private and protected constructors) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static members up the hierarchy.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> <a href="#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetConstructor</a> cannot be used to obtain a class initializer. Class initializers are available through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>,  <a href="#GetConstructors">Type.GetConstructors</a>, and  <a href="#TypeInitializer">Type.TypeInitializer</a>.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
<p> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL><br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
using System;
using System.Reflection;
using System.Security;


public class MyClass1
{
   public MyClass1(int i){}

   public static void Main()
   {
      try
      {
         Type  myType = typeof(MyClass1);
         Type[] types = new Type[1];
         types[0] = typeof(int);
         // Get the constructor that is public, instance method and takes an integer parameter.
         ConstructorInfo constructorInfoObj = myType.GetConstructor(
            BindingFlags.Instance | BindingFlags.Public, null,
            CallingConventions.HasThis, types, null);
         if(constructorInfoObj != null)
         {
            Console.WriteLine("The constructor of the class MyClass1 that is a public " +
               "instance method and takes an integer as a parameter is: ");
            Console.WriteLine(constructorInfoObj.ToString());
         }
         else
         {
            Console.WriteLine("The Constructor of the class 'MyClass1' that is a public instance " +
               "method and takes an integer as a parameter is not available.");
         }
      }
      catch(ArgumentNullException e)
      {
         Console.WriteLine("ArgumentNullException: " + e.Message);
      }
      catch(ArgumentException e)
      {
         Console.WriteLine("ArgumentException: " + e.Message);
      }
      catch(SecurityException e)
      {
         Console.WriteLine("SecurityException: " + e.Message);
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception: " + e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="../../System.Reflection/types/Binder.html">Binder</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetConstructorImpl</a> |  <a href="#GetConstructors">Type.GetConstructors</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="GetConstructorImplTopic1"></a><a name="GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">GetConstructorImpl</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected override <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> GetConstructorImpl(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to conduct a case-sensitive search for public methods.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to conduct a case-sensitive search for public methods.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="../../System/types/Type.html#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="../../System/types/Type.html#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>callConvention</i><br><dl>
<dd>
<param> The  <a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the constructor to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the constructor to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <i>types</i> array.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> object representing the constructor that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not currently supported in types that are not complete.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> As a workaround to retrieve the constructor of a finished type, you can retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetConstructorsTopic1"></a><a name="GetConstructors">GetConstructors</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetConstructors">System.Type.GetConstructors</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns all the public constructors defined for the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo[]</a> GetConstructors();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> objects representing all the public constructors defined for the current  <a href="../../System/types/Type.html">Type</a>, including the type initializer if it is defined.<p> -or- </p>
<p> An empty array of type  <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a>, if no public constructors are defined for the current  <a href="../../System/types/Type.html">Type</a>.</p>
</dd>
</dl><b>Remarks</b><dl>
<dd> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.<br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
<p> This method calls <a href="../../System/types/Type.html#getconstructorstopic2">GetConstructors</a>. It will not find static constructors unless you explicitly pass <b>BindingFlags.Static</b>, as shown in the examples.</p>
<p> Class initializers are available through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>, and  <a href="#GetConstructors">Type.GetConstructors</a>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> This example shows the output of <b>GetConstructors()</b> from a class that has two instance constructors and one static constructor.<pre>
 using System;
 using System.Reflection;
 
 public class t {
     public t() {}
     static t() {}
     public t(int i) {}
 
     public static void Main() {
         ConstructorInfo[] p = typeof(t).GetConstructors();
         Console.WriteLine(p.Length);
 
         for (int i=0;i&lt;p.Length;i++) {
             Console.WriteLine(p[i].IsStatic);
         }
     }
 }

    </pre>
<p> The output of this code is: </p>
<p> 2 </p>
<p> False </p>
<p> False </p>
<p> Because <b>GetConstructors</b> () only calls the Public and Instance <b>BindingFlags</b>, the static constructor is neither counted by the <b>for</b> expression nor evaluated by <b>IsStatic</b>.</p>
<p> Use <b>GetConstructors</b> (BindingFlags) and pass it <b>BindingFlags.Public</b> | <b>BindingFlags.Static</b> | <b>BindingFlags.NonPublic</b> | <b>BindingFlags.Instance</b> to find static constructors, as follows: </p>
<pre>
 using System;
 using System.Reflection;
  
 public class t {
     public t() {}
     static t() {}
     public t(int i) {}
 
     public static void Main() {
         ConstructorInfo[] p = typeof(t).GetConstructors(
            BindingFlags.Public | BindingFlags.Static |
            BindingFlags.NonPublic | BindingFlags.Instance);
         Console.WriteLine(p.Length);
 
         for (int i=0;i&lt;p.Length;i++) {
             Console.WriteLine(p[i].IsStatic);
         }
     }
 }

    </pre>
<p> Now the output is: </p>
<p> 3 </p>
<p> False </p>
<p> True </p>
<p> False </p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> |  <a href="#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetConstructor</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetConstructorsTopic2"></a><a name="GetConstructors(System.Reflection.BindingFlags)">GetConstructors</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns an array of  <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> objects representing the public and non-public constructors defined for this class, as specified.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo[]</a> GetConstructors(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> This must be a bit flag from  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a>: <b>InvokeMethod</b>, <b>NonPublic</b>, and so on.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns an array of  <a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> objects representing the specified constructors defined for this class. If no constructors are defined, an empty array is returned.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not currently supported in types that are not complete.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> As a workaround, to retrieve the constructor of a finished type, you can retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetCustomAttributesTopic1"></a><a name="GetCustomAttributes(System.Boolean)">GetCustomAttributes</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>inherit</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns all the custom attributes defined for this constructor.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Object.html">object[]</a> GetCustomAttributes(<br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>inherit</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>inherit</i><br><dl>
<dd>
<param> Specifies whether to search this member's inheritance chain to find the attributes.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns an array of objects representing all the custom attributes of the constructor represented by this  <a href="../../System.Reflection.Emit/types/ConstructorBuilder.html">ConstructorBuilder</a> instance.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not currently supported in types that are not complete.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/ICustomAttributeProvider.html#GetCustomAttributes(System.Boolean)">ICustomAttributeProvider.GetCustomAttributes</a></dd>
</dl><b>Remarks</b><dl>
<dd> As a workaround, to retrieve the custom attributes of a finished type, retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> and call  <a href="../../System.Reflection/types/MemberInfo.html#GetCustomAttributes(System.Boolean)">MemberInfo.GetCustomAttributes</a> on the returned  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetCustomAttributesTopic2"></a><a name="GetCustomAttributes(System.Type,System.Boolean)">GetCustomAttributes</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>attributeType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>inherit</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns the custom attributes identified by the given type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Object.html">object[]</a> GetCustomAttributes(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>attributeType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>inherit</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>attributeType</i><br><dl>
<dd>
<param> The <b>Type</b> object to which the custom attributes are applied.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>inherit</i><br><dl>
<dd>
<param> Specifies whether to search this member's inheritance chain to find the attributes.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns an array of objects representing the attributes of this constructor that are of  <a href="../../System/types/Type.html">Type</a><i>attributeType</i>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not currently supported in types that are not complete.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/ICustomAttributeProvider.html#GetCustomAttributes(System.Type,System.Boolean)">ICustomAttributeProvider.GetCustomAttributes</a></dd>
</dl><b>Remarks</b><dl>
<dd> As a workaround, to retrieve the custom attributes of a finished type, retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> and call  <a href="../../System.Reflection/types/MemberInfo.html#GetCustomAttributes(System.Boolean)">MemberInfo.GetCustomAttributes</a> on the returned  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetDefaultMembersTopic1"></a><a name="GetDefaultMembers">GetDefaultMembers</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetDefaultMembers">System.Type.GetDefaultMembers</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the members defined for the current  <a href="../../System/types/Type.html">Type</a> whose  <a href="../../System.Reflection/types/DefaultMemberAttribute.html">DefaultMemberAttribute</a> is set.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo[]</a> GetDefaultMembers();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> objects representing all default members of the current  <a href="../../System/types/Type.html">Type</a>.<p> -or- </p>
<p> An empty array of type  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a>, if the current  <a href="../../System/types/Type.html">Type</a> does not have default members.</p>
</dd>
</dl><b>Remarks</b><dl>
<dd> This method can be overridden by a derived class.<p> Members include properties, methods, fields, events, and so on.</p>
<p> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>

using System;
using System.Reflection;
using System.IO;

[DefaultMemberAttribute("Age")]   
public class MyClass
{
   public void Name(String s) {}
      public int Age
      {
      get
         {
	 return 20;
	 }
      }
   public static void Main()
   {
      try
      {
         Type  myType = typeof(MyClass);
         MemberInfo[] memberInfoArray = myType.GetDefaultMembers();
         if (memberInfoArray.Length &gt; 0)
         {
            Console.WriteLine("The default members of the class MyClass are:\n"); 
               foreach(MemberInfo memberInfoObj in memberInfoArray)
               {
                  Console.WriteLine("The default member name is: " + memberInfoObj.ToString());
               }
         }
         else
         {
         Console.WriteLine("No default members are available."); 
         }
      }
      catch(InvalidOperationException e)
      {
         Console.WriteLine("InvalidOperationException: " + e.Message);
      }
      catch(IOException e)
      {
         Console.WriteLine("IOException: " + e.Message);
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception: " + e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> |  <a href="../../System.Reflection/types/DefaultMemberAttribute.html">DefaultMemberAttribute</a> |  <a href="#GetMember(System.String)">Type.GetMember</a> |  <a href="#GetMembers">Type.GetMembers</a> |  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="GetElementTypeTopic1"></a><a name="GetElementType">GetElementType</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Calling this method always throws  <a href="../../System/types/NotSupportedException.html">NotSupportedException</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Type.html">Type</a> GetElementType();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> This method is not supported. No value is returned.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not currently supported.</td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetEventTopic1"></a><a name="GetEvent(System.String)">GetEvent</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetEvent(System.String)">System.Type.GetEvent</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns the  <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> object representing the specified event.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> GetEvent(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of an event which is declared or inherited by the current  <a href="../../System/types/Type.html">Type</a>.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The  <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> object representing the specified event which is declared or inherited by the current  <a href="../../System/types/Type.html">Type</a>, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
<p> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
			Type myType = typeof(System.Windows.Forms.Button);
         EventInfo myEvent = myType.GetEvent("Click");
         if(myEvent != null)
         {
            Console.WriteLine("Looking for Click event in Button class.");
            Console.WriteLine(myEvent.ToString());
         }
         else
            Console.WriteLine("The Click event is not available with Button class");

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="#GetEvents">Type.GetEvents</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetEventTopic2"></a><a name="GetEvent(System.String,System.Reflection.BindingFlags)">GetEvent</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns the event with the specified name.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> GetEvent(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The name of the event to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> This invocation attribute. This must be a bit flag from  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a>: <b>InvokeMethod</b>, <b>NonPublic</b>, and so on.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns an  <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> object representing the event declared or inherited by this type with the specified name. If there are no matches, then an empty array is returned.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not currently supported in types that are not complete.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> As a workaround, to retrieve the event of a finished type, retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetEventsTopic1"></a><a name="GetEvents">GetEvents</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns the events for the public events declared or inherited by this type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Reflection/types/EventInfo.html">EventInfo[]</a> GetEvents();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns an array of  <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> objects representing the public events declared or inherited by this type. An empty array is returned if there are no public events.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not currently supported in types that are not complete.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> As a workaround, to retrieve the events of a finished type, retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetEventsTopic2"></a><a name="GetEvents(System.Reflection.BindingFlags)">GetEvents</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns the public and non-public events that are declared by this type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Reflection/types/EventInfo.html">EventInfo[]</a> GetEvents(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> This must be a bit flag from  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a>, such as <b>InvokeMethod</b>, <b>NonPublic</b>, and so on.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns an array of  <a href="../../System.Reflection/types/EventInfo.html">EventInfo</a> objects representing the public and non-public events declared or inherited by this type. An empty array is returned if there are no events, as specified.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not currently supported in types that are not complete.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> As a workaround, to retrieve the events of a finished type, retrieve Retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type to retrieve the events.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetFieldTopic1"></a><a name="GetField(System.String)">GetField</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetField(System.String)">System.Type.GetField</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the field with the specified name.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo</a> GetField(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the data field to get.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo</a> object representing the field with the specified name, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
public class MyFieldClassA
{
	public string field = "A Field";
	public string Field
	{
		get
		{
			return field;
		}
		set
		{
			if(field!=value)
			{
				field=value;
         }
		}
	}
}
public class MyFieldClassB
{
	public string field = "B Field";
	public string Field 
	{
		get
		{
			return field;
		}
		set
		{
			if(field!=value)
			{
				field=value;
			}
		}
	}
}

public class MyFieldInfoClass
{
	public static void Main()
	{
		try
		{
			MyFieldClassB myFieldObjectB = new MyFieldClassB();
			MyFieldClassA myFieldObjectA = new MyFieldClassA();

			Type myTypeA = Type.GetType("MyFieldClassA");
			FieldInfo myFieldInfo = myTypeA.GetField("field");
		
			Type myTypeB = Type.GetType("MyFieldClassB");
			FieldInfo myFieldInfo1 = myTypeB.GetField("field", BindingFlags.Public | BindingFlags.Instance);

			Console.WriteLine("The value of the field is : {0} ", myFieldInfo.GetValue(myFieldObjectA));
			Console.WriteLine("The value of the field is : {0} ", myFieldInfo1.GetValue(myFieldObjectB));
		}
		catch(SecurityException e)
		{
			Console.WriteLine("Exception Raised !");
			Console.WriteLine("Message :"+e.Message);
		}
		catch(ArgumentNullException e)
		{
			Console.WriteLine("Exception Raised !");
			Console.WriteLine("Message :"+e.Message);
		}
		catch(Exception e)
		{
			Console.WriteLine("Exception Raised !");
			Console.WriteLine("Message :"+e.Message);
		}
	}
}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetFields">Type.GetFields</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetFieldTopic2"></a><a name="GetField(System.String,System.Reflection.BindingFlags)">GetField</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns the field specified by the given name.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo</a> GetField(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The name of the field to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> This must be a bit flag from  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a>: <b>InvokeMethod</b>, <b>NonPublic</b>, and so on.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns the  <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo</a> object representing the field declared or inherited by this type with the specified name and public or non-public modifier. If there are no matches, then null is returned.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not currently supported in types that are not complete.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#GetField(System.String,System.Reflection.BindingFlags)">IReflect.GetField</a></dd>
</dl><b>Remarks</b><dl>
<dd> As a workaround, to retrieve the field of a finished type, retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetFieldsTopic1"></a><a name="GetFields">GetFields</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetFields">System.Type.GetFields</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns all the public fields of the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo[]</a> GetFields();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo</a> objects representing all the public fields defined for the current  <a href="../../System/types/Type.html">Type</a>.<p> -or- </p>
<p> An empty array of type  <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo</a>, if no public fields are defined for the current  <a href="../../System/types/Type.html">Type</a>.</p>
</dd>
</dl><b>Remarks</b><dl>
<dd> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.<br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
			Console.WriteLine("HashCode of the System.Windows.Forms.Button type is  : {0}",
            typeof(System.Windows.Forms.Button).GetHashCode());

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo</a> |  <a href="#GetField(System.String,System.Reflection.BindingFlags)">Type.GetField</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetFieldsTopic2"></a><a name="GetFields(System.Reflection.BindingFlags)">GetFields</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns the public and non-public fields that are declared by this type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo[]</a> GetFields(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> This must be a bit flag from  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a>, such as InvokeMethod, NonPublic, and so on.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns an array of  <a href="../../System.Reflection/types/FieldInfo.html">FieldInfo</a> objects representing the public and non-public fields declared or inherited by this type. An empty array is returned if there are no fields, as specified.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not currently supported in types that are not complete.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#GetFields(System.Reflection.BindingFlags)">IReflect.GetFields</a></dd>
</dl><b>Remarks</b><dl>
<dd> As a workaround, to retrieve the field of a finished type, retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetHashCodeTopic1"></a><a name="GetHashCode">GetHashCode</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetHashCode">System.Type.GetHashCode</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns the hash code for this instance.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Int32.html">int</a> GetHashCode();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An  <a href="../../System/types/Int32.html">Int32</a> containing the hash code for this instance.</dd>
</dl><b>Remarks</b><dl>
<dd> This method overrides  <a href="../../System/types/Object.html#GetHashCode">Object.GetHashCode</a>.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
			Console.WriteLine("HashCode of the System.Windows.Forms.Button type is  : {0}",
            typeof(System.Windows.Forms.Button).GetHashCode());

    </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetInterfaceTopic1"></a><a name="GetInterface(System.String)">GetInterface</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetInterface(System.String)">System.Type.GetInterface</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the interface with the specified name.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Type.html">Type</a> GetInterface(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the interface to get.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System/types/Type.html">Type</a> object representing the interface with the specified name, implemented or inherited by the current  <a href="../../System/types/Type.html">Type</a>, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/TargetInvocationException.html">TargetInvocationException</a></td>
<td> A static initializer is invoked and throws an exception.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
    public static void Main()
    {
        Hashtable hashtableObj = new Hashtable();
        Type objType = hashtableObj.GetType();
        MemberInfo[] arrayMemberInfo;
        MethodInfo[] arrayMethodInfo;
        try
        {   
            // Get the methods implemented in 'IDeserializationCallback' interface.
            arrayMethodInfo =objType.GetInterface("IDeserializationCallback").GetMethods();
            Console.WriteLine ("\nMethods of 'IDeserializationCallback' Interface :");
            for(int index=0;index &lt; arrayMethodInfo.Length ;index++)
                Console.WriteLine (arrayMethodInfo[index].ToString() ); 

            // Get FullName for interface by using Ignore case search.
            Console.WriteLine ("\nMethods of 'IEnumerable' Interface");
            arrayMethodInfo = objType.GetInterface("ienumerable",true).GetMethods();
            for(int index=0;index &lt; arrayMethodInfo.Length ;index++)
               Console.WriteLine (arrayMethodInfo[index].ToString()); 
           
            //Get the Interface methods for 'IDictionary' interface
            InterfaceMapping interfaceMappingObj;
            interfaceMappingObj = objType.GetInterfaceMap(typeof(IDictionary));
            arrayMemberInfo = interfaceMappingObj.InterfaceMethods;
            Console.WriteLine ("\nHashtable class Implements the following IDictionary Interface methods :");
            for(int index=0; index &lt; arrayMemberInfo.Length; index++)
                Console.WriteLine (arrayMemberInfo[index].ToString() ); 
        }
        catch (Exception e)
        {
            Console.WriteLine ("Exception : " + e.ToString());            
        }                 
    }

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/String.html">String</a> |  <a href="#GetInterfaces">Type.GetInterfaces</a> |  <a href="#FindInterfaces(System.Reflection.TypeFilter,System.Object)">Type.FindInterfaces</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetInterfaceTopic2"></a><a name="GetInterface(System.String,System.Boolean)">GetInterface</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>ignoreCase</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns the interface implemented (directly or indirectly) by this class with the fully-qualified name matching the given interface name.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Type.html">Type</a> GetInterface(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>ignoreCase</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The name of the interface.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>ignoreCase</i><br><dl>
<dd>
<param> If <b>true</b>, the search is case-insensitive. If <b>false</b>, the search is case-sensitive.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns a  <a href="../../System/types/Type.html">Type</a> object representing the implemented interface. Returns null if no interface matching name is found.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not currently supported in types that are not complete.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> As a workaround, to retrieve the interface of a finished type, retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="GetInterfaceMapTopic1"></a><a name="GetInterfaceMap(System.Type)">GetInterfaceMap</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>interfaceType</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns an interface mapping for the interface requested.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Reflection/types/InterfaceMapping.html">InterfaceMapping</a> GetInterfaceMap(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>interfaceType</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>interfaceType</i><br><dl>
<dd>
<param> The type of the interface for which the interface mapping is to be retrieved.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The requested interface mapping.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td> The type does not implement the interface.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> As a workaround, to retrieve the interface mapping types of a finished type, retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="GetInterfacesTopic1"></a><a name="GetInterfaces">GetInterfaces</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns an array of all the interfaces implemented on this a class and its base classes.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Type.html">Type[]</a> GetInterfaces();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns an array of  <a href="../../System/types/Type.html">Type</a> objects representing the implemented interfaces. If none are defined, an empty array is returned.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMemberTopic1"></a><a name="GetMember(System.String)">GetMember</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetMember(System.String)">System.Type.GetMember</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the members with the specified name.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo[]</a> GetMember(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the public members to get.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> objects representing the public members with the specified name, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.<p> Members include properties, methods, fields, events, and so on.</p>
<p> This method searches the current classes and its base classes. Only public methods can be found using this method. If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
<p> Class initializers are available through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>, and  <a href="#GetConstructors">Type.GetConstructors</a>.</p>
<p> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
	public void GetMemberInfo()
	{
		String myString = "GetMember_String";

		Type myType = myString.GetType();
		// Get the members for myString starting with 'C',using searchCriteria 'C*'.
		MemberInfo[] myMembers = myType.GetMember("C*");
      if(myMembers.Length &gt; 0)
      {
         Console.WriteLine("\nThe Member(s) starting with 'C' for type {0} :", myType);
         for(int index=0; index &lt; myMembers.Length; index++)
            Console.WriteLine("Member {0} : {1}", index + 1, myMembers[index].ToString());
      }
      else
            Console.WriteLine("No Members match the Search Criteria.");    
	}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMembers">Type.GetMembers</a> |  <a href="#GetDefaultMembers">Type.GetDefaultMembers</a> |  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMemberTopic2"></a><a name="GetMember(System.String,System.Reflection.BindingFlags)">GetMember</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetMember(System.String,System.Reflection.BindingFlags)">System.Type.GetMember</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified members, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo[]</a> GetMember(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the members to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> objects representing the public members with the specified name, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#GetMember(System.String,System.Reflection.BindingFlags)">IReflect.GetMember</a></dd>
</dl><b>Remarks</b><dl>
<dd> This method can be overridden by a derived class.<p> Members include properties, methods, fields, events, and so on.</p>
<p> This method searches the current classes and its base classes. If the requested member is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which members to include in the search: </p>
<UL>
<li><i>Instance</i> to include instance members in the search.</li>
<li><i>Static</i> to include static members in the search.</li>
<li><i>Public</i> to include public members in the search.</li>
<li><i>NonPublic</i> to include non-public members (that is, private and protected members) in the search.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><i>IgnoreCase</i> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <i>IgnoreCase</i> flag.</li>
<li><i>DeclaredOnly</i> to search only the members declared on the  <a href="../../System/types/Type.html">Type</a>, not members that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> Class initializers are available through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>, and  <a href="#GetConstructors">Type.GetConstructors</a>.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
	public void GetPublicStaticMemberInfo()
	{
		String myString = "GetMember_String_BindingFlag";

		Type myType = myString.GetType();
      // Get the Public Static members for the class myString starting with 'C'.
		MemberInfo[] myMembers = myType.GetMember("C*",
                                 BindingFlags.Public |BindingFlags.Static);

      if(myMembers.Length &gt; 0)
      {
         Console.WriteLine("\nThe Public Static Member(s)  starting with 'C' for type {0} :",myType);
         for(int index=0; index &lt; myMembers.Length; index++)
            Console.WriteLine("Member {0} : {1}", index + 1, myMembers[index].ToString());
      }
      else
         Console.WriteLine("No Members match the Search Criteria.");    
	}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMembers">Type.GetMembers</a> |  <a href="#GetDefaultMembers">Type.GetDefaultMembers</a> |  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMemberTopic3"></a><a name="GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">GetMember</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/MemberTypes.html">MemberTypes</a> <i>type</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns all the public and non-public members declared or inherited by this type, as specified.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo[]</a> GetMember(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/MemberTypes.html">MemberTypes</a> <i>type</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The name of the member.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>type</i><br><dl>
<dd>
<param> The type of member that is to be returned.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> This must be a bit flag from  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a>: <b>InvokeMethod</b>, <b>NonPublic</b>, and so on.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns an array of  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> objects representing the public and non-public members defined on this type if <i>nonPublic</i> is used; otherwise, only the public members are returned.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not currently supported in types that are not complete.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> As a workaround, to retrieve the member of a finished type, retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMembersTopic1"></a><a name="GetMembers">GetMembers</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetMembers">System.Type.GetMembers</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns all the public members of the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo[]</a> GetMembers();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> objects representing all the public members of the current  <a href="../../System/types/Type.html">Type</a>.<p> -or- </p>
<p> An empty array of type  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a>, if the current  <a href="../../System/types/Type.html">Type</a> does not have public members.</p>
</dd>
</dl><b>Remarks</b><dl>
<dd> Members include properties, methods, fields, events, and so on.<p> Class initializers are available through  <a href="#GetMember(System.String)">Type.GetMember</a>,  <a href="#GetMembers">Type.GetMembers</a>,  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a>, and  <a href="#GetConstructors">Type.GetConstructors</a>.</p>
<p> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
class MyClass
{
   public int myInt = 0;
   public string myString = null;

   public MyClass()
   {
   }
   public void Myfunction()
   {
   }
}

class Type_GetMembers
{
   public static void Main()
   {
      try
      {
         MyClass myObject = new MyClass();
         MemberInfo[] myMemberInfo; 

         // Get the type of 'MyClass'.
         Type myType = myObject.GetType(); 
        
         // Get the information related to all public member's of 'MyClass'. 
         myMemberInfo = myType.GetMembers();
    
         Console.WriteLine( "\nThe members of class '{0}' are :\n", myType); 
         for (int i =0 ; i &lt; myMemberInfo.Length ; i++)
         {
            // Display name and type of the concerned member.
            Console.WriteLine( "'{0}' is a {1}", myMemberInfo[i].Name, myMemberInfo[i].MemberType);
         }
      }
      catch(SecurityException e)
      {
         Console.WriteLine("Exception : " + e.Message ); 
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> |  <a href="#GetMember(System.String)">Type.GetMember</a> |  <a href="#GetDefaultMembers">Type.GetDefaultMembers</a> |  <a href="#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMembersTopic2"></a><a name="GetMembers(System.Reflection.BindingFlags)">GetMembers</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns all the public and non-public members declared or inherited by this type, as specified.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo[]</a> GetMembers(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> This must be a bit flag from  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a>: <b>InvokeMethod</b>, <b>NonPublic</b>, and so on.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns an array of  <a href="../../System.Reflection/types/MemberInfo.html">MemberInfo</a> objects representing the public and non-public members declared or inherited by this type. An empty array is returned if there are no matching members.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not currently supported in types that are not complete.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#GetMembers(System.Reflection.BindingFlags)">IReflect.GetMembers</a></dd>
</dl><b>Remarks</b><dl>
<dd> As a workaround, to retrieve the members of a finished type, retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMethodTopic1"></a><a name="GetMethod(System.String)">GetMethod</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetMethod(System.String)">System.Type.GetMethod</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the public method with the specified name.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> GetMethod(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the public method to get.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> object representing the public method with the specified name, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one method is found with the specified name.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p><br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
class MyClass
{
   public int myInt = 0;
   public string myString = null;

   public MyClass()
   {
   }
   public void Myfunction(int i)
   {
   } 
}
class Type_GetMethod
{
   public static void Main()
   {
      try
      {         
         MyClass MyObject = new MyClass();
         MethodInfo myMethodInfo; 

         // Get the type of the class 'MyClass'.
         Type myType = MyObject.GetType(); 
        
         // Get the method information for a method named 'MyFunction'. 
         myMethodInfo = myType.GetMethod("Myfunction");
         
         // Get the parameters for the method 'Myfunction'.
         ParameterInfo[] myParameters = myMethodInfo.GetParameters();
    
         Console.WriteLine( "\nThe parameters of the method 'Myfunction' of class 'MyClass' are :\n"); 
         
         // Display the position and type of the parameters.
         for(int i = 0; i &lt; myParameters.Length; i++)
            Console.WriteLine("The parameter {0} is of type {1}", 
               myParameters[i].Position + 1, myParameters[i].ParameterType);
      }
      catch (SecurityException e)
      {
         Console.WriteLine("SecurityException : " + e.Message ); 
      }
      catch (Exception e)
      {
         Console.WriteLine("Exception : " + e.Message ); 
      }      
   }
}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetMethodImpl</a> |  <a href="#GetMethods">Type.GetMethods</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMethodTopic2"></a><a name="GetMethod(System.String,System.Reflection.BindingFlags)">GetMethod</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetMethod(System.String,System.Reflection.BindingFlags)">System.Type.GetMethod</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified method, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> GetMethod(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the method to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> object representing the method that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one method is found with the specified name and matching the specified binding constraints.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#GetMethod(System.String,System.Reflection.BindingFlags)">IReflect.GetMethod</a></dd>
</dl><b>Remarks</b><dl>
<dd> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which methods to include in the search: <UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public methods in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public methods (that is, private and protected members) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static methods up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.IgnoreCase</b> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <b>IgnoreCase</b> flag.</li>
<li><b>BindingFlags.DeclaredOnly</b> to search only the methods declared on the  <a href="../../System/types/Type.html">Type</a>, not methods that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p><br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
class MyClass
{
   public void MyMethod()
   {    
   }
}

public class Type_GetMethod
{
   public static void Main()
   {
      try
      {
         // Get the type of 'MyClass'.
         Type myType = typeof(MyClass);
         
         // Get the method information of the type 'MyClass'.
         MethodInfo myMethodInfo = myType.GetMethod("MyMethod",
            BindingFlags.Public|BindingFlags.Instance );
         
         // Displays the member info to the console.
         Console.WriteLine("\nThe signature of 'MyMethod' is : {0}", myMethodInfo.ToString());
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception : {0}", e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetMethodImpl</a> |  <a href="#GetMethods">Type.GetMethods</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMethodTopic3"></a><a name="GetMethod(System.String,System.Type[])">GetMethod</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetMethod(System.String,System.Type[])">System.Type.GetMethod</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified public method whose parameters match the specified argument types.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> GetMethod(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the public method to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the method to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the method to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> object representing the public method whose parameters match the specified argument types, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one method is found with the specified name and specified parameters.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p> -or- </p>
<p><i>types</i> is <b>null</b>.</p>
<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.<p> -or- </p>
<p><i>modifiers</i> is multidimensional.</p>
<p> -or- </p>
<p><i>types</i> and <i>modifiers</i> do not have the same length.</p>
</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p><br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
            // Get a 'Type' object corresponding to 'MyClass1' class.
            Type myClassType = typeof(MyClass1);
            // Create a Type array.
            Type[] typeArray =new Type[1];
            typeArray.SetValue(typeof(int),0);
            // Find the method matching the specified argument types.
            MethodInfo myMethodInfo = 
                        myClassType.GetMethod("MyMethod",typeArray);
            Console.WriteLine("The Name of the Method :"+myMethodInfo);

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetMethodImpl</a> |  <a href="#GetMethods">Type.GetMethods</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMethodTopic4"></a><a name="GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">GetMethod</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">System.Type.GetMethod</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified public method whose parameters match the specified argument types and modifiers.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> GetMethod(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the public method to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the method to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the method to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <i>types</i> array. The default binder does not process this parameter.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> object representing the public method that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one method is found with the specified name and specified parameters.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p> -or- </p>
<p><i>types</i> is <b>null</b>.</p>
<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.<p> -or- </p>
<p><i>modifiers</i> is multidimensional.</p>
<p> -or- </p>
<p><i>types</i> and <i>modifiers</i> do not have the same length.</p>
</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Although the default binder does not process  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> (the <i>modifiers</i> parameter), you can use the abstract  <a href="../../System.Reflection/types/Binder.html">Binder</a> class to write a custom binder that does process <i>modifiers</i>.<b>ParameterModifier</b> is only used when calling through COM interop, and only parameters that are passed by reference are handled.<p> The <i>types</i> array and the <i>modifiers</i> array have the same length. A parameter specified in the <i>types</i> array can have the following attributes, which are specified in the <i>modifiers</i> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and are used for interoperability.</p>
<p> The search for <i>name</i> is case-sensitive.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p><br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetMethodImpl</a> |  <a href="#GetMethods">Type.GetMethods</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMethodTopic5"></a><a name="GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">GetMethod</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">System.Type.GetMethod</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> GetMethod(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the method to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the method to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the method to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <i>types</i> array. The default binder does not process this parameter.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> object representing the method that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one method is found with the specified name and matching the specified binding constraints.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p> -or- </p>
<p><i>types</i> is <b>null</b>.</p>
<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.<p> -or- </p>
<p><i>modifiers</i> is multidimensional.</p>
<p> -or- </p>
<p><i>types</i> and <i>modifiers</i> do not have the same length.</p>
</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">IReflect.GetMethod</a></dd>
</dl><b>Remarks</b><dl>
<dd> Although the default binder does not process  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> (the <i>modifiers</i> parameter), you can use the abstract  <a href="../../System.Reflection/types/Binder.html">Binder</a> class to write a custom binder that does process <i>modifiers</i>.<b>ParameterModifier</b> is only used when calling through COM interop, and only parameters that are passed by reference are handled.<p> The <i>types</i> array and the <i>modifiers</i> array have the same length. A parameter specified in the <i>types</i> array can have the following attributes, which are specified in the <i>modifiers</i> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.</p>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which methods to include in the search: </p>
<UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public methods in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public methods (that is, private and protected members) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static methods up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.IgnoreCase</b> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <b>IgnoreCase</b> flag.</li>
<li><b>BindingFlags.DeclaredOnly</b> to search only the methods declared on the  <a href="../../System/types/Type.html">Type</a>, not methods that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p><br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
public class MyClass
{
   public int i = 10;
   public string k = "My Field";
   public int MyMethod(int i)
   {
      this.i = i;
      return i;
   }
   public string MyMethod(string k)
   {
      this.k = k;
      return k;
   }
}
public class Type_GetMethod
{
   public static void Main()
   {
      try
      {
         // Get the type of the class 'MyClass'.
         Type myType = typeof(MyClass);

         // Get the attributes of the method and the metadata of the method 'MyMethod'.
         MethodInfo myMethodInfo = myType.GetMethod("MyMethod", 
            BindingFlags.Public | BindingFlags.Instance, null, 
            new Type[] {typeof(int)}, null);
         
         Console.WriteLine("\n Declaring type of the method '{0}' is : \n '{1}'", myMethodInfo,
            myMethodInfo.DeclaringType);
         
         // Get the attributes of the method and the metadata of the method 'MyMethod'.
         MethodInfo myMethodInfo1 = myType.GetMethod("MyMethod", 
            BindingFlags.Public | BindingFlags.Instance, null, 
            new Type[] {typeof(string)}, null);
         
         Console.WriteLine("\n Declaring type of the method '{0}' is : \n '{1}'", myMethodInfo1,
            myMethodInfo1.DeclaringType);
         
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception : {0}", e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="../../System.Reflection/types/Binder.html">Binder</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetMethodImpl</a> |  <a href="#GetMethods">Type.GetMethods</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMethodTopic6"></a><a name="GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">GetMethod</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">System.Type.GetMethod</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> GetMethod(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the method to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>callConvention</i><br><dl>
<dd>
<param> The  <a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the method to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the method to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <i>types</i> array. The default binder does not process this parameter.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> object representing the method that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one method is found with the specified name and matching the specified binding constraints.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p> -or- </p>
<p><i>types</i> is <b>null</b>.</p>
<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.<p> -or- </p>
<p><i>modifiers</i> is multidimensional.</p>
<p> -or- </p>
<p><i>types</i> and <i>modifiers</i> do not have the same length.</p>
</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Although the default binder does not process  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> (the <i>modifiers</i> parameter), you can use the abstract  <a href="../../System.Reflection/types/Binder.html">Binder</a> class to write a custom binder that does process <i>modifiers</i>.<b>ParameterModifier</b> is only used when calling through COM interop, and only parameters that are passed by reference are handled.<p> The following table shows what members of a base class are returned by the <b>GetXXX</b> methods when reflecting on a type.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
<p> The <i>types</i> array and the <i>modifiers</i> array have the same length. A parameter specified in the <i>types</i> array can have the following attributes, which are specified in the <i>modifiers</i> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.</p>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which methods to include in the search: </p>
<UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public methods in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public methods (that is, private and protected members) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static methods up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.IgnoreCase</b> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <b>IgnoreCase</b> flag.</li>
<li><b>BindingFlags.DeclaredOnly</b> to search only the methods declared on the  <a href="../../System/types/Type.html">Type</a>, not methods that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p><br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>

public class MyClass
{
   public int i = 10;
   public int j = 2;
   
   public int MyFunc(int i , int j)
   {
      int k;
      k = i * 10 - j;
      return k;
   }
}
public class Type_GetMethod
{
   public static void Main()
   {
      try
      {
         // Get the type of the class 'MyClass'.
         Type myType = typeof(MyClass);

         // Get the method information of 'MyFunc(int , int )'.
         MemberInfo myMemberInfo = myType.GetMethod("MyFunc", BindingFlags.Public |
                                                         BindingFlags.Instance, 
                                                         null, 
                                                         CallingConventions.Any,  
                                                         new Type[] {typeof(int),typeof(int)}, 
                                                         null);
         
         Console.WriteLine("\nDisplaying method 'MyFunc' : \n");
         
         // Print the method information to the console.
         Console.WriteLine("{0}", myMemberInfo);
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception : {0}", e.Message);
      }
   }
}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting non-public objects. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#TypeInformation">ReflectionPermissionFlag.TypeInformation</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="../../System.Reflection/types/Binder.html">Binder</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetMethodImpl</a> |  <a href="#GetMethods">Type.GetMethods</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="GetMethodImplTopic1"></a><a name="GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">GetMethodImpl</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected override <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> GetMethodImpl(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> <i>callConvention</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the method to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to conduct a case-sensitive search for public methods.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to conduct a case-sensitive search for public methods.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="../../System/types/Type.html#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="../../System/types/Type.html#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>callConvention</i><br><dl>
<dd>
<param> The  <a href="../../System.Reflection/types/CallingConventions.html">CallingConventions</a> object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the method to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the method to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <i>types</i> array.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> object representing the method that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not currently supported in types that are not complete.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> As a workaround, to retrieve the method, retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMethodsTopic1"></a><a name="GetMethods">GetMethods</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetMethods">System.Type.GetMethods</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns all the public methods of the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo[]</a> GetMethods();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> objects representing all the public methods defined for the current  <a href="../../System/types/Type.html">Type</a>.<p> -or- </p>
<p> An empty array of type  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a>, if no public methods are defined for the current  <a href="../../System/types/Type.html">Type</a>.</p>
</dd>
</dl><b>Remarks</b><dl>
<dd> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.<br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL><br><br><b>Note </b> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> |  <a href="#GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetMethod</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetMethodsTopic2"></a><a name="GetMethods(System.Reflection.BindingFlags)">GetMethods</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns all the public and non-public methods declared or inherited by this type, as specified.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo[]</a> GetMethods(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> This must be a bit flag from  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a>, such as <b>InvokeMethod</b>, <b>NonPublic</b>, and so on.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns an array of  <a href="../../System.Reflection/types/MethodInfo.html">MethodInfo</a> objects representing the public and non-public methods defined on this type if <i>nonPublic</i> is used; otherwise, only the public methods are returned.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not currently supported in types that are not complete.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#GetMethods(System.Reflection.BindingFlags)">IReflect.GetMethods</a></dd>
</dl><b>Remarks</b><dl>
<dd> As a workaround, to retrieve the methods of a finished type, retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetNestedTypeTopic1"></a><a name="GetNestedType(System.String)">GetNestedType</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetNestedType(System.String)">System.Type.GetNestedType</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the nested type with the specified name.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Type.html">Type</a> GetNestedType(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the nested type to get.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System/types/Type.html">Type</a> object representing the nested type with the specified name, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.<p> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="#GetNestedTypes">Type.GetNestedTypes</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetNestedTypeTopic2"></a><a name="GetNestedType(System.String,System.Reflection.BindingFlags)">GetNestedType</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns the public and non-public nested types that are declared by this type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Type.html">Type</a> GetNestedType(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the nested type to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to conduct a case-sensitive search for public methods.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to conduct a case-sensitive search for public methods.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System/types/Type.html">Type</a> object representing the nested type that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not currently supported in types that are not complete.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> As a workaround, to retrieve the nested type of a finished type, retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetNestedTypesTopic1"></a><a name="GetNestedTypes">GetNestedTypes</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetNestedTypes">System.Type.GetNestedTypes</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns all the types nested within the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Type.html">Type[]</a> GetNestedTypes();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System/types/Type.html">Type</a> objects representing all the types nested within the current  <a href="../../System/types/Type.html">Type</a>.<p> -or- </p> An empty array of type  <a href="../../System/types/Type.html">Type</a>, if no types are nested within the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl><b>Remarks</b><dl>
<dd> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.<br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
                  // Get Type Object corresponding to MyClass.
                  Type myType=typeof(MyClass);
                  // Get array of nested type objects which are in 'MyClass'.                 
                  Type[] nestType=myType.GetNestedTypes();
                  Console.WriteLine("Number of nested types are {0}",nestType.Length);
                  foreach(Type t in nestType)
                     Console.WriteLine("Nested type is {0}",t.ToString());

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#GetNestedType(System.String)">Type.GetNestedType</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetNestedTypesTopic2"></a><a name="GetNestedTypes(System.Reflection.BindingFlags)">GetNestedTypes</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns the public and non-public nested types that are declared or inherited by this type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Type.html">Type[]</a> GetNestedTypes(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> This must be a bit flag from  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a>, such as <b>InvokeMethod</b>, <b>NonPublic</b>, and so on.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System/types/Type.html">Type</a> objects representing all the types nested within the current  <a href="../../System/types/Type.html">Type</a> that match the specified binding constraints.<p> An empty array of type  <a href="../../System/types/Type.html">Type</a>, if no types are nested within the current  <a href="../../System/types/Type.html">Type</a>, or if none of the nested types match the binding constraints.</p>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not currently supported in types that are not complete.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> As a workaround, to retrieve the nested types of a finished type, retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetPropertiesTopic1"></a><a name="GetProperties">GetProperties</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetProperties">System.Type.GetProperties</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns all the public properties of the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo[]</a> GetProperties();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An array of  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> objects representing all public properties of the current  <a href="../../System/types/Type.html">Type</a>.<p> -or- </p>
<p> An empty array of type  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a>, if the current  <a href="../../System/types/Type.html">Type</a> does not have public properties.</p>
</dd>
</dl><b>Remarks</b><dl>
<dd> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.<br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
				PropertyInfo[] myPropertyInfo;
				// Get the properties of 'Type' class object.
				myPropertyInfo = Type.GetType("System.Type").GetProperties();
				Console.WriteLine("Properties of System.Type are:");
            for (int i = 0; i &lt; myPropertyInfo.Length; i++)
				{
					Console.WriteLine(myPropertyInfo[i].ToString());
				}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> |  <a href="#GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">Type.GetProperty</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetPropertiesTopic2"></a><a name="GetProperties(System.Reflection.BindingFlags)">GetProperties</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns all the public and non-public properties declared or inherited by this type, as specified.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo[]</a> GetProperties(<br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> This invocation attribute. This must be a bit flag from  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a>: <b>InvokeMethod</b>, <b>NonPublic</b>, and so on.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns an array of  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> objects representing the public and non-public properties defined on this type if <i>nonPublic</i> is used; otherwise, only the public properties are returned.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not currently supported in types that are not complete.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#GetProperties(System.Reflection.BindingFlags)">IReflect.GetProperties</a></dd>
</dl><b>Remarks</b><dl>
<dd> As a workaround, to retrieve the properties of a finished type, retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetPropertyTopic1"></a><a name="GetProperty(System.String)">GetProperty</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetProperty(System.String)">System.Type.GetProperty</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the public property with the specified name.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> GetProperty(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the public property to get.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> object representing the public property with the specified name, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one property is found with the specified name.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> Different languages use different syntax to specify default or parameterized properties.<pre>
            // Get Type Object corresponding to MyClass.
            Type myType=typeof(MyClass);       
            // Get PropertyInfo object by passing property name.
            PropertyInfo myPropInfo = myType.GetProperty("MyProperty");
            // Display Name propety to console.
            Console.WriteLine("The Property {0} exists",myPropInfo.Name);
            }

    </pre>
<p> Internally, this property is referred to by the name "Item" in the metadata. Therefore, any attempt to get <b>PropertyInfo</b> using reflection must specify this internal name in order for the <b>PropertyInfo</b> to be returned correctly.</p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">Type.GetPropertyImpl</a> |  <a href="#GetProperties(System.Reflection.BindingFlags)">Type.GetProperties</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetPropertyTopic2"></a><a name="GetProperty(System.String,System.Reflection.BindingFlags)">GetProperty</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetProperty(System.String,System.Reflection.BindingFlags)">System.Type.GetProperty</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified property, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> GetProperty(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the property to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> object representing the property that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one property is found with the specified name and matching the specified binding constraints.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#GetProperty(System.String,System.Reflection.BindingFlags)">IReflect.GetProperty</a></dd>
</dl><b>Remarks</b><dl>
<dd> The <i>types</i> array and the <i>modifiers</i> array have the same length. A parameter specified in the <i>types</i> array can have the following attributes, which are specified in the <i>modifiers</i> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which properties to include in the search: </p>
<UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public properties in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public properties (that is, private and protected properties ) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static properties up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.IgnoreCase</b> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <b>IgnoreCase</b> flag.</li>
<li><b>BindingFlags.DeclaredOnly</b> to search only the properties declared on the  <a href="../../System/types/Type.html">Type</a>, not properties that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> Different languages use different syntax to specify default or parameterized properties.<pre>
            // Get Type Object corresponding to MyClass.
            Type myType=typeof(MyClass);       
            // Get PropertyInfo object by passing property name and specifying BindingFlags.
            PropertyInfo myPropInfo = myType.GetProperty("MyProperty",
                                                   BindingFlags.Public|
                                                   BindingFlags.Instance);
            // Display Name propety to console.
            Console.WriteLine("{0} is a Property of 'MyClass'.",myPropInfo.Name);
            }

    </pre>
<p> Internally, this property is referred to by the name "Item" in the metadata. Therefore, any attempt to get <b>PropertyInfo</b> using reflection must specify this internal name in order for the <b>PropertyInfo</b> to be returned correctly.</p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">Type.GetPropertyImpl</a> |  <a href="#GetProperties(System.Reflection.BindingFlags)">Type.GetProperties</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetPropertyTopic3"></a><a name="GetProperty(System.String,System.Type)">GetProperty</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetProperty(System.String,System.Type)">System.Type.GetProperty</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the public property with the specified name and return type.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> GetProperty(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the public property to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>returnType</i><br><dl>
<dd>
<param> The return type of the property.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> object representing the public property with the specified name, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one property is found with the specified name.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> Different languages use different syntax to specify default or parameterized properties.<pre>
			Type myType = typeof(MyClass1);
		
			// Get the 'PropertyInfo' object representing 'MyProperty1' property. 
			PropertyInfo myStringProperties1 = myType.GetProperty("MyProperty1",
				typeof(string));
			Console.WriteLine("The Name of the first Property of MyClass1 :"+myStringProperties1.Name);
			Console.WriteLine("The Type of first Property of MyClass1 :"+myStringProperties1.PropertyType);

			// Get a 'Type' array  corresponding to the indexed  property.
			Type[] myTypeArr = new Type[2];
			myTypeArr.SetValue(typeof(int),0);            
			myTypeArr.SetValue(typeof(int),1);

			// Get the 'PropertyInfo' object representing 'MyProperty2' property. 
			PropertyInfo myStringProperties2 =myType.GetProperty("Item",typeof(int),myTypeArr);
			Console.WriteLine("{0} property exists in MyClass1.",myStringProperties2.ToString());
			Console.WriteLine("The Name of the second Property of MyClass1 :"+myStringProperties2.Name);
			Console.WriteLine("The Type of second Property of MyClass1 :"+myStringProperties2.PropertyType);

    </pre>
<p> Internally, this property is referred to by the name "Item" in the metadata. Therefore, any attempt to get <b>PropertyInfo</b> using reflection must specify this internal name in order for the <b>PropertyInfo</b> to be returned correctly.</p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">Type.GetPropertyImpl</a> |  <a href="#GetProperties(System.Reflection.BindingFlags)">Type.GetProperties</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetPropertyTopic4"></a><a name="GetProperty(System.String,System.Type[])">GetProperty</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetProperty(System.String,System.Type[])">System.Type.GetProperty</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified public property whose parameters match the specified argument types.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> GetProperty(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the public property to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> object representing the public property whose parameters match the specified argument types, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one property is found with the specified name and matching the specified argument types.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p> -or- </p>
<p><i>types</i> is <b>null</b>.</p>
<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> Different languages use different syntax to specify default or parameterized properties.<pre>
				// Get Type Object.
				Type myType=typeof(MyClass1);       
				Type[] myTypeArr = new Type[2];
				// Initialize Type array.
				myTypeArr.SetValue(typeof(int),0);            
				myTypeArr.SetValue(typeof(int),1);
				// Get PropertyInfo object for indexed property 'Item' which has two integer parameters. 
				PropertyInfo myPropInfo = myType.GetProperty("Item",myTypeArr);
				// Dispaly propety to console.
				Console.WriteLine("{0} property exists in MyClass1.",myPropInfo.ToString());

    </pre>
<p> Internally, this property is referred to by the name "Item" in the metadata. Therefore, any attempt to get <b>PropertyInfo</b> using reflection must specify this internal name in order for the <b>PropertyInfo</b> to be returned correctly.</p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">Type.GetPropertyImpl</a> |  <a href="#GetProperties(System.Reflection.BindingFlags)">Type.GetProperties</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetPropertyTopic5"></a><a name="GetProperty(System.String,System.Type,System.Type[])">GetProperty</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetProperty(System.String,System.Type,System.Type[])">System.Type.GetProperty</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified public property whose parameters match the specified argument types.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> GetProperty(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the public property to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>returnType</i><br><dl>
<dd>
<param> The return type of the property.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> object representing the public property whose parameters match the specified argument types, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one property is found with the specified name and matching the specified argument types.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p> -or- </p>
<p><i>types</i> is <b>null</b>.</p>
<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The search for <i>name</i> is case-sensitive.<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd></dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">Type.GetPropertyImpl</a> |  <a href="#GetProperties(System.Reflection.BindingFlags)">Type.GetProperties</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetPropertyTopic6"></a><a name="GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">GetProperty</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">System.Type.GetProperty</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified public property whose parameters match the specified argument types and modifiers.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> GetProperty(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the public property to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>returnType</i><br><dl>
<dd>
<param> The return type of the property.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <i>types</i> array. The default binder does not process this parameter.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> object representing the public property that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one property is found with the specified name and matching the specified argument types and modifiers.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p> -or- </p>
<p><i>types</i> is <b>null</b>.</p>
<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.<p> -or- </p>
<p><i>modifiers</i> is multidimensional.</p>
<p> -or- </p>
<p><i>types</i> and <i>modifiers</i> do not have the same length.</p>
</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Although the default binder does not process  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> (the <i>modifiers</i> parameter), you can use the abstract  <a href="../../System.Reflection/types/Binder.html">Binder</a> class to write a custom binder that does process <i>modifiers</i>.<b>ParameterModifier</b> is only used when calling through COM interop, and only parameters that are passed by reference are handled.<p> The <i>types</i> array and the <i>modifiers</i> array have the same length. A parameter specified in the <i>types</i> array can have the following attributes, which are specified in the <i>modifiers</i> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.</p>
<p> The search for <i>name</i> is case-sensitive.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> Different languages use different syntax to specify default or parameterized properties.<pre>
// MyPropAA - ReadOnly
protected short m_prvPropAA = -1;
public short m_PropAA = -2;
public short this [Boolean nonPublic]
{
    //get accessor for property {short MyPropAA}
    get {
        return ((nonPublic) ? m_prvPropAA: m_PropAA);
    }
}

    </pre>
<p> Internally, this property is referred to by the name "Item" in the metadata. Therefore, any attempt to get <b>PropertyInfo</b> using reflection must specify this internal name in order for the <b>PropertyInfo</b> to be returned correctly.</p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">Type.GetPropertyImpl</a> |  <a href="#GetProperties(System.Reflection.BindingFlags)">Type.GetProperties</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="GetPropertyTopic7"></a><a name="GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">GetProperty</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">System.Type.GetProperty</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> GetProperty(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the property to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to return <b>null</b>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>returnType</i><br><dl>
<dd>
<param> The return type of the property.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <i>types</i> array. The default binder does not process this parameter.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> object representing the property that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one property is found with the specified name and matching the specified binding constraints.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>name</i> is <b>null</b>.<p> -or- </p>
<p><i>types</i> is <b>null</b>.</p>
<p> -or- </p>
<p> One of the elements in <i>types</i> is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>types</i> is multidimensional.<p> -or- </p>
<p><i>modifiers</i> is multidimensional.</p>
<p> -or- </p>
<p><i>types</i> and <i>modifiers</i> do not have the same length.</p>
</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">IReflect.GetProperty</a></dd>
</dl><b>Remarks</b><dl>
<dd> Although the default binder does not process  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> (the <i>modifiers</i> parameter), you can use the abstract  <a href="../../System.Reflection/types/Binder.html">Binder</a> class to write a custom binder that does process <i>modifiers</i>.<b>ParameterModifier</b> is only used when calling through COM interop, and only parameters that are passed by reference are handled.<p> The following table shows what members of a base class are returned by the <b>Get</b> methods when reflecting on a type.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
                  Member Type
                </TH>
<TH>
                  Static
                </TH>
<TH>
                  Non-Static
                </TH>
</THEAD>
<TR valign="top">
<TD>
                  Constructor
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Field
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A field is always
                  hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Event
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Method
                </TD>
<TD>
                  No
                </TD>
<TD>
                  Yes. A method (both virtual and non-virtual)
                  can be hide-by-name or hide-by-name-and-signature.
                </TD>
</TR>
<TR valign="top">
<TD>
                  Nested Type
                </TD>
<TD>
                  No
                </TD>
<TD>
                  No
                </TD>
</TR>
<TR valign="top">
<TD>
                  Property
                </TD>
<TD>
                  Not applicable
                </TD>
<TD>
                  The common type system rule is that the
                  inheritance is the same as that of the methods that implement the
                  property. Reflection treats properties as hide-by-name-and-signature. See
                  note 2 below.
                </TD>
</TR>
</table>
<OL>
<li> Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</li>
<li> For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</li>
<li> Custom attributes are not part of the common type system.</li>
</OL>
<p> The <i>types</i> array and the <i>modifiers</i> array have the same length. A parameter specified in the <i>types</i> array can have the following attributes, which are specified in the <i>modifiers</i> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.</p>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which properties to include in the search: </p>
<UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public properties in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public properties (that is, private and protected properties ) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static properties up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.IgnoreCase</b> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <b>IgnoreCase</b> flag.</li>
<li><b>BindingFlags.DeclaredOnly</b> to search only the properties declared on the  <a href="../../System/types/Type.html">Type</a>, not properties that were simply inherited.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> If the requested type is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public objects outside the current assembly, this method returns <b>null</b>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> Different languages use different syntax to specify default or parameterized properties.<p></p>
<p> Internally, this property is referred to by the name "Item" in the metadata. Therefore, any attempt to get <b>PropertyInfo</b> using reflection must specify this internal name in order for the <b>PropertyInfo</b> to be returned correctly.</p>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> |  <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="../../System.Reflection/types/Binder.html">Binder</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> |  <a href="#GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">Type.GetPropertyImpl</a> |  <a href="#GetProperties(System.Reflection.BindingFlags)">Type.GetProperties</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="GetPropertyImplTopic1"></a><a name="GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">GetPropertyImpl</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected override <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> GetPropertyImpl(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>bindingAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>returnType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Type.html">Type[]</a> <i>types</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the property to get.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>bindingAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to conduct a case-sensitive search for public properties.</p> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted.<p> -or- </p>
<p> Zero, to conduct a case-sensitive search for public properties.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="../../System/types/Type.html#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="../../System/types/Type.html#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>returnType</i><br><dl>
<dd>
<param> The return type of the property.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>types</i><br><dl>
<dd>
<param> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p> An array of  <a href="../../System/types/Type.html">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.<p> -or- </p>
<p> An empty array of the type  <a href="../../System/types/Type.html">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <i>types</i> array.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System.Reflection/types/PropertyInfo.html">PropertyInfo</a> object representing the property that matches the specified requirements, if found; otherwise, <b>null</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not currently supported in types that are not complete.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> As a workaround, to retrieve the property of a finished type, retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetTypeTopic1"></a><a name="GetType">GetType</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#GetType">System.Object.GetType</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Type.html">Type</a> GetType();</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="HasElementTypeImplTopic1"></a><a name="HasElementTypeImpl">HasElementTypeImpl</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Calling this method always throws  <a href="../../System/types/NotSupportedException.html">NotSupportedException</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected override <a href="../../System/types/Boolean.html">bool</a> HasElementTypeImpl();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> This method is not supported. No value is returned.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not supported.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="InvokeMemberTopic1"></a><a name="InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">InvokeMember</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>invokeAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>target</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object[]</a> <i>args</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">System.Type.InvokeMember</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Invokes the specified member, using the specified binding constraints and matching the specified argument list.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Object.html">object</a> InvokeMember(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>invokeAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>target</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object[]</a> <i>args</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the constructor, method, property, or field member to invoke. -or- <p> An empty string ("") to invoke the default member.</p> -or- <p> An empty string ("") to invoke the default member.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>invokeAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted. The access can be one of the <b>BindingFlags</b> such as <b>Public</b>, <b>NonPublic</b>, <b>Private</b>, <b>InvokeMethod</b>, <b>GetField</b>, and so on. The type of lookup need not be specified. If the type of lookup is omitted, <b>BindingFlags.Public</b> | <b>BindingFlags.Instance</b> will apply.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>target</i><br><dl>
<dd>
<param> The  <a href="../../System/types/Object.html">Object</a> on which to invoke the specified member.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>args</i><br><dl>
<dd>
<param> An array containing the arguments to pass to the member to invoke.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An  <a href="../../System/types/Object.html">Object</a> representing the return value of the invoked member.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>invokeAttr</i> contains <i>CreateInstance</i> and <i>typeName</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>args</i> is multidimensional.<p> -or- </p>
<p><i>invokeAttr</i> is not a valid  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> attribute.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains <i>CreateInstance</i> combined with <i>InvokeMethod</i>, <i>GetField</i>, <i>SetField</i>, <i>GetProperty</i>, or <i>SetProperty</i>.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains both <i>GetField</i> and <i>SetField</i>.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains both <i>GetProperty</i> and <i>SetProperty</i>.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains <i>InvokeMethod</i> combined with <i>SetField</i> or <i>SetProperty</i>.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains <i>SetField</i> and <i>args</i> has more than one element.</p>
<p> -or- </p>
<p> This method is called on a COM object and one of the following binding flags was not passed in: <b>BindingFlags.InvokeMethod</b>, <b>BindingFlags.GetProperty</b>, <b>BindingFlags.SetProperty</b>, <b>BindingFlags.PutDispProperty</b>, or <b>BindingFlags.PutRefDispProperty</b>.</p>
<p> -or- </p>
<p> One of the named parameter arrays contains a string that is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/MemberAccessException.html">MemberAccessException</a></td>
<td> The specified member is a class initializer.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/MissingFieldException.html">MissingFieldException</a></td>
<td> The field or property cannot be found.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/MissingMethodException.html">MissingMethodException</a></td>
<td> The method cannot be found.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Security/types/SecurityException.html">SecurityException</a></td>
<td> The specified member is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public members outside the current assembly.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/TargetException.html">TargetException</a></td>
<td> The specified member cannot be invoked on <i>target</i>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one method matches the binding criteria.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which members to include in the search: <UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public members in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public members (that is, private and protected members) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static members up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.IgnoreCase</b> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <b>IgnoreCase</b> flag.</li>
<li><b>BindingFlags.DeclaredOnly</b> to search only the members declared on the  <a href="../../System/types/Type.html">Type</a>, not members that were simply inherited.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> invocation flags can be used to denote what action to take with the member: </p>
<UL>
<li><b>CreateInstance</b> to invoke a constructor.<i>name</i> is ignored. Not valid with other invocation flags.</li>
<li><b>InvokeMethod</b> to invoke a method, but not a constructor or a type initializer. Not valid with <b>SetField</b> or <b>SetProperty</b>.</li>
<li><b>GetField</b> to get the value of a field. Not valid with <b>SetField</b>.</li>
<li><b>SetField</b> to set the value of a field. Not valid with <b>GetField</b>.</li>
<li><b>GetProperty</b> to get a property. Not valid with <b>SetProperty</b>.</li>
<li><b>SetProperty</b> to set a property. Not valid with <b>GetProperty</b>.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> A method will be invoked if the following conditions are true: </p>
<UL>
<li> The number of parameters in the method declaration equals the number of arguments in the <i>args</i> array (unless default arguments are defined on the member), and </li>
<li> The type of each arguments can be converted by the binder to the type of the parameter.</li>
</UL> The binder will find all of the matching methods. These methods are found based upon the type of binding requested ( <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> values <b>InvokeMethod</b>, <b>GetProperty</b>, and so on). The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.<p> After the method is selected, it is invoked. Accessibility is checked at that point. The search may control which set of methods are searched based upon the accessibility attribute associated with the method. The  <a href="../../System.Reflection/types/Binder.html#BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)">Binder.BindToMethod</a> method of the  <a href="../../System.Reflection/types/Binder.html">Binder</a> class is responsible for selecting the method to be invoked. The default binder selects the most specific match.</p>
<p> Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through  <a href="../../System.Reflection/System.Reflection.html">System.Reflection</a> whenever the code is fully trusted.</p>
<p> You can use Type.InvokeMember to set a field to a particular value by specifying BindingFlags.SetField. For example, if you want to set a public instance field named F on class C, and F is a <b>String</b> you can say: </p><code>
              typeof(C).InvokeMember( "F",
              BindingFlags.SetField, null, C, new Object{ "strings new value"}, null, null,
              null );
            </code><p> Now suppose that F is a <b>String[]</b> you can say: </p><code>
              typeof(C).InvokeMember( "F",
              BindingFlags.SetField, null, C, new Object{new String[]{"a","z","c","d"}, null,
              null, null );
            </code><p> which will initialize the field F to this new array. Furthermore you can use Type.InvokeMember to set a position in an array by supplying to the index of the value and then the next value by doing the following: </p><code>
              typeof(C).InvokeMember( "F",
              BindingFlags.SetField, null, C, new Object{1, "b"}, null, null, null );
            </code><p> This will change string "z" in the array that F holds to string "b".</p>
</dd>
</dl><b>Example</b><dl>
<dd> Here are syntax examples using <b>InvokeMember</b> to invoke, get, and set various members.<pre>
using System;
using System.IO;
using System.Reflection;

public class Sample
{
 public void Method()
 {

//Call a static method
 Type t = typeof (TestClass);
 t.InvokeMember ("SayHello", BindingFlags.Public | BindingFlags.InvokeMethod | BindingFlags.Static, null, null, new object [] {});
         
 //Call an instance method
 TestClass c = new TestClass ();
 c.GetType().InvokeMember ("AddUp", BindingFlags.Public | BindingFlags.InvokeMethod, null, c, new object [] {});
 c.GetType().InvokeMember ("AddUp", BindingFlags.Public | BindingFlags.InvokeMethod, null, c, new object [] {});
         
 //Call a method with arguments
 object [] args = new object [] {100.09, 184.45};
 object result;
 result = t.InvokeMember ("ComputeSum", BindingFlags.Public | BindingFlags.InvokeMethod | BindingFlags.Static, null, null, args);
 Console.WriteLine ("{0} + {1} = {2}", args[0], args[1], result);
         
 //Get a field value
 result = t.InvokeMember ("Name", BindingFlags.Public | BindingFlags.GetField, null, c, new object [] {});
 Console.WriteLine ("Name == {0}", result);
         
 //Set a field
 t.InvokeMember ("Name", BindingFlags.Public |BindingFlags.SetField, null, c, new object [] {"NewName"});
 result = t.InvokeMember ("Name", BindingFlags.Public |BindingFlags.GetField, null, c, new object [] {});
 Console.WriteLine ("Name == {0}", result);
         
 //Get an indexed property value
 int  index = 3;
 result = t.InvokeMember ("Item", BindingFlags.Public |BindingFlags.GetProperty , null, c, new object [] {index});
 Console.WriteLine ("Item[{0}] == {1}", index, result);
         
 //Set an indexed property value
 index = 3;
 t.InvokeMember ("Item", BindingFlags.Public |BindingFlags.SetProperty, null, c, new object [] {index, "NewValue"});
 result = t.InvokeMember ("Item", BindingFlags.Public |BindingFlags.GetProperty , null, c, new object [] {index});
 Console.WriteLine ("Item[{0}] == {1}", index, result);
         
 //Get a field or property
 result = t.InvokeMember ("Name", BindingFlags.Public |BindingFlags.GetField | BindingFlags.GetProperty, null, c, new object [] {});
 Console.WriteLine ("Name == {0}", result);
 result = t.InvokeMember ("Value", BindingFlags.Public |BindingFlags.GetField | BindingFlags.GetProperty, null, c, new object [] {});
 Console.WriteLine ("Value == {0}", result);
         
 //Call a method using named arguments
 object[] argValues = new object [] {"Mouse", "Micky"};
 String [] argNames = new String [] {"lastName", "firstName"};
 t.InvokeMember ("PrintName", BindingFlags.Public |BindingFlags.InvokeMethod, null, null, argValues, null, null, argNames);
         
 //Call the default member of a type
 Type t3 = typeof (TestClass2);
 t3.InvokeMember ("", BindingFlags.Public |BindingFlags.InvokeMethod, null, new TestClass2(), new object [] {});
         
 //Invoking a ByRef member
 MethodInfo m = t.GetMethod("Swap");
 args = new object[2];
 args[0] = 1;
 args[1] = 2;
 m.Invoke(new TestClass(),args);
 Console.WriteLine ("{0}, {1}", args[0], args[1]);
 Console.WriteLine ("\r\nPress Return to exit.");
 Console.Read();

 }
}

// Class added so sample will compile
public class TestClass {}

// Class added so sample will compile
public class TestClass2 {}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting members that are not public. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#MemberAccess">ReflectionPermissionFlag.MemberAccess</a></dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/SecurityPermission.html">SecurityPermission</a> to call unmanaged code. Associated enumeration:  <a href="../../System.Security.Permissions/types/SecurityPermissionFlag.html#UnmanagedCode">SecurityPermissionFlag.UnmanagedCode</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/Binder.html">Binder</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Reflection/types/ParameterAttributes.html">ParameterAttributes</a> |  <a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="InvokeMemberTopic2"></a><a name="InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">InvokeMember</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>invokeAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>target</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object[]</a> <i>args</i>,</font><br>   <font color="#008080"><a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> <i>culture</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">System.Type.InvokeMember</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Object.html">object</a> InvokeMember(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>invokeAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>target</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object[]</a> <i>args</i>,</font><br>   <font color="#008080"><a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> <i>culture</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The  <a href="../../System/types/String.html">String</a> containing the name of the constructor, method, property, or field member to invoke.<p> -or- </p>
<p> An empty string ("") to invoke the default member.</p> The  <a href="../../System/types/String.html">String</a> containing the name of the constructor, method, property, or field member to invoke.<p> -or- </p>
<p> An empty string ("") to invoke the default member.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>invokeAttr</i><br><dl>
<dd>
<param> A bitmask comprised of one or more  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> that specify how the search is conducted. The access can be one of the <b>BindingFlags</b> such as <b>Public</b>, <b>NonPublic</b>, <b>Private</b>, <b>InvokeMethod</b>, <b>GetField</b>, and so on. The type of lookup need not be specified. If the type of lookup is omitted, <b>BindingFlags.Public</b> | <b>BindingFlags.Instance</b> will apply.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p> A  <a href="../../System.Reflection/types/Binder.html">Binder</a> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.<p> -or- </p>
<p><b>null</b>, to use the  <a href="#DefaultBinder">Type.DefaultBinder</a>.</p>
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>target</i><br><dl>
<dd>
<param> The  <a href="../../System/types/Object.html">Object</a> on which to invoke the specified member.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>args</i><br><dl>
<dd>
<param> An array containing the arguments to pass to the member to invoke.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>culture</i><br><dl>
<dd>
<param> The  <a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.<p> -or- </p>
<p><b>null</b> to use the current thread's  <a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a>.</p> The  <a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.<p> -or- </p>
<p><b>null</b> to use the current thread's  <a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> An  <a href="../../System/types/Object.html">Object</a> representing the return value of the invoked member.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>invokeAttr</i> contains <i>CreateInstance</i> and <i>typeName</i> is <b>null</b>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentException.html">ArgumentException</a></td>
<td><i>args</i> is multidimensional.<p> -or- </p>
<p><i>invokeAttr</i> is not a valid  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> attribute.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains <i>CreateInstance</i> combined with <i>InvokeMethod</i>, <i>GetField</i>, <i>SetField</i>, <i>GetProperty</i>, or <i>SetProperty</i>.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains both <i>GetField</i> and <i>SetField</i>.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains both <i>GetProperty</i> and <i>SetProperty</i>.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains <i>InvokeMethod</i> combined with <i>SetField</i> or <i>SetProperty</i>.</p>
<p> -or- </p>
<p><i>invokeAttr</i> contains <i>SetField</i> and <i>args</i> has more than one element.</p>
<p> -or- </p>
<p> This method is called on a COM object and one of the following binding flags was not passed in: <b>BindingFlags.InvokeMethod</b>, <b>BindingFlags.GetProperty</b>, <b>BindingFlags.SetProperty</b>, <b>BindingFlags.PutDispProperty</b>, or <b>BindingFlags.PutRefDispProperty</b>.</p>
<p> -or- </p>
<p> One of the named parameter arrays contains a string that is <b>null</b>.</p>
</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/MemberAccessException.html">MemberAccessException</a></td>
<td> The specified member is a class initializer.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/MissingFieldException.html">MissingFieldException</a></td>
<td> The field or property cannot be found.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/MissingMethodException.html">MissingMethodException</a></td>
<td> The method cannot be found.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Security/types/SecurityException.html">SecurityException</a></td>
<td> The specified member is non-public and the caller does not have  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> to reflect non-public members outside the current assembly.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/TargetException.html">TargetException</a></td>
<td> The specified member cannot be invoked on <i>target</i>.</td>
</tr>
<tr valign="top">
<td> <a href="../../System.Reflection/types/AmbiguousMatchException.html">AmbiguousMatchException</a></td>
<td> More than one method matches the binding criteria.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Although the default binder does not process  <a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> (the <i>culture</i> parameter), you can use the abstract  <a href="../../System.Reflection/types/Binder.html">Binder</a> class to write a custom binder that does process <i>culture</i>.<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> filter flags can be used to define which members to include in the search: </p>
<UL>
<li> You must specify either <b>BindingFlags.Instance</b> or <b>BindingFlags.Static</b> in order to get a return.</li>
<li> Specify <b>BindingFlags.Public</b> to include public members in the search.</li>
<li> Specify <b>BindingFlags.NonPublic</b> to include non-public members (that is, private and protected members) in the search.</li>
<li> Specify <b>BindingFlags.FlattenHierarchy</b> to include static members up the hierarchy.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> modifier flags can be used to change how the search works: </p>
<UL>
<li><b>BindingFlags.IgnoreCase</b> to ignore the case of <i>name</i>. If <i>name</i> has 128 or more standard ASCII characters, a case-sensitive search is performed, regardless of the <b>IgnoreCase</b> flag.</li>
<li><b>BindingFlags.DeclaredOnly</b> to search only the members declared on the  <a href="../../System/types/Type.html">Type</a>, not members that were simply inherited.</li>
</UL>
<p> The following  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> invocation flags can be used to denote what action to take with the member: </p>
<UL>
<li><b>CreateInstance</b> to invoke a constructor.<i>name</i> is ignored. Not valid with other invocation flags.</li>
<li><b>InvokeMethod</b> to invoke a method, but not a constructor or a type initializer. Not valid with <b>SetField</b> or <b>SetProperty</b>.</li>
<li><b>GetField</b> to get the value of a field. Not valid with <b>SetField</b>.</li>
<li><b>SetField</b> to set the value of a field. Not valid with <b>GetField</b>.</li>
<li><b>GetProperty</b> to get a property. Not valid with <b>SetProperty</b>.</li>
<li><b>SetProperty</b> to set a property. Not valid with <b>GetProperty</b>.</li>
</UL>
<p> See  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> for more information.</p>
<p> A method will be invoked if the following conditions are true: </p>
<UL>
<li> The number of parameters in the method declaration equals the number of arguments in the <i>args</i> array (unless default arguments are defined on the member).</li>
<li> The type of each arguments can be converted by the binder to the type of the parameter.</li>
</UL> The binder will find all of the matching methods. These methods are found based upon the type of binding requested ( <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> values <b>InvokeMethod</b>, <b>GetProperty</b>, and so on). The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.<p> After the method is selected, it is invoked. Accessibility is checked at that point. The search may control which set of methods are searched based upon the accessibility attribute associated with the method. The  <a href="../../System.Reflection/types/Binder.html#BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)">Binder.BindToMethod</a> method of the  <a href="../../System.Reflection/types/Binder.html">Binder</a> class is responsible for selecting the method to be invoked. The default binder selects the most specific match.</p>
<p> Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through Reflection whenever the code is fully trusted.</p>
<p> You can use Type.InvokeMember to set a field to a particular value by specifying BindingFlags.SetField. For example, if you want to set a public instance field named F on class C, and F is a <b>String</b> you can say: </p><code>
              typeof(C).InvokeMember( "F",
              BindingFlags.SetField, null, C, new Object{ "strings new value"}, null, null,
              null );
            </code><p> Now suppose that F is a <b>String[]</b> you can say: </p><code>
              typeof(C).InvokeMember( "F",
              BindingFlags.SetField, null, C, new Object{new String[]{"a","z","c","d"}, null,
              null, null );
            </code><p> which will initialize the field F to this new array. Furthermore you can use Type.InvokeMember to set a position in an array by supplying to the index of the value and then the next value by doing the following: </p><code>
              typeof(C).InvokeMember( "F",
              BindingFlags.SetField, null, C, new Object{1, "b"}, null, null, null );
            </code><p> This will change string "z" in the array that F holds to string "b".</p>
</dd>
</dl><b>Example</b><dl>
<dd> Here are syntax examples using <b>InvokeMember</b> to invoke, get, and set various members.<pre>
using System;
using System.IO;
using System.Reflection;

public class Sample
{
 public void Method()
 {

//Call a static method
 Type t = typeof (TestClass);
 t.InvokeMember ("SayHello", BindingFlags.Public | BindingFlags.InvokeMethod | BindingFlags.Static, null, null, new object [] {});
         
 //Call an instance method
 TestClass c = new TestClass ();
 c.GetType().InvokeMember ("AddUp", BindingFlags.Public | BindingFlags.InvokeMethod, null, c, new object [] {});
 c.GetType().InvokeMember ("AddUp", BindingFlags.Public | BindingFlags.InvokeMethod, null, c, new object [] {});
         
 //Call a method with arguments
 object [] args = new object [] {100.09, 184.45};
 object result;
 result = t.InvokeMember ("ComputeSum", BindingFlags.Public | BindingFlags.InvokeMethod | BindingFlags.Static, null, null, args);
 Console.WriteLine ("{0} + {1} = {2}", args[0], args[1], result);
         
 //Get a field value
 result = t.InvokeMember ("Name", BindingFlags.Public | BindingFlags.GetField, null, c, new object [] {});
 Console.WriteLine ("Name == {0}", result);
         
 //Set a field
 t.InvokeMember ("Name", BindingFlags.Public |BindingFlags.SetField, null, c, new object [] {"NewName"});
 result = t.InvokeMember ("Name", BindingFlags.Public |BindingFlags.GetField, null, c, new object [] {});
 Console.WriteLine ("Name == {0}", result);
         
 //Get an indexed property value
 int  index = 3;
 result = t.InvokeMember ("Item", BindingFlags.Public |BindingFlags.GetProperty , null, c, new object [] {index});
 Console.WriteLine ("Item[{0}] == {1}", index, result);
         
 //Set an indexed property value
 index = 3;
 t.InvokeMember ("Item", BindingFlags.Public |BindingFlags.SetProperty, null, c, new object [] {index, "NewValue"});
 result = t.InvokeMember ("Item", BindingFlags.Public |BindingFlags.GetProperty , null, c, new object [] {index});
 Console.WriteLine ("Item[{0}] == {1}", index, result);
         
 //Get a field or property
 result = t.InvokeMember ("Name", BindingFlags.Public |BindingFlags.GetField | BindingFlags.GetProperty, null, c, new object [] {});
 Console.WriteLine ("Name == {0}", result);
 result = t.InvokeMember ("Value", BindingFlags.Public |BindingFlags.GetField | BindingFlags.GetProperty, null, c, new object [] {});
 Console.WriteLine ("Value == {0}", result);
         
 //Call a method using named arguments
 object[] argValues = new object [] {"Mouse", "Micky"};
 String [] argNames = new String [] {"lastName", "firstName"};
 t.InvokeMember ("PrintName", BindingFlags.Public |BindingFlags.InvokeMethod, null, null, argValues, null, null, argNames);
         
 //Call the default member of a type
 Type t3 = typeof (TestClass2);
 t3.InvokeMember ("", BindingFlags.Public |BindingFlags.InvokeMethod, null, new TestClass2(), new object [] {});
         
 //Invoking a ByRef member
 MethodInfo m = t.GetMethod("Swap");
 args = new object[2];
 args[0] = 1;
 args[1] = 2;
 m.Invoke(new TestClass(),args);
 Console.WriteLine ("{0}, {1}", args[0], args[1]);
 Console.WriteLine ("\r\nPress Return to exit.");
 Console.Read();

 }
}

// Class added so sample will compile
public class TestClass {}

// Class added so sample will compile
public class TestClass2 {}

    </pre>
</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a> for reflecting members that are not public. Associated enumeration:  <a href="../../System.Security.Permissions/types/ReflectionPermissionFlag.html#MemberAccess">ReflectionPermissionFlag.MemberAccess</a></dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/SecurityPermission.html">SecurityPermission</a> to call unmanaged code. Associated enumeration:  <a href="../../System.Security.Permissions/types/SecurityPermissionFlag.html#UnmanagedCode">SecurityPermissionFlag.UnmanagedCode</a></dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/String.html">String</a> |  <a href="../../System.Reflection/types/Binder.html">Binder</a> |  <a href="#DefaultBinder">Type.DefaultBinder</a> |  <a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> |  <a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier</a> |  <a href="../../System.Reflection/types/ParameterAttributes.html">ParameterAttributes</a> |  <a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> |  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="InvokeMemberTopic3"></a><a name="InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">InvokeMember</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>invokeAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>target</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object[]</a> <i>args</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i>,</font><br>   <font color="#008080"><a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> <i>culture</i>,</font><br>   <font color="#008080"><a href="../../System/types/String.html">string[]</a> <i>namedParameters</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Invokes the specified member. The method that is to be invoked must be accessible and provide the most specific match with the specified argument list, under the contraints of the specified binder and invocation attributes.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Object.html">object</a> InvokeMember(<br>   <font color="#008080"><a href="../../System/types/String.html">string</a> <i>name</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/BindingFlags.html">BindingFlags</a> <i>invokeAttr</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/Binder.html">Binder</a> <i>binder</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>target</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object[]</a> <i>args</i>,</font><br>   <font color="#008080"><a href="../../System.Reflection/types/ParameterModifier.html">ParameterModifier[]</a> <i>modifiers</i>,</font><br>   <font color="#008080"><a href="../../System.Globalization/types/CultureInfo.html">CultureInfo</a> <i>culture</i>,</font><br>   <font color="#008080"><a href="../../System/types/String.html">string[]</a> <i>namedParameters</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>name</i><br><dl>
<dd>
<param> The name of the member to invoke. This can be a constructor, method, property, or field. A suitable invocation attribute must be specified. Note that it is possible to invoke the default member of a class by passing an empty string as the name of the member.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>invokeAttr</i><br><dl>
<dd>
<param> The invocation attribute. This must be a bit flag from <b>BindingFlags</b>.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binder</i><br><dl>
<dd>
<param> An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <b>MemberInfo</b> objects using reflection. If binder is <b>null</b>, the default binder is used. See  <a href="../../System.Reflection/types/Binder.html">Binder</a>.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>target</i><br><dl>
<dd>
<param> The object on which to invoke the specified member. If the member is static, this parameter is ignored.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>args</i><br><dl>
<dd>
<param> An argument list. This is an array of objects that contains the number, order, and type of the parameters of the member to be invoked. If there are no parameters this should be null.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>modifiers</i><br><dl>
<dd>
<param> An array of the same length as <i>args</i> with elements that represent the attributes associated with the arguments of the member to be invoked. A parameter has attributes associated with it in the metadata. They are used by various interoperability services. See the metadata specs for details such as this.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>culture</i><br><dl>
<dd>
<param> An instance of <b>CultureInfo</b> used to govern the coercion of types. If this is null, the <b>CultureInfo</b> for the current thread is used. (Note that this is necessary to, for example, convert a string that represents 1000 to a double value, since 1000 is represented differently by different cultures.) 
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>namedParameters</i><br><dl>
<dd>
<param> Each parameter in the <i>namedParameters</i> array gets the value in the corresponding element in the <i>args</i> array. If the length of <i>args</i> is greater than the length of <i>namedParameters</i>, the remaining argument values are passed in order.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> Returns the return value of the invoked member.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not currently supported in types that are not complete.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/IReflect.html#InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">IReflect.InvokeMember</a></dd>
</dl><b>Remarks</b><dl>
<dd> You can retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> or  <a href="../../System.Reflection/types/Assembly.html#GetType(System.String)">Assembly.GetType</a> and use reflection on the retrieved type.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="IsArrayImplTopic1"></a><a name="IsArrayImpl">IsArrayImpl</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns <b>false</b>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected override <a href="../../System/types/Boolean.html">bool</a> IsArrayImpl();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>false</b></dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="IsAssignableFromTopic1"></a><a name="IsAssignableFrom(System.Type)">IsAssignableFrom</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>c</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsAssignableFrom(System.Type)">System.Type.IsAssignableFrom</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Determines whether an instance of the current  <a href="../../System/types/Type.html">Type</a> can be assigned from an instance of the specified <b>Type</b>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/Boolean.html">bool</a> IsAssignableFrom(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>c</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>c</i><br><dl>
<dd>
<param> The <b>Type</b> to compare with the current <b>Type</b>.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the <i>c</i> parameter and the current <b>Type</b> represent the same type, or if the current <b>Type</b> is in the inheritance hierarchy of <i>c</i>, or if the current <b>Type</b> is an interface that <i>c</i> supports.<b>false</b> if none of these conditions are the case, or if <i>c</i> is <b>null</b>.</dd>
</dl><b>Remarks</b><dl>
<dd> This method can be overridden by a derived class.<p> Determine the element types of a <b>Type</b> using  <a href="#GetElementType">Type.GetElementType</a>.</p>
</dd>
</dl><b>Example</b><dl>
<dd> The following example demonstrates the <b>IsAssignable</b> method using arrays.<pre>
using System;
class ArrayTypeTest 
{
   public static void Main() 
   {
   int i = 1;
   int [] array10  = new int [10];
   int [] array2   = new int[2];
   int [,]array22  = new int[2,2];
   int [,]array24  = new int[2,4];
   int [,,]array333 = new int[3,3,3];
   Type array10Type = array10.GetType();
   Type array2Type  = array2.GetType();
   Type array22Type = array22.GetType();
   Type array24Type = array24.GetType();
   Type array333Type = array333.GetType();

   // If X and Y are not both arrays, then return false.
   Console.WriteLine("int[2]  is assignable from int? {0} ", array2Type.IsAssignableFrom(i.GetType()));
   // If X and Y have same type and rank, then return true.
   Console.WriteLine("int[2]  is assignable from int[10]? {0} ", array2Type.IsAssignableFrom(array10Type));
   Console.WriteLine("int[2,2] is assignable from int[2,4]? {0}", array22Type.IsAssignableFrom(array24Type));
   Console.WriteLine("int[2,4] is assignable from int[2,2]? {0}", array24Type.IsAssignableFrom(array22Type));
   Console.WriteLine("");
   // If X and Y do not have the same rank, then return false.
   Console.WriteLine("int[2,2] is assignable from int[10]? {0}", array22Type.IsAssignableFrom(array10Type));
   Console.WriteLine("int[2,2]   is assignable from int[3,3,3]? {0}", array22Type.IsAssignableFrom(array333Type));
   Console.WriteLine("int[3,3,3] is assignable from int[2,2]? {0}", array333Type.IsAssignableFrom(array22Type));
   }
}

    </pre>
<p> This code produces the following output: </p>
<pre>
              				int[2] is assignable from int? False
              				int[2] is assignable from int[10]? True
              				int[2,2] is assignable from int[2,4]? True
              				int[2,4] is assignable from int[2,2]? True
              				int[2,2] is assignable from int[10]? False
              				int[2,2] is assignable from int[3,3,3]? False
              				int[3,3,3] is assignable from int[2,2]? False
              			
            </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="IsByRefImplTopic1"></a><a name="IsByRefImpl">IsByRefImpl</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns <b>false</b>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected override <a href="../../System/types/Boolean.html">bool</a> IsByRefImpl();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b></dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="IsCOMObjectImplTopic1"></a><a name="IsCOMObjectImpl">IsCOMObjectImpl</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns <b>false</b>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected override <a href="../../System/types/Boolean.html">bool</a> IsCOMObjectImpl();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>false</b></dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="IsContextfulImplTopic1"></a><a name="IsContextfulImpl">IsContextfulImpl</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsContextfulImpl">System.Type.IsContextfulImpl</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Implements the  <a href="#IsContextful">Type.IsContextful</a> property and determines whether the  <a href="../../System/types/Type.html">Type</a> can be hosted in a context.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected virtual <a href="../../System/types/Boolean.html">bool</a> IsContextfulImpl();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the  <a href="../../System/types/Type.html">Type</a> can be hosted in a context; otherwise, <b>false</b>.</dd>
</dl><b>Remarks</b><dl>
<dd> This method can be overridden by a derived class.<p> A context intercepts calls to the class members and enforce policies that are applied to the class, such as synchronization.</p>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
public class MyTypeDelegatorClass : TypeDelegator
{
   public string myElementType = null;
   private Type myType = null ; 

   public MyTypeDelegatorClass(Type myType) : base(myType)
   {
      this.myType = myType;
   }

   // Override 'IsContextfulImpl' method of 'Type' class.
   protected override bool IsContextfulImpl()
   {
      // Check whether the type is contextful.
      if(myType.IsContextful)
      { 
         myElementType = " is contextful ";
         return true;
      }
      return false;
   }
}

public class MyTypeDemoClass
{
   public static void Main()
   {
      try
      {
         MyTypeDelegatorClass myType;
         Console.WriteLine ("Check whether 'MyContextBoundClass' can be hosted in a context.");
         // Check if 'MyContextBoundClass' type is contextful.
         myType = new MyTypeDelegatorClass(typeof(MyContextBoundClass));
         if( myType.IsContextful)
         {
            Console.WriteLine(typeof(MyContextBoundClass) + " can be hosted in a context.");
         }
         else
         {
            Console.WriteLine(typeof(MyContextBoundClass) + " cannot be hosted in a context.");
         }

         // Check if 'int' type is contextful.
         myType = new MyTypeDelegatorClass(typeof(MyTypeDemoClass));
         Console.WriteLine ("\nCheck whether 'MyTypeDemoClass' can be hosted in a context.");
         if( myType.IsContextful)
         {
            Console.WriteLine(typeof(MyTypeDemoClass) + " can be hosted in a context.");
         }
         else
         {
            Console.WriteLine(typeof(MyTypeDemoClass) + " cannot be hosted in a context.");
         }
      }
      catch( Exception e )
      {
         Console.WriteLine("Exception: {0}", e.Message);
      }
   }
}

// This class is used to demonstrate 'IsContextfulImpl' method.
public class MyContextBoundClass : ContextBoundObject
{
   public string myString = "This class is used to demonstrate members of the 'Type' class.";
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#IsContextful">Type.IsContextful</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="IsDefinedTopic1"></a><a name="IsDefined(System.Type,System.Boolean)">IsDefined</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>attributeType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>inherit</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Checks if the specified custom attribute type is defined.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/Boolean.html">bool</a> IsDefined(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>attributeType</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>inherit</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>attributeType</i><br><dl>
<dd>
<param> The <b>Type</b> object to which the custom attributes are applied.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>inherit</i><br><dl>
<dd>
<param> Specifies whether to search this member's inheritance chain to find the attributes.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if one or more instance of <i>attributeType</i> is defined on this member; otherwise, <b>false</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> This method is not currently supported in types that are not complete.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Implements: </b></dt>
<dd> <a href="../../System.Reflection/types/ICustomAttributeProvider.html#IsDefined(System.Type,System.Boolean)">ICustomAttributeProvider.IsDefined</a></dd>
</dl><b>Remarks</b><dl>
<dd> As a workaround, to check if a custom attribute is defined for a finished type, retrieve the type using  <a href="../../System/types/Type.html#GetType(System.String,System.Boolean,System.Boolean)">Type.GetType</a> and call  <a href="../../System.Reflection/types/MemberInfo.html#GetCustomAttributes(System.Boolean)">MemberInfo.GetCustomAttributes</a> on the returned  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="IsInstanceOfTypeTopic1"></a><a name="IsInstanceOfType(System.Object)">IsInstanceOfType</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>o</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsInstanceOfType(System.Object)">System.Type.IsInstanceOfType</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Determines whether the specified object is an instance of the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/Boolean.html">bool</a> IsInstanceOfType(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>o</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>o</i><br><dl>
<dd>
<param> The object to compare with the current <b>Type</b>.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the current <b>Type</b> is in the inheritance hierarchy of the object represented by the <i>o</i> parameter, or if the current Type is an interface that <i>o</i> supports.<b>false</b> if neither of these conditions is the case, or if <i>o</i> is <b>null</b>.</dd>
</dl><b>Remarks</b><dl>
<dd> This method can be overridden by a derived class.</dd>
</dl><b>Example</b><dl>
<dd> The following example demonstrates the use of the <b>IsInstanceOfType</b> method.<pre>
using System;
public interface IMyIfc {}
public class MyClass : IMyIfc {}
public class MyDerivedClass : MyClass {}
class IsInstanceTest 
{
   public static void Main() 
   {
   Type imyifcType=typeof(IMyIfc);
   MyClass mc = new MyClass();
   Type mcType = mc.GetType();
   MyClass mdc = new MyDerivedClass();
   Type mdcType = mdc.GetType();
   int [] array  = new int [10];
   Type arrayType = typeof(Array);
   Console.WriteLine("int[] is instance of Array? {0}", arrayType.IsInstanceOfType(array));
   Console.WriteLine("myclass instance is instance of MyClass? {0}", mcType.IsInstanceOfType(mc));
   Console.WriteLine("myderivedclass instance is instance of MyClass? {0}", mcType.IsInstanceOfType(mdc));
   Console.WriteLine("myclass instance is instance of IMyIfc? {0}", imyifcType.IsInstanceOfType(mc));
   Console.WriteLine("myderivedclass instance is instance of IMyIfc? {0}", imyifcType.IsInstanceOfType(mdc));
   }
}

    </pre>
<p> This code produces the following output: </p>
<pre>
              				int[] is instance of Array? True 
              				myclass instance is instance of MyClass? True 
              				myderivedclass instance is instance of MyClass? True 
              				myclass instance is instance of IMyIfc? True 
              				myderivedclass instance is instance of IMyIfc? True
              			
            </pre>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="IsMarshalByRefImplTopic1"></a><a name="IsMarshalByRefImpl">IsMarshalByRefImpl</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsMarshalByRefImpl">System.Type.IsMarshalByRefImpl</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Implements the  <a href="#IsMarshalByRef">Type.IsMarshalByRef</a> property and determines whether the  <a href="../../System/types/Type.html">Type</a> is marshalled by reference.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected virtual <a href="../../System/types/Boolean.html">bool</a> IsMarshalByRefImpl();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the  <a href="../../System/types/Type.html">Type</a> is marshalled by reference; otherwise, <b>false</b>.</dd>
</dl><b>Remarks</b><dl>
<dd> This method can be overridden by a derived class.</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
public class MyTypeDelegatorClass : TypeDelegator
{
   public string myElementType = null;
   private Type myType = null ; 

   public MyTypeDelegatorClass(Type myType) : base(myType)
   {
      this.myType = myType;
   }

   // Override 'IsMarshalByRefImpl' method of 'Type' class.
   protected override bool IsMarshalByRefImpl()
   {
      // Check whether the type is marshalled by reference.
      if(myType.IsMarshalByRef)
      { 
         myElementType = " marshalled by reference";
         return true;
      }
      return false;
   }
}

public class MyTypeDemoClass
{
   public static void Main()
   {
      try
      {
         MyTypeDelegatorClass myType;
         Console.WriteLine ("Check whether 'MyContextBoundClass' is marshalled by reference");
         // Check if 'MyContextBoundClass' type is marshalled by reference.
         myType = new MyTypeDelegatorClass(typeof(MyContextBoundClass));
         if( myType.IsMarshalByRef )
         {
            Console.WriteLine(typeof(MyContextBoundClass) + " is marshalled by reference.");
         }
         else
         {
            Console.WriteLine(typeof(MyContextBoundClass) + " is not marshalled by reference.");
         }

         // Check if 'int' type is marshalled by reference.
         myType = new MyTypeDelegatorClass(typeof(int));
         Console.WriteLine ("\nCheck whether 'int' is marshalled by reference");
         if( myType.IsMarshalByRef)
         {
            Console.WriteLine(typeof(int) + " is marshalled by reference.");
         }
         else
         {
            Console.WriteLine(typeof(int) + " is not marshalled by reference.");
         }
      }
      catch( Exception e )
      {
         Console.WriteLine("Exception: {0}", e.Message);
      }
   }
}
// This class is used to demonstrate 'IsMarshalByRefImpl' method.
public class MyContextBoundClass : ContextBoundObject
{
   public string myString = "This class is used demonstrate members of the 'Type' class.";
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#IsMarshalByRef">Type.IsMarshalByRef</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="IsPointerImplTopic1"></a><a name="IsPointerImpl">IsPointerImpl</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns <b>false</b>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected override <a href="../../System/types/Boolean.html">bool</a> IsPointerImpl();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b></dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="IsPrimitiveImplTopic1"></a><a name="IsPrimitiveImpl">IsPrimitiveImpl</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns <b>false</b>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected override <a href="../../System/types/Boolean.html">bool</a> IsPrimitiveImpl();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>false</b></dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="IsSubclassOfTopic1"></a><a name="IsSubclassOf(System.Type)">IsSubclassOf</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>c</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#IsSubclassOf(System.Type)">System.Type.IsSubclassOf</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Determines whether the current  <a href="../../System/types/Type.html">Type</a> derives from the specified <b>Type</b>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/Boolean.html">bool</a> IsSubclassOf(<br>   <font color="#008080"><a href="../../System/types/Type.html">Type</a> <i>c</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>c</i><br><dl>
<dd>
<param> The <b>Type</b> to compare with the current <b>Type</b>.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the <b>Type</b> represented by the <i>c</i> parameter and the current <b>Type</b> represent classes, and the class represented by the current <b>Type</b> derives from the class represented by <i>c</i>; otherwise, <b>false</b>. This method also returns <b>false</b> if <i>c</i> and the current <b>Type</b> represent the same class.</dd>
</dl><b>Remarks</b><dl>
<dd> This method can be overridden by a derived class.</dd>
</dl><b>Example</b><dl>
<dd> The following example demonstrates the use of the <b>IsSubclassOf</b> method.<pre>
using System;
public interface IMyIfc {}
public interface IDerived : IMyIfc {}
public class Class1 : IMyIfc {}
public class MyDerivedClass : Class1 {}
class IsSubclassTest 
{
   public static void Main() 
   {
   Type imyifcType = typeof(IMyIfc);
   Type imyderivedType = typeof(IDerived);
   Class1 mc = new Class1();
   Type mcType = mc.GetType();
   Class1 mdc = new MyDerivedClass();
   Type mdcType = mdc.GetType();
   int [] array  = new int [10];
   Type arrayOfIntsType = array.GetType();
   Type arrayType = typeof(Array);
	
   Console.WriteLine("Array is derived class of int[]? {0}", arrayType.IsSubclassOf(arrayOfIntsType));
   Console.WriteLine("int [] is derived class of Array? {0}", arrayOfIntsType.IsSubclassOf(arrayType));
   Console.WriteLine("IMyIfc is derived class of IDerived? {0}", imyifcType.IsSubclassOf(imyderivedType));
   Console.WriteLine("myclass is derived class of Class1? {0}", mcType.IsSubclassOf(mcType));
   Console.WriteLine("myderivedclass is derived class of Class1? {0}", mdcType.IsSubclassOf(mcType));
   }
}

    </pre>
<p> This code produces the following output: </p>
<pre>
              				Array is derived class of int[]? False 
              				int [] is derived class of Array? True 
              				IMyIfc is derived class of IDerived? False 
              				myclass is derived class of Class1? False 
              				myderivedclass is derived class of Class1? True
              			
            </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="#BaseType">Type.BaseType</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overridden Method: <i><a name="IsValueTypeImplTopic1"></a><a name="IsValueTypeImpl">IsValueTypeImpl</a></i></b><b><i>()</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Returns <b>true</b>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected override <a href="../../System/types/Boolean.html">bool</a> IsValueTypeImpl();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b></dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="MemberwiseCloneTopic1"></a><a name="MemberwiseClone">MemberwiseClone</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#MemberwiseClone">System.Object.MemberwiseClone</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected <a href="../../System/types/Object.html">object</a> MemberwiseClone();</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="SetCustomAttributeTopic1"></a><a name="SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">SetCustomAttribute</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection.Emit/types/CustomAttributeBuilder.html">CustomAttributeBuilder</a> <i>customBuilder</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Sets a custom attribute using a custom attribute builder.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public void SetCustomAttribute(<br>   <font color="#008080"><a href="../../System.Reflection.Emit/types/CustomAttributeBuilder.html">CustomAttributeBuilder</a> <i>customBuilder</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>customBuilder</i><br><dl>
<dd>
<param> An instance of a helper class to define the custom attribute.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>con</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="SetCustomAttributeTopic2"></a><a name="SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">SetCustomAttribute</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> <i>con</i>,</font><br>   <font color="#008080"><a href="../../System/types/Byte.html">byte[]</a> <i>binaryAttribute</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Sets a custom attribute using a specified custom attribute blob.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public void SetCustomAttribute(<br>   <font color="#008080"><a href="../../System.Reflection/types/ConstructorInfo.html">ConstructorInfo</a> <i>con</i>,</font><br>   <font color="#008080"><a href="../../System/types/Byte.html">byte[]</a> <i>binaryAttribute</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>con</i><br><dl>
<dd>
<param> The constructor for the custom attribute.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>binaryAttribute</i><br><dl>
<dd>
<param> A byte blob representing the attributes.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentNullException.html">ArgumentNullException</a></td>
<td><i>con</i> or <i>binaryAttribute</i> is <b>null</b>.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> See the metadata specification for details on how to format <i>binaryAttribute</i>.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="ToStringTopic1"></a><a name="ToString">ToString</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Type.html#ToString">System.Type.ToString</a></font></b></dd>
</dl><br><dl>
<dt><b>Summary</b></dt>
<dd> Returns a <b>String</b> representing the name of the current <b>Type</b>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public override <a href="../../System/types/String.html">string</a> ToString();</b></code></td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> A  <a href="../../System/types/String.html">String</a> representing the name of the current  <a href="../../System/types/Type.html">Type</a>.</dd>
</dl><b>Remarks</b><dl>
<dd> This method returns the fully qualified common language runtime namespace and name for all primitive types. For example, the C# instruction, <code>
                (long)0.Type().ToString()
              </code> returns "System.Int64" instead of merely "Int64".</dd>
</dl><b>Example</b><dl>
<dd>
<pre>

namespace MyNamespace
{
   class MyClass
   {
   }
}
public class Type_ToString_3
{
   public static void Main()
   {
      
      try
      {
         Type myType = typeof(MyNamespace.MyClass);
         
         Console.WriteLine("\nPrinting the details of '{0}'\n", myType); 
         // Get the namespace of the class 'Type_ToString_3'.
         Console.WriteLine("Namespace : {0}", myType.Namespace);
         
         // Get the name of the module.
         Console.WriteLine("Module    : {0} ",myType.Module);
         
         // Get fully qualified common language runtime namespace.
         Console.WriteLine("Fully Qualified type : {0}", myType.ToString());
      }
      catch(Exception e)
      {
         Console.WriteLine("Exception : " + e.Message ); 
      }
   }
}

    </pre>
</dd>
</dl><b>See also: 
			</b><br> <a href="../../System/types/String.html">String</a><h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite">
<h3 align="center"><a href="#TopOfPage">
					Top of page
				</a></h3><i><a href="../../documentation_license.txt">
				  Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
				</a></i></body>
</html>
