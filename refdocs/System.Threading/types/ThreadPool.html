<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../refdoc.css">
<title>Type: System.Threading.ThreadPool</title>
</head>
<body><a name="TopOfPage"></a><h2>System.Threading.ThreadPool Class</h2><b>Assembly: </b>Mscorlib.dll<br><b>Namespace: </b>System.Threading<br><dl>
<dt><b>Summary</b></dt>
<dd> Provides a pool of threads that can be used to post work items, process asynchronous I/O, wait on behalf of other threads, and process timers.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
        public sealed class ThreadPool
      </b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> Many applications create threads that spend a great deal of time in the sleeping state, waiting for an event to occur. Other threads may enter a sleeping state only to be awakened periodically to poll for a change or update status information. Thread pooling enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system. One thread monitors the status of several wait operations queued to the thread pool. When a wait operation completes, a worker thread from the thread pool executes the corresponding callback function.<p> You can also queue work items that are not related to a wait operation to the thread pool. To request that a work item be handled by a thread in the thread pool, call the  <a href="#QueueUserWorkItem(System.Threading.WaitCallback,System.Object)">ThreadPool.QueueUserWorkItem</a> method. This method takes as a parameter a reference to the method or delegate that will be called by the thread selected from the thread pool. There is no way to cancel a work item after it has been queued.</p>
<p> Timer-queue timers and registered wait operations also use the thread pool. Their callback functions are queued to the thread pool.</p>
<p> The thread pool is created the first time you create an instance of the <b>ThreadPool</b> class. The thread pool has a default limit of 25 threads per available processor, which could be changed using <b>CorSetMaxThreads</b> as defined in the mscoree.h file. Each thread uses the default stack size and runs at the default priority. Each process can have only one operating system thread pool.</p>
</dd>
</dl><b>See also: </b><dl>
<dd> <a href="../../System.Threading/System.Threading.html">System.Threading Namespace</a></dd>
</dl>
<h3>System.Threading.ThreadPool Member List: </h3>
<dl>
<dt><b>Public Methods</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#Equals(System.Object)">Equals</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#Equals(System.Object)">System.Object.Equals</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetAvailableThreads(System.Int32,System.Int32)">GetAvailableThreads</a></td>
<td width="55%"> Retrieves the number of thread pool requests or work items that the user can add before reaching the maximum limit defined in  <a href="#GetMaxThreads(System.Int32@,System.Int32@)">ThreadPool.GetMaxThreads</a>.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetHashCode">GetHashCode</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#GetHashCode">System.Object.GetHashCode</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetMaxThreads(System.Int32,System.Int32)">GetMaxThreads</a></td>
<td width="55%"> Retrieves the number of requests to the thread pool that can queue concurrently. All requests above that number are blocked until some of the queued requests finish work.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#GetType">GetType</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#GetType">System.Object.GetType</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#QueueUserWorkItem(System.Threading.WaitCallback)">QueueUserWorkItem</a></td>
<td width="55%"><b>Overloaded:</b><br><code>QueueUserWorkItem(WaitCallback callBack)<br><br></code> Queues a user work item to the thread pool and invokes the specified delegate.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#QueueUserWorkItem(System.Threading.WaitCallback,System.Object)">QueueUserWorkItem</a></td>
<td width="55%"><b>Overloaded:</b><br><code>QueueUserWorkItem(WaitCallback callBack, object state)<br><br></code> Queues a user work item to the thread pool, invokes the specified delegate, and specifies an object to be passed to the delegate when serviced from the thread pool.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)">RegisterWaitForSingleObject</a></td>
<td width="55%"><b>Overloaded:</b><br><code>RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce)<br><br></code> Registers a delegate that is waiting for a  <a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a>, using a 32-bit signed integer for the time out in milliseconds.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)">RegisterWaitForSingleObject</a></td>
<td width="55%"><b>Overloaded:</b><br><code>RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce)<br><br></code> Registers a delegate that is waiting for a  <a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a>, using a 32-bit unsigned integer for the time out in milliseconds.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)">RegisterWaitForSingleObject</a></td>
<td width="55%"><b>Overloaded:</b><br><code>RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce)<br><br></code> Registers a delegate that is waiting for a  <a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a>, using a  <a href="../../System/types/TimeSpan.html">TimeSpan</a> value for the time out.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)">RegisterWaitForSingleObject</a></td>
<td width="55%"><b>Overloaded:</b><br><code>RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce)<br><br></code> Registers a delegate that is waiting for a  <a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a>, using a 32-bit unsigned integer for the time out in milliseconds.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#ToString">ToString</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#ToString">System.Object.ToString</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)">UnsafeQueueUserWorkItem</a></td>
<td width="55%"> Queues a user work item to the thread pool.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)">UnsafeRegisterWaitForSingleObject</a></td>
<td width="55%"><b>Overloaded:</b><br><code>UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce)<br><br></code> Queues the specified delegate to the thread pool.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)">UnsafeRegisterWaitForSingleObject</a></td>
<td width="55%"><b>Overloaded:</b><br><code>UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce)<br><br></code> Queues the specified delegate to the thread pool.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)">UnsafeRegisterWaitForSingleObject</a></td>
<td width="55%"><b>Overloaded:</b><br><code>UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce)<br><br></code> Queues the specified delegate to the thread pool.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)">UnsafeRegisterWaitForSingleObject</a></td>
<td width="55%"><b>Overloaded:</b><br><code>UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce)<br><br></code> Queues the specified delegate to the thread pool.</td>
</tr>
</table>
</dd>
</dl>
<dl>
<dt><b>Protected Methods</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><a href="#Finalize">Finalize</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#Finalize">System.Object.Finalize</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
<tr valign="top">
<td width="35%"><a href="#MemberwiseClone">MemberwiseClone</a><br>(inherited from <b>System.Object)</b></td>
<td width="55%"><b><font color="#800080">See base class member description: <a href="../../System/types/Object.html#MemberwiseClone">System.Object.MemberwiseClone</a></font></b><br><br>Derived from System.Object, the primary base class for all objects.</td>
</tr>
</table>
</dd>
</dl>
<p><b>Hierarchy:</b><ul class="none">
<li><a href="../../System/types/Object.html">System.Object</a></li>
<ul class="none">
<li><b>System.Threading.ThreadPool</b></li>
</ul>
</ul>
</p>
<hr>
<h3>System.Threading.ThreadPool Member Details</h3><b>Method: <i><a name="EqualsTopic1"></a><a name="Equals(System.Object)">Equals</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>obj</i></font><br>)</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#Equals(System.Object)">System.Object.Equals</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/Boolean.html">bool</a> Equals(<br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>obj</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="FinalizeTopic1"></a><a name="Finalize">Finalize</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#Finalize">System.Object.Finalize</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            ~ThreadPool();</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetAvailableThreadsTopic1"></a><a name="GetAvailableThreads(System.Int32,System.Int32)">GetAvailableThreads</a></i></b><b><i>(<br>   <font color="#008080"><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfmemberstopic.asp">out</a> <i>int workerThreads</i>,</font><br>   <font color="#008080"><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfmemberstopic.asp">out</a> <i>int completionPortThreads</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Retrieves the number of thread pool requests or work items that the user can add before reaching the maximum limit defined in  <a href="#GetMaxThreads(System.Int32@,System.Int32@)">ThreadPool.GetMaxThreads</a>.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public static void GetAvailableThreads(<br>   <font color="#008080"><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfmemberstopic.asp">out</a> <i>int workerThreads</i>,</font><br>   <font color="#008080"><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfmemberstopic.asp">out</a> <i>int completionPortThreads</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>workerThreads</i><br><dl>
<dd>
<param> The number of worker threads.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>completionPortThreads</i><br><dl>
<dd>
<param> The number of asynchronous I/O threads.
</dd>
</dl>
</p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetHashCodeTopic1"></a><a name="GetHashCode">GetHashCode</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#GetHashCode">System.Object.GetHashCode</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual <a href="../../System/types/Int32.html">int</a> GetHashCode();</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetMaxThreadsTopic1"></a><a name="GetMaxThreads(System.Int32,System.Int32)">GetMaxThreads</a></i></b><b><i>(<br>   <font color="#008080"><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfmemberstopic.asp">out</a> <i>int workerThreads</i>,</font><br>   <font color="#008080"><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfmemberstopic.asp">out</a> <i>int completionPortThreads</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Retrieves the number of requests to the thread pool that can queue concurrently. All requests above that number are blocked until some of the queued requests finish work.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public static void GetMaxThreads(<br>   <font color="#008080"><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfmemberstopic.asp">out</a> <i>int workerThreads</i>,</font><br>   <font color="#008080"><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfmemberstopic.asp">out</a> <i>int completionPortThreads</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>workerThreads</i><br><dl>
<dd>
<param> The number of worker threads.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>completionPortThreads</i><br><dl>
<dd>
<param> The number of asynchronous I/O threads.
</dd>
</dl>
</p>
</dd>
</dl><b>Remarks</b><dl>
<dd> When a call to GetMaxThreads completes the <i>workerThreads</i> contains the maximum number of worker threads and the <i>completionPortThreads</i> parameter contains the maximum number of asynchronous I/O threads.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="GetTypeTopic1"></a><a name="GetType">GetType</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#GetType">System.Object.GetType</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public <a href="../../System/types/Type.html">Type</a> GetType();</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="MemberwiseCloneTopic1"></a><a name="MemberwiseClone">MemberwiseClone</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#MemberwiseClone">System.Object.MemberwiseClone</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            protected <a href="../../System/types/Object.html">object</a> MemberwiseClone();</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="QueueUserWorkItemTopic1"></a><a name="QueueUserWorkItem(System.Threading.WaitCallback)">QueueUserWorkItem</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Threading/types/WaitCallback.html">WaitCallback</a> <i>callBack</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Queues a user work item to the thread pool and invokes the specified delegate.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public static <a href="../../System/types/Boolean.html">bool</a> QueueUserWorkItem(<br>   <font color="#008080"><a href="../../System.Threading/types/WaitCallback.html">WaitCallback</a> <i>callBack</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>callBack</i><br><dl>
<dd>
<param> A <b>WaitCallback</b> representing the delegate to invoke when the thread in the thread pool picks up the work item.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the method succeeds; otherwise, <b>false</b>.</dd>
</dl><b>Remarks</b><dl>
<dd> State data can be stored in the instance fields of the class on which the delegate is defined. The callback function is queued to a worker thread.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="QueueUserWorkItemTopic2"></a><a name="QueueUserWorkItem(System.Threading.WaitCallback,System.Object)">QueueUserWorkItem</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Threading/types/WaitCallback.html">WaitCallback</a> <i>callBack</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>state</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Queues a user work item to the thread pool, invokes the specified delegate, and specifies an object to be passed to the delegate when serviced from the thread pool.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public static <a href="../../System/types/Boolean.html">bool</a> QueueUserWorkItem(<br>   <font color="#008080"><a href="../../System.Threading/types/WaitCallback.html">WaitCallback</a> <i>callBack</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>state</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>callBack</i><br><dl>
<dd>
<param> A  <a href="../../System.Threading/types/WaitCallback.html">WaitCallback</a> representing the delegate to invoke when a thread in the thread pool picks up the work item.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>state</i><br><dl>
<dd>
<param> The object that is passed to the delegate when serviced from the thread pool.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the method succeeds; otherwise, <b>false</b>.</dd>
</dl><b>Remarks</b><dl>
<dd> State data can be stored in the instance fields of the class on which the delegate is defined. The callback function is queued to a worker thread.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="RegisterWaitForSingleObjectTopic1"></a><a name="RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)">RegisterWaitForSingleObject</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a> <i>waitObject</i>,</font><br>   <font color="#008080"><a href="../../System.Threading/types/WaitOrTimerCallback.html">WaitOrTimerCallback</a> <i>callBack</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>state</i>,</font><br>   <font color="#008080"><a href="../../System/types/Int32.html">int</a> <i>millisecondsTimeOutInterval</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>executeOnlyOnce</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Registers a delegate that is waiting for a  <a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a>, using a 32-bit signed integer for the time out in milliseconds.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public static <a href="../../System.Threading/types/RegisteredWaitHandle.html">RegisteredWaitHandle</a> RegisterWaitForSingleObject(<br>   <font color="#008080"><a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a> <i>waitObject</i>,</font><br>   <font color="#008080"><a href="../../System.Threading/types/WaitOrTimerCallback.html">WaitOrTimerCallback</a> <i>callBack</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>state</i>,</font><br>   <font color="#008080"><a href="../../System/types/Int32.html">int</a> <i>millisecondsTimeOutInterval</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>executeOnlyOnce</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>waitObject</i><br><dl>
<dd>
<param> The  <a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a> to register.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>callBack</i><br><dl>
<dd>
<param> The  <a href="../../System.Threading/types/WaitOrTimerCallback.html">WaitOrTimerCallback</a> delegate to call when the <i>waitObject</i> parameter is signaled.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>state</i><br><dl>
<dd>
<param> The object passed to the delegate.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>millisecondsTimeOutInterval</i><br><dl>
<dd>
<param> The time out in milliseconds. If the <i>millisecondsTimeOutInterval</i> parameter is zero (0), the function tests the object's state and returns immediately. If <i>millisecondsTimeOutInterval</i> is -1, the function's time-out interval never elapses.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>executeOnlyOnce</i><br><dl>
<dd>
<param><b>true</b> to indicate the thread will no longer wait on the <i>waitObject</i> parameter after the delegate has been called; <b>false</b> to indicate the timer is reset every time the wait operation completes until the wait is unregistered.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The  <a href="../../System.Threading/types/RegisteredWaitHandle.html">RegisteredWaitHandle</a> that encapsulates the native handle.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentOutOfRangeException.html">ArgumentOutOfRangeException</a></td>
<td> The <i>millisecondsTimeOutInterval</i> parameter is less than -1.</td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="RegisterWaitForSingleObjectTopic2"></a><a name="RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)">RegisterWaitForSingleObject</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a> <i>waitObject</i>,</font><br>   <font color="#008080"><a href="../../System.Threading/types/WaitOrTimerCallback.html">WaitOrTimerCallback</a> <i>callBack</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>state</i>,</font><br>   <font color="#008080"><a href="../../System/types/Int64.html">long</a> <i>millisecondsTimeOutInterval</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>executeOnlyOnce</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Registers a delegate that is waiting for a  <a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a>, using a 32-bit unsigned integer for the time out in milliseconds.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public static <a href="../../System.Threading/types/RegisteredWaitHandle.html">RegisteredWaitHandle</a> RegisterWaitForSingleObject(<br>   <font color="#008080"><a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a> <i>waitObject</i>,</font><br>   <font color="#008080"><a href="../../System.Threading/types/WaitOrTimerCallback.html">WaitOrTimerCallback</a> <i>callBack</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>state</i>,</font><br>   <font color="#008080"><a href="../../System/types/Int64.html">long</a> <i>millisecondsTimeOutInterval</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>executeOnlyOnce</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>waitObject</i><br><dl>
<dd>
<param> The  <a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a> to register.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>callBack</i><br><dl>
<dd>
<param> The  <a href="../../System.Threading/types/WaitOrTimerCallback.html">WaitOrTimerCallback</a> delegate to call when the <i>waitObject</i> parameter is signaled.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>state</i><br><dl>
<dd>
<param> The object passed to the delegate.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>millisecondsTimeOutInterval</i><br><dl>
<dd>
<param> The time out in milliseconds. If the <i>millisecondsTimeOutInterval</i> parameter is zero (0), the function tests the object's state and returns immediately. If <i>millisecondsTimeOutInterval</i> is -1, the function's time-out interval never elapses.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>executeOnlyOnce</i><br><dl>
<dd>
<param><b>true</b> to indicate the thread will no longer wait on the <i>waitObject</i> parameter after the delegate has been called; <b>false</b> to indicate the timer is reset every time the wait operation completes until the wait is unregistered.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The  <a href="../../System.Threading/types/RegisteredWaitHandle.html">RegisteredWaitHandle</a> that encapsulates the native handle.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentOutOfRangeException.html">ArgumentOutOfRangeException</a></td>
<td> The <i>millisecondsTimeOutInterval</i> parameter is less than -1.</td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="RegisterWaitForSingleObjectTopic3"></a><a name="RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)">RegisterWaitForSingleObject</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a> <i>waitObject</i>,</font><br>   <font color="#008080"><a href="../../System.Threading/types/WaitOrTimerCallback.html">WaitOrTimerCallback</a> <i>callBack</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>state</i>,</font><br>   <font color="#008080"><a href="../../System/types/TimeSpan.html">TimeSpan</a> <i>timeout</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>executeOnlyOnce</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Registers a delegate that is waiting for a  <a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a>, using a  <a href="../../System/types/TimeSpan.html">TimeSpan</a> value for the time out.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public static <a href="../../System.Threading/types/RegisteredWaitHandle.html">RegisteredWaitHandle</a> RegisterWaitForSingleObject(<br>   <font color="#008080"><a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a> <i>waitObject</i>,</font><br>   <font color="#008080"><a href="../../System.Threading/types/WaitOrTimerCallback.html">WaitOrTimerCallback</a> <i>callBack</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>state</i>,</font><br>   <font color="#008080"><a href="../../System/types/TimeSpan.html">TimeSpan</a> <i>timeout</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>executeOnlyOnce</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>waitObject</i><br><dl>
<dd>
<param> The  <a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a> to register.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>callBack</i><br><dl>
<dd>
<param> The  <a href="../../System.Threading/types/WaitOrTimerCallback.html">WaitOrTimerCallback</a> delegate to call when the <i>waitObject</i> parameter is signaled.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>state</i><br><dl>
<dd>
<param> The object passed to the delegate.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>timeout</i><br><dl>
<dd>
<param> The time out represented by a  <a href="../../System/types/TimeSpan.html">TimeSpan</a>. If <i>timeout</i> is zero, the function tests the object's state and returns immediately. If <i>timeout</i> is -1, the function's time-out interval never elapses.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>executeOnlyOnce</i><br><dl>
<dd>
<param><b>true</b> to indicate the thread will no longer wait on the <i>waitObject</i> parameter after the delegate has been called; <b>false</b> to indicate the timer is reset every time the wait operation completes until the wait is unregistered.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The  <a href="../../System.Threading/types/RegisteredWaitHandle.html">RegisteredWaitHandle</a> that encapsulates the native handle.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentOutOfRangeException.html">ArgumentOutOfRangeException</a></td>
<td> The <i>timeout</i> parameter is less than -1.</td>
</tr>
<tr valign="top">
<td> <a href="../../System/types/NotSupportedException.html">NotSupportedException</a></td>
<td> The <i>timeout</i> parameter is greater than  <a href="../../System/types/Int32.html#MaxValue">Int32.MaxValue</a>.</td>
</tr>
</table>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="RegisterWaitForSingleObjectTopic4"></a><a name="RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)">RegisterWaitForSingleObject</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a> <i>waitObject</i>,</font><br>   <font color="#008080"><a href="../../System.Threading/types/WaitOrTimerCallback.html">WaitOrTimerCallback</a> <i>callBack</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>state</i>,</font><br>   <font color="#008080"><a href="../../System/types/UInt32.html">uint</a> <i>millisecondsTimeOutInterval</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>executeOnlyOnce</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Registers a delegate that is waiting for a  <a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a>, using a 32-bit unsigned integer for the time out in milliseconds.</dd>
</dl>
<dl>
<dd><b><font color="#FF3399">This member is not CLS Compliant<br><br></font></b></dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code>[CLSCompliant(false)]<br><b>public static <a href="../../System.Threading/types/RegisteredWaitHandle.html">RegisteredWaitHandle</a> RegisterWaitForSingleObject(<br>   <font color="#008080"><a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a> <i>waitObject</i>,</font><br>   <font color="#008080"><a href="../../System.Threading/types/WaitOrTimerCallback.html">WaitOrTimerCallback</a> <i>callBack</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>state</i>,</font><br>   <font color="#008080"><a href="../../System/types/UInt32.html">uint</a> <i>millisecondsTimeOutInterval</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>executeOnlyOnce</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>waitObject</i><br><dl>
<dd>
<param> The  <a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a> to register.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>callBack</i><br><dl>
<dd>
<param> The  <a href="../../System.Threading/types/WaitOrTimerCallback.html">WaitOrTimerCallback</a> delegate to call when the <i>waitObject</i> parameter is signaled.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>state</i><br><dl>
<dd>
<param> The object passed to the delegate.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>millisecondsTimeOutInterval</i><br><dl>
<dd>
<param> The time out in milliseconds. If the <i>millisecondsTimeOutInterval</i> parameter is zero (0), the function tests the object's state and returns immediately. If <i>millisecondsTimeOutInterval</i> is -1, the function's time-out interval never elapses.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>executeOnlyOnce</i><br><dl>
<dd>
<param><b>true</b> to indicate the thread will no longer wait on the <i>waitObject</i> parameter after the delegate has been called; <b>false</b> to indicate the timer is reset every time the wait operation completes until the wait is unregistered.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The  <a href="../../System.Threading/types/RegisteredWaitHandle.html">RegisteredWaitHandle</a> that can be used to cancel the registered wait operation.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System/types/ArgumentOutOfRangeException.html">ArgumentOutOfRangeException</a></td>
<td> The <i>millisecondsTimeOutInterval</i> parameter is less than -1.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> The <b>RegisterWaitForSingleObject</b> method queues the specified delegate to the thread pool. A worker thread will execute the delegate when one of the following occurs: <UL>
<li> The specified object is in the signaled state.</li>
<li> The time-out interval elapses.</li>
</UL>
<p> The <b>RegisterWaitForSingleObject</b> method checks the current state of the specified object's  <a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a>. If the object's state is non-signaled, the method registers a wait operation. The wait operation is performed by a thread from the thread pool. The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses. If the <i>timeOutInterval</i> parameter is not zero (0) and the <i>executeOnlyOnce</i> parameter is not <b>false</b>, the timer is reset every time the event is signaled or the time-out interval elapses.</p>
<p> To cancel the wait operation, call the  <a href="../../System.Threading/types/RegisteredWaitHandle.html#Unregister(System.Threading.WaitHandle)">RegisteredWaitHandle.Unregister</a> method.</p>
<p> The wait thread uses the <b>WaitForMultipleObjects</b> function to monitor registered wait operations. Therefore, if you must use the same native operating system handle in multiple calls to <b>RegisterWaitForSingleObject</b>, you must duplicate the handle using the Win32 <b>DuplicateHandle</b> function. Note that you should not pulse an event object passed to <b>RegisterWaitForSingleObject</b>, because the wait thread might not detect that the event is signaled before it is reset.</p>
<p> Before returning, the function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the wait condition to be satisfied. For example, the count of a semaphore is decreased by one.</p>
</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="ToStringTopic1"></a><a name="ToString">ToString</a></i></b><b><i>()</i></b><dl>
<dd><b><font color="#800080"> Inherited<br>See base class member description: <a href="../../System/types/Object.html#ToString">System.Object.ToString</a></font></b></dd>
</dl>
<dl>
<dd>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public virtual string ToString();</b></code></td>
</tr>
</table>
</dd>
</dl><br>For more information on members inherited from System.Object click on the link above.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Method: <i><a name="UnsafeQueueUserWorkItemTopic1"></a><a name="UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)">UnsafeQueueUserWorkItem</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Threading/types/WaitCallback.html">WaitCallback</a> <i>callBack</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>state</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Queues a user work item to the thread pool.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public static <a href="../../System/types/Boolean.html">bool</a> UnsafeQueueUserWorkItem(<br>   <font color="#008080"><a href="../../System.Threading/types/WaitCallback.html">WaitCallback</a> <i>callBack</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>state</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>callBack</i><br><dl>
<dd>
<param> A <b>WaitCallback</b> representing the delegate to invoke when a thread in the thread pool picks up the work item.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>state</i><br><dl>
<dd>
<param> The object that is passed to the delegate when serviced from the thread pool.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd><b>true</b> if the method succeeds; otherwise, <b>false</b>.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Security/types/SecurityException.html">SecurityException</a></td>
<td> The caller does not have the required permission.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This is an unsafe version of  <a href="#QueueUserWorkItem(System.Threading.WaitCallback,System.Object)">ThreadPool.QueueUserWorkItem</a> that does not propagate the calling stack onto the worker thread. This allows code to lose the calling stack and thereby elevate its security privileges.</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/SecurityPermission.html">SecurityPermission</a> to provide evidence and view and modify policy. Associated enumerations:  <a href="../../System.Security.Permissions/types/SecurityPermissionFlag.html#ControlEvidence">SecurityPermissionFlag.ControlEvidence</a>,  <a href="../../System.Security.Permissions/types/SecurityPermissionFlag.html#ControlPolicy">SecurityPermissionFlag.ControlPolicy</a>.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="UnsafeRegisterWaitForSingleObjectTopic1"></a><a name="UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)">UnsafeRegisterWaitForSingleObject</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a> <i>waitObject</i>,</font><br>   <font color="#008080"><a href="../../System.Threading/types/WaitOrTimerCallback.html">WaitOrTimerCallback</a> <i>callBack</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>state</i>,</font><br>   <font color="#008080"><a href="../../System/types/Int32.html">int</a> <i>millisecondsTimeOutInterval</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>executeOnlyOnce</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Queues the specified delegate to the thread pool.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public static <a href="../../System.Threading/types/RegisteredWaitHandle.html">RegisteredWaitHandle</a> UnsafeRegisterWaitForSingleObject(<br>   <font color="#008080"><a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a> <i>waitObject</i>,</font><br>   <font color="#008080"><a href="../../System.Threading/types/WaitOrTimerCallback.html">WaitOrTimerCallback</a> <i>callBack</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>state</i>,</font><br>   <font color="#008080"><a href="../../System/types/Int32.html">int</a> <i>millisecondsTimeOutInterval</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>executeOnlyOnce</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>waitObject</i><br><dl>
<dd>
<param> The  <a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a> to register.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>callBack</i><br><dl>
<dd>
<param> The delegate to call when the <i>waitObject</i> parameter is signaled.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>state</i><br><dl>
<dd>
<param> The object that is passed to the delegate.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>millisecondsTimeOutInterval</i><br><dl>
<dd>
<param> The time out in milliseconds. If the <i>millisecondsTimeOutInterval</i> parameter is zero (0), the function tests the object's state and returns immediately. If <i>millisecondsTimeOutInterval</i> is -1, the function's time-out interval never elapses.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>executeOnlyOnce</i><br><dl>
<dd>
<param><b>true</b> to indicate the thread will no longer wait on the <i>waitObject</i> parameter after the delegate has been called; <b>false</b> to indicate the timer is reset every time the wait operation completes until the wait is unregistered.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The  <a href="../../System.Threading/types/RegisteredWaitHandle.html">RegisteredWaitHandle</a> object that can be used to cancel the registered wait operation.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Security/types/SecurityException.html">SecurityException</a></td>
<td> The caller does not have the required permission.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This is an unsafe version of  <a href="#RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)">ThreadPool.RegisterWaitForSingleObject</a> that does not propagate the calling stack onto the worker thread. This allows code to lose the calling stack and thereby elevate its security privileges.</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/SecurityPermission.html">SecurityPermission</a> to provide evidence and view and modify policy. Associated enumerations:  <a href="../../System.Security.Permissions/types/SecurityPermissionFlag.html#ControlEvidence">SecurityPermissionFlag.ControlEvidence</a>,  <a href="../../System.Security.Permissions/types/SecurityPermissionFlag.html#ControlPolicy">SecurityPermissionFlag.ControlPolicy</a>.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="UnsafeRegisterWaitForSingleObjectTopic2"></a><a name="UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)">UnsafeRegisterWaitForSingleObject</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a> <i>waitObject</i>,</font><br>   <font color="#008080"><a href="../../System.Threading/types/WaitOrTimerCallback.html">WaitOrTimerCallback</a> <i>callBack</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>state</i>,</font><br>   <font color="#008080"><a href="../../System/types/Int64.html">long</a> <i>millisecondsTimeOutInterval</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>executeOnlyOnce</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Queues the specified delegate to the thread pool.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public static <a href="../../System.Threading/types/RegisteredWaitHandle.html">RegisteredWaitHandle</a> UnsafeRegisterWaitForSingleObject(<br>   <font color="#008080"><a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a> <i>waitObject</i>,</font><br>   <font color="#008080"><a href="../../System.Threading/types/WaitOrTimerCallback.html">WaitOrTimerCallback</a> <i>callBack</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>state</i>,</font><br>   <font color="#008080"><a href="../../System/types/Int64.html">long</a> <i>millisecondsTimeOutInterval</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>executeOnlyOnce</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>waitObject</i><br><dl>
<dd>
<param> The  <a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a> to register.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>callBack</i><br><dl>
<dd>
<param> The delegate to call when the <i>waitObject</i> parameter is signaled.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>state</i><br><dl>
<dd>
<param> The object that is passed to the delegate.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>millisecondsTimeOutInterval</i><br><dl>
<dd>
<param> The time out in milliseconds. If the <i>millisecondsTimeOutInterval</i> parameter is zero (0), the function tests the object's state and returns immediately. If <i>millisecondsTimeOutInterval</i> is -1, the function's time-out interval never elapses.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>executeOnlyOnce</i><br><dl>
<dd>
<param><b>true</b> to indicate the thread will no longer wait on the <i>waitObject</i> parameter after the delegate has been called; <b>false</b> to indicate the timer is reset every time the wait operation completes until the wait is unregistered.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The  <a href="../../System.Threading/types/RegisteredWaitHandle.html">RegisteredWaitHandle</a> object that can be used to cancel the registered wait operation.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Security/types/SecurityException.html">SecurityException</a></td>
<td> The caller does not have the required permission.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This is an unsafe version of  <a href="#RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)">ThreadPool.RegisterWaitForSingleObject</a> that does not propagate the calling stack onto the worker thread. This allows code to lose the calling stack and thereby elevate its security privileges.</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/SecurityPermission.html">SecurityPermission</a> to provide evidence and view and modify policy. Associated enumerations:  <a href="../../System.Security.Permissions/types/SecurityPermissionFlag.html#ControlEvidence">SecurityPermissionFlag.ControlEvidence</a>,  <a href="../../System.Security.Permissions/types/SecurityPermissionFlag.html#ControlPolicy">SecurityPermissionFlag.ControlPolicy</a>.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="UnsafeRegisterWaitForSingleObjectTopic3"></a><a name="UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)">UnsafeRegisterWaitForSingleObject</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a> <i>waitObject</i>,</font><br>   <font color="#008080"><a href="../../System.Threading/types/WaitOrTimerCallback.html">WaitOrTimerCallback</a> <i>callBack</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>state</i>,</font><br>   <font color="#008080"><a href="../../System/types/TimeSpan.html">TimeSpan</a> <i>timeout</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>executeOnlyOnce</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Queues the specified delegate to the thread pool.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code><b>
            public static <a href="../../System.Threading/types/RegisteredWaitHandle.html">RegisteredWaitHandle</a> UnsafeRegisterWaitForSingleObject(<br>   <font color="#008080"><a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a> <i>waitObject</i>,</font><br>   <font color="#008080"><a href="../../System.Threading/types/WaitOrTimerCallback.html">WaitOrTimerCallback</a> <i>callBack</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>state</i>,</font><br>   <font color="#008080"><a href="../../System/types/TimeSpan.html">TimeSpan</a> <i>timeout</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>executeOnlyOnce</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>waitObject</i><br><dl>
<dd>
<param> The  <a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a> to register.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>callBack</i><br><dl>
<dd>
<param> The delegate to call when the <i>waitObject</i> parameter is signaled.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>state</i><br><dl>
<dd>
<param> The object that is passed to the delegate.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>timeout</i><br><dl>
<dd>
<param> The time out represented by a  <a href="../../System/types/TimeSpan.html">TimeSpan</a>. If <i>timeout</i> is zero, the function tests the object's state and returns immediately. If <i>timeout</i> is -1, the function's time-out interval never elapses.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>executeOnlyOnce</i><br><dl>
<dd>
<param><b>true</b> to indicate the thread will no longer wait on the <i>waitObject</i> parameter after the delegate has been called; <b>false</b> to indicate the timer is reset every time the wait operation completes until the wait is unregistered.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The  <a href="../../System.Threading/types/RegisteredWaitHandle.html">RegisteredWaitHandle</a> object that can be used to cancel the registered wait operation.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Security/types/SecurityException.html">SecurityException</a></td>
<td> The caller does not have the required permission.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This is an unsafe version of  <a href="#RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)">ThreadPool.RegisterWaitForSingleObject</a> that does not propagate the calling stack onto the worker thread. This allows code to lose the calling stack and thereby elevate its security privileges.</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/SecurityPermission.html">SecurityPermission</a> to provide evidence and view and modify policy. Associated enumerations:  <a href="../../System.Security.Permissions/types/SecurityPermissionFlag.html#ControlEvidence">SecurityPermissionFlag.ControlEvidence</a>,  <a href="../../System.Security.Permissions/types/SecurityPermissionFlag.html#ControlPolicy">SecurityPermissionFlag.ControlPolicy</a>.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite"><b>Overloaded Method: <i><a name="UnsafeRegisterWaitForSingleObjectTopic4"></a><a name="UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)">UnsafeRegisterWaitForSingleObject</a></i></b><b><i>(<br>   <font color="#008080"><a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a> <i>waitObject</i>,</font><br>   <font color="#008080"><a href="../../System.Threading/types/WaitOrTimerCallback.html">WaitOrTimerCallback</a> <i>callBack</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>state</i>,</font><br>   <font color="#008080"><a href="../../System/types/UInt32.html">uint</a> <i>millisecondsTimeOutInterval</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>executeOnlyOnce</i></font><br>)</i></b><dl>
<dt><b>Summary</b></dt>
<dd> Queues the specified delegate to the thread pool.</dd>
</dl>
<dl>
<dd><b><font color="#FF3399">This member is not CLS Compliant<br><br></font></b></dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code>[CLSCompliant(false)]<br><b>public static <a href="../../System.Threading/types/RegisteredWaitHandle.html">RegisteredWaitHandle</a> UnsafeRegisterWaitForSingleObject(<br>   <font color="#008080"><a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a> <i>waitObject</i>,</font><br>   <font color="#008080"><a href="../../System.Threading/types/WaitOrTimerCallback.html">WaitOrTimerCallback</a> <i>callBack</i>,</font><br>   <font color="#008080"><a href="../../System/types/Object.html">object</a> <i>state</i>,</font><br>   <font color="#008080"><a href="../../System/types/UInt32.html">uint</a> <i>millisecondsTimeOutInterval</i>,</font><br>   <font color="#008080"><a href="../../System/types/Boolean.html">bool</a> <i>executeOnlyOnce</i></font><br>);</b></code></td>
</tr>
</table>
</dd>
</dl><b>Parameters:</b><br><dl>
<dd>
<p><i>waitObject</i><br><dl>
<dd>
<param> The  <a href="../../System.Threading/types/WaitHandle.html">WaitHandle</a> to register.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>callBack</i><br><dl>
<dd>
<param> The delegate to call when the <i>waitObject</i> parameter is signaled.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>state</i><br><dl>
<dd>
<param> The object that is passed to the delegate.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>millisecondsTimeOutInterval</i><br><dl>
<dd>
<param> The time out in milliseconds. If the <i>millisecondsTimeOutInterval</i> parameter is zero (0), the function tests the object's state and returns immediately. If <i>millisecondsTimeOutInterval</i> is -1, the function's time-out interval never elapses.
</dd>
</dl>
</p>
</dd>
<dd>
<p><i>executeOnlyOnce</i><br><dl>
<dd>
<param><b>true</b> to indicate the thread will no longer wait on the <i>waitObject</i> parameter after the delegate has been called; <b>false</b> to indicate the timer is reset every time the wait operation completes until the wait is unregistered.
</dd>
</dl>
</p>
</dd>
</dl>
<dl>
<dt><b>Return Value: </b></dt>
<dd> The  <a href="../../System.Threading/types/RegisteredWaitHandle.html">RegisteredWaitHandle</a> object that can be used to cancel the registered wait operation.</dd>
</dl>
<dl>
<dt><b>Exceptions </b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<th width="30%">Exception Type</th>
<th width="60%">Condition</th>
</tr>
<tr valign="top">
<td> <a href="../../System.Security/types/SecurityException.html">SecurityException</a></td>
<td> The caller does not have the required permission.</td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> This is an unsafe version of  <a href="#RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)">ThreadPool.RegisterWaitForSingleObject</a> that does not propagate the calling stack onto the worker thread. This allows code to lose the calling stack and thereby elevate its security privileges.</dd>
</dl><b>.NET Framework Security:</b><dl>
<dd> <a href="../../System.Security.Permissions/types/SecurityPermission.html">SecurityPermission</a> to provide evidence and view and modify policy. Associated enumerations:  <a href="../../System.Security.Permissions/types/SecurityPermissionFlag.html#ControlEvidence">SecurityPermissionFlag.ControlEvidence</a>,  <a href="../../System.Security.Permissions/types/SecurityPermissionFlag.html#ControlPolicy">SecurityPermissionFlag.ControlPolicy</a>.</dd>
</dl>
<h4 align="center"><a href="#TopOfPage" class="top">
						Return to top
					</a></h4>
<hr class="lite">
<h3 align="center"><a href="#TopOfPage">
					Top of page
				</a></h3><i><a href="../../documentation_license.txt">
				  Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
				</a></i></body>
</html>
