<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../refdoc.css">
<title>Type: System.Reflection.BindingFlags</title>
</head>
<body><a name="TopOfPage"></a><h2>System.Reflection.BindingFlags Enumeration</h2><b>Assembly: </b>Mscorlib.dll<br><b>Namespace: </b>System.Reflection<br><dl>
<dt><b>Summary</b></dt>
<dd> Specifies flags that control binding and the way in which the search for members and types is conducted by reflection.</dd>
</dl>
<dl>
<dt><b>C# Syntax:</b></dt>
<dd>
<table border="1" class="syntax" width="90%" style="border-collapse: collapse">
<tr>
<td><code>[Flags]<br>[Serializable]<br><b>public enum BindingFlags</b></code></td>
</tr>
</table>
</dd>
</dl><b>Remarks</b><dl>
<dd> These <b>BindingFlags</b> control enumeration for a great many classes in the <b>System</b>, <b>System.Reflection</b>, and <b>System.Runtime</b> namespaces that invoke, create, get, set, and find members and types.<p><b>BindingFlags</b> are used in the following  <a href="../../System/types/Type.html">Type</a> methods and other places such as  <a href="../../System.Reflection/types/MethodBase.html#Invoke(System.Object,System.Object[])">MethodBase.Invoke</a>: </p>
<UL>
<li> <a href="../../System.Reflection/types/MethodBase.html#Invoke(System.Object,System.Object[])">MethodBase.Invoke</a></li>
<li> <a href="../../System/types/Type.html#GetMembers">Type.GetMembers</a></li>
<li> <a href="../../System/types/Type.html#GetEvents">Type.GetEvents</a></li>
<li> <a href="../../System/types/Type.html#InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">Type.InvokeMember</a></li>
<li> <a href="../../System/types/Activator.html#CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">Activator.CreateInstance</a></li>
<li> <a href="../../System/types/Type.html#GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetConstructor</a></li>
<li> <a href="../../System/types/Type.html#GetConstructors">Type.GetConstructors</a></li>
<li> <a href="../../System/types/Type.html#GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetMethod</a></li>
<li> <a href="../../System/types/Type.html#GetMethods">Type.GetMethods</a></li>
<li> <a href="../../System/types/Type.html#GetField(System.String,System.Reflection.BindingFlags)">Type.GetField</a></li>
<li> <a href="../../System/types/Type.html#GetFields">Type.GetFields</a></li>
<li> <a href="../../System/types/Type.html#GetEvent(System.String)">Type.GetEvent</a></li>
<li> <a href="../../System/types/Type.html#GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">Type.GetProperty</a></li>
<li> <a href="../../System/types/Type.html#GetProperties(System.Reflection.BindingFlags)">Type.GetProperties</a></li>
<li> <a href="../../System/types/Type.html#GetMember(System.String)">Type.GetMember</a></li>
<li> <a href="../../System/types/Type.html#FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">Type.FindMembers</a></li>
</UL>
<p> <a href="../../System/types/Type.html#InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">Type.InvokeMember</a> and  <a href="../../System/types/Type.html#GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">Type.GetMethod</a> are especially important.</p>
<p> The binding flags are categorized as follows.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
              Binding Flag
            </TH>
<TH>
              Purpose
            </TH>
</THEAD>
<TR valign="top">
<TD><b>DeclaredOnly</b></TD>
<TD>
              Access Control
            </TD>
</TR>
<TR valign="top">
<TD><b>FlattenHierarchy</b></TD>
<TD>
              Access Control
            </TD>
</TR>
<TR valign="top">
<TD><b>IgnoreCase</b></TD>
<TD>
              Access Control
            </TD>
</TR>
<TR valign="top">
<TD><b>IgnoreReturn</b></TD>
<TD>
              Access Control
            </TD>
</TR>
<TR valign="top">
<TD><b>Instance</b></TD>
<TD>
              Access Control
            </TD>
</TR>
<TR valign="top">
<TD><b>NonPublic</b></TD>
<TD>
              Access Control
            </TD>
</TR>
<TR valign="top">
<TD><b>Public</b></TD>
<TD>
              Access Control
            </TD>
</TR>
<TR valign="top">
<TD><b>Static</b></TD>
<TD>
              Access Control
            </TD>
</TR>
<TR valign="top">
<TD><b>ExactBinding</b></TD>
<TD>
              Change Type
            </TD>
</TR>
<TR valign="top">
<TD><b>OptionalParamBinding</b></TD>
<TD>
              Change Type
            </TD>
</TR>
<TR valign="top">
<TD><b>CreateInstance</b></TD>
<TD>
              Operation Type
            </TD>
</TR>
<TR valign="top">
<TD><b>GetField</b></TD>
<TD>
              Operation Type
            </TD>
</TR>
<TR valign="top">
<TD><b>SetField</b></TD>
<TD>
              Operation Type
            </TD>
</TR>
<TR valign="top">
<TD><b>GetProperty</b></TD>
<TD>
              Operation Type
            </TD>
</TR>
<TR valign="top">
<TD><b>SetProperty</b></TD>
<TD>
              Operation Type
            </TD>
</TR>
<TR valign="top">
<TD><b>InvokeMethod</b></TD>
<TD>
              Operation Type
            </TD>
</TR>
<TR valign="top">
<TD><b>PutDispProperty</b></TD>
<TD>
              Operation Type
            </TD>
</TR>
<TR valign="top">
<TD><b>PutRefDispProperty</b></TD>
<TD>
              Operation Type
            </TD>
</TR>
</table><br><br><b>Note </b> You must specify <b>Instance</b> or <b>Static</b> along with <b>Public</b> or <b>NonPublic</b> or no members will be returned.<p> The following table lists the coercions performed by the default  <a href="../../System.Reflection/types/Binder.html#ChangeType(System.Object,System.Type,System.Globalization.CultureInfo)">Binder.ChangeType</a>. This table applies especially to the <b>ExactBinding</b> binding flag.</p><br><br><table border="1" width="90%" style="border-collapse: collapse">
<THEAD>
<TH>
              Source Type
            </TH>
<TH>
              Target Type
            </TH>
</THEAD>
<TR valign="top">
<TD>
              Any type
            </TD>
<TD>
              Its base type.
            </TD>
</TR>
<TR valign="top">
<TD>
              Any type
            </TD>
<TD>
              The interface it implements.
            </TD>
</TR>
<TR valign="top">
<TD><b>Char</b></TD>
<TD><b>UInt16</b>
              ,
              <b>UInt32</b>
              ,
              <b>Int32</b>
              ,
              <b>UInt64</b>
              ,
              <b>Int64</b>
              ,
              <b>Single</b>
              ,
              <b>Double</b></TD>
</TR>
<TR valign="top">
<TD><b>Byte</b></TD>
<TD><b>Char</b>
              ,
              <b>UInt16</b>
              ,
              <b>Int16</b>
              ,
              <b>UInt32</b>
              ,
              <b>Int32</b>
              ,
              <b>UInt64</b>
              ,
              <b>Int64</b>
              ,
              <b>Single</b>
              ,
              <b>Double</b></TD>
</TR>
<TR valign="top">
<TD><b>SByte</b></TD>
<TD><b>Int16</b>
              ,
              <b>Int32</b>
              ,
              <b>Int64</b>
              ,
              <b>Single</b>
              ,
              <b>Double</b></TD>
</TR>
<TR valign="top">
<TD><b>UInt16</b></TD>
<TD><b>UInt32</b>
              ,
              <b>Int32</b>
              ,
              <b>UInt64</b>
              ,
              <b>Int64</b>
              ,
              <b>Single</b>
              ,
              <b>Double</b></TD>
</TR>
<TR valign="top">
<TD><b>Int16</b></TD>
<TD><b>Int32</b>
              ,
              <b>Int64</b>
              ,
              <b>Single</b>
              ,
              <b>Double</b></TD>
</TR>
<TR valign="top">
<TD><b>UInt32</b></TD>
<TD><b>UInt64</b>
              ,
              <b>Int64</b>
              ,
              <b>Single</b>
              ,
              <b>Double</b></TD>
</TR>
<TR valign="top">
<TD><b>Int32</b></TD>
<TD><b>Int64</b>
              ,
              <b>Single</b>
              ,
              <b>Double</b></TD>
</TR>
<TR valign="top">
<TD><b>UInt64</b></TD>
<TD><b>Single</b>
              ,
              <b>Double</b></TD>
</TR>
<TR valign="top">
<TD><b>Int64</b></TD>
<TD><b>Single</b>
              ,
              <b>Double</b></TD>
</TR>
<TR valign="top">
<TD><b>Single</b></TD>
<TD><b>Double</b></TD>
</TR>
<TR valign="top">
<TD>
              Non-reference
            </TD>
<TD>
              By-reference.
            </TD>
</TR>
</table>
</dd>
</dl><b>Example</b><dl>
<dd>
<pre>
			//Call an instance method
			Console.WriteLine();
			Console.WriteLine("Invoking an Instance method");
			Console.WriteLine("---------------------------------");
			tc.GetType().InvokeMember ("AddUp", BindingFlags.Public | 
				BindingFlags.Instance | BindingFlags.CreateInstance, 
				null, tc, new object [] {});

    </pre>
<pre>
			//Call an instance method
			TestClass tc2 = new TestClass();
			Console.WriteLine();
			Console.WriteLine("DeclaredOnly members");
			Console.WriteLine("---------------------------------");
			System.Reflection.MemberInfo[] memInfo = 
				tc2.GetType().GetMembers(BindingFlags.DeclaredOnly);
			for(int i=0;i&lt;memInfo.Length;i++) {
				Console.WriteLine(memInfo[i].Name);
			}

    </pre>
<pre>
			//Call the default member of a type
			Type t3 = typeof (TestClass2);
			t3.InvokeMember ("", BindingFlags.InvokeMethod | BindingFlags.Default, null, new TestClass2(), new object [] {});

    </pre>
<pre>
      // Get the method named 'MyMethod'.
      Console.WriteLine("\nDisplaying a method with (int) and (short) parameters.\n");
      // Get the method name 'MyMethod' without exact binding.
      myMethod = myType.GetMethod("MyMethod", 
         new Type[]{typeof(int), typeof(short)});
      Console.WriteLine(myMethod);
      Console.WriteLine("\nDisplaying a method with (int) and (short) parameters.\n");
      // Get the method name 'MyMethod' with exact binding.
      myMethod = myType.GetMethod("MyMethod", BindingFlags.ExactBinding |
         BindingFlags.Public | BindingFlags.Instance, null,
         new Type[]{typeof(int), typeof(short)}, null);
      // Fails to find method with the exact signature as 'MyMethod(int, short)'.
      Console.WriteLine(myMethod);

    </pre>
<pre>
      // Get all the static fields in a class and its base classes.
      myType = typeof(MyClassDerived);
      Console.WriteLine("\nDisplaying the public static fields in 'MyClassDerived'.\n");
      myFields = myType.GetFields(BindingFlags.Public | 
         BindingFlags.Static);
      for(int i = 0; i &lt; myFields.Length; i++)
         Console.WriteLine(myFields[i]);

      Console.WriteLine("\nDisplaying the public static fields in all base classes of and in 'MyClassDerived'.\n");
      // Get all the public static fields declared in all base classes of and in 'MyClassDerived'.
      myFields = myType.GetFields(BindingFlags.FlattenHierarchy | 
         BindingFlags.Public | 
         BindingFlags.Static);
      for(int i = 0; i &lt; myFields.Length; i++)
         Console.WriteLine(myFields[i]);

    </pre>
<pre>
			//Get a field value
			result = t.InvokeMember ("Name", BindingFlags.GetField, null, c, new object [] {});
			Console.WriteLine ("Name == {0}", result);

    </pre>
<pre>
			//Get an indexed property value
			int  index = 3;
			result = t.InvokeMember ("Item", BindingFlags.GetProperty, null, c, new object [] {index});
			Console.WriteLine ("Item[{0}] == {1}", index, result);

    </pre>
<pre>
      // Get the method 'mymethod' irrespective of the case.
      myType = typeof(MyClass);
      Console.WriteLine("\nDisplaying the methods named 'mymethod' (case insensitive)\n");
      
      // Get the method named 'MyMethod'.
      myMethod = myType.GetMethod("mymethod", BindingFlags.IgnoreCase |
         BindingFlags.Public |
         BindingFlags.Instance);
      Console.WriteLine(myMethod);

    </pre>
<pre>
			//Call a static method
			Console.WriteLine();
			Console.WriteLine("Invoking static method - PrintName");
			Console.WriteLine("---------------------------------");
			methInfo = obj.GetType().GetMethod("PrintName");
			methInfo.Invoke(obj,BindingFlags.IgnoreReturn | 
				BindingFlags.InvokeMethod, null,new object[] 
				{"Brad","Smith"},null);

    </pre>
<pre>
			//Call an instance method
			TestClass tc = new TestClass ();
			Console.WriteLine();
			Console.WriteLine("Invoking an Instance method");
			Console.WriteLine("---------------------------------");
			tc.GetType().InvokeMember ("AddUp", BindingFlags.Public | 
				BindingFlags.Instance | BindingFlags.CreateInstance, 
				null, tc, new object [] {});

    </pre>
<pre>
			//Call an instance method
			TestClass c = new TestClass ();

			Console.WriteLine();
			Console.WriteLine("Invoking an Instance method");
			Console.WriteLine("---------------------------------");
			c.GetType().InvokeMember ("AddUp", BindingFlags.InvokeMethod, null, c, new object [] {});
			c.GetType().InvokeMember ("AddUp", BindingFlags.InvokeMethod, null, c, new object [] {});

    </pre>
<pre>
			MethodInfo [] miNonPublic = type.GetMethods (BindingFlags.Static |
					BindingFlags.NonPublic);  // methods

    </pre>
<pre>
			//Call a static method
			Console.WriteLine();
			Console.WriteLine("Invoking static method - PrintName");
			Console.WriteLine("---------------------------------");
			methInfo = obj.GetType().GetMethod("PrintName");
			methInfo.Invoke(obj,BindingFlags.OptionalParamBinding | 
				BindingFlags.InvokeMethod, null,new object[] 
				{"Brad","Smith"},null);

    </pre>
<pre>
      // Get public fields.
      Console.WriteLine("\nDisplaying public fields.\n");
      myFields = myType.GetFields(BindingFlags.Public | 
         BindingFlags.Instance);
      for(int i = 0; i &lt; myFields.Length; i++)
         Console.WriteLine(myFields[i]);

    </pre>
<pre>
      // Set the value of a public field.
      Console.WriteLine("\nDisplaying the value of a field after setting it.\n");
      result = myType.InvokeMember("myFieldD", BindingFlags.SetField,
         null, myInstance, new object[]{(int)32},
         null);
      Console.WriteLine(myInstance.myFieldD);

    </pre>
<pre>
      // Set the value of a public property.
      Console.WriteLine("\nDisplaying the value of a property after setting it.\n");
      result = myType.InvokeMember("MyProperty", BindingFlags.SetProperty,
         null, myInstance, new object[]{(int)32},
         null);
      Console.WriteLine(myInstance.MyProperty);

    </pre>
<pre>
      // Get private fields.
      Console.WriteLine("\nDisplaying private fields.\n");
      myFields = myType.GetFields(BindingFlags.NonPublic | 
         BindingFlags.Instance);
      for(int i = 0; i &lt; myFields.Length; i++)
         Console.WriteLine(myFields[i]);

    </pre>
</dd>
</dl><b>See also: </b><dl>
<dd> <a href="../../System.Reflection/System.Reflection.html">System.Reflection Namespace</a></dd>
</dl>
<h3>System.Reflection.BindingFlags Member List: </h3>
<dl>
<dt><b>Public Fields</b></dt>
<dd>
<table border="1" width="90%" style="border-collapse: collapse">
<tr valign="top">
<td width="35%"><b>CreateInstance</b></td>
<td width="55%"> Specifies that Reflection should create an instance of the specified type. Calls the constructor that matches the given arguments. The supplied member name is ignored. If the type of lookup is not specified, (Instance | Public) will apply. It is not possible to call a type initializer.</td>
</tr>
<tr valign="top">
<td width="35%"><b>DeclaredOnly</b></td>
<td width="55%"> Specifies that only members declared at the level of the supplied type's hierarchy should be considered. Inherited members are not considered.</td>
</tr>
<tr valign="top">
<td width="35%"><b>Default</b></td>
<td width="55%"> Specifies no binding flag.</td>
</tr>
<tr valign="top">
<td width="35%"><b>ExactBinding</b></td>
<td width="55%"> Specifies that types of the supplied arguments must exactly match the types of the corresponding formal parameters. When this flag is specified,  <a href="../../System/types/Type.html#DefaultBinder">Type.DefaultBinder</a> is called. Reflection throws an exception if the caller supplies a non-null <b>Binder</b> object, since that implies that the caller is supplying <b>BindToXXX</b> implementations that will pick the appropriate method. Reflection models the accessibility rules of the common type system. For example, if the caller is in the same assembly, the caller does not need special permissions for internal members. Otherwise, the caller needs  <a href="../../System.Security.Permissions/types/ReflectionPermission.html">ReflectionPermission</a>. This is consistent with lookup of members that are protected, private, and so on. The general principle is that  <a href="../../System.Reflection/types/Binder.html#ChangeType(System.Object,System.Type,System.Globalization.CultureInfo)">Binder.ChangeType</a> should perform only widening coercions, which never lose data. An example of a widening coercion is coercing a value that is a 32-bit signed integer to a value that is a 64-bit signed integer. This is distinguished from a narrowing coercion, which may lose data. An example of a narrowing coercion is coercing a 64-bit signed integer to a 32-bit signed integer. The default binder ignores this flag, while custom binders can implement the semantics of this flag.</td>
</tr>
<tr valign="top">
<td width="35%"><b>FlattenHierarchy</b></td>
<td width="55%"> Specifies that static members up the hierarchy should be returned. Static members include fields, methods, events, and properties. Nested types are not returned.</td>
</tr>
<tr valign="top">
<td width="35%"><b>GetField</b></td>
<td width="55%"> Specifies that the value of the specified field should be returned.</td>
</tr>
<tr valign="top">
<td width="35%"><b>GetProperty</b></td>
<td width="55%"> Specifies that the value of the specified property should be returned.</td>
</tr>
<tr valign="top">
<td width="35%"><b>IgnoreCase</b></td>
<td width="55%"></td>
</tr>
<tr valign="top">
<td width="35%"><b>IgnoreReturn</b></td>
<td width="55%"> Used in COM Interop to specify that the return value of the member can be ignored.</td>
</tr>
<tr valign="top">
<td width="35%"><b>Instance</b></td>
<td width="55%"> Specifies that instance members are to be included in the search.</td>
</tr>
<tr valign="top">
<td width="35%"><b>InvokeMethod</b></td>
<td width="55%"> Specifies that a method is to be invoked. This may not be a constructor or a type initializer.</td>
</tr>
<tr valign="top">
<td width="35%"><b>NonPublic</b></td>
<td width="55%"> Specifies that non-public members are to be included in the search.</td>
</tr>
<tr valign="top">
<td width="35%"><b>OptionalParamBinding</b></td>
<td width="55%"> Returns the set of members whose parameter count matches the number of supplied arguments. This binding flag is used for methods with parameters that have default values and methods with variable arguments (varargs). This flag should only be used with  <a href="../../System/types/Type.html#InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">Type.InvokeMember</a>. Parameters with default values are used only in calls where trailing arguments are omitted. They must be the last arguments.</td>
</tr>
<tr valign="top">
<td width="35%"><b>Public</b></td>
<td width="55%"> Specifies that public members are to be included in the search.</td>
</tr>
<tr valign="top">
<td width="35%"><b>PutDispProperty</b></td>
<td width="55%"> Specifies that the <b>PROPPUT</b> member on a COM object should be invoked.<b>PROPPUT</b> specifies a property-setting function that uses a value. Use <b>PutDispProperty</b> if a property has both <b>PROPPUT</b> and <b>PROPPUTREF</b> and you need to distinguish which one is called.</td>
</tr>
<tr valign="top">
<td width="35%"><b>PutRefDispProperty</b></td>
<td width="55%"> Specifies that the <b>PROPPUTREF</b> member on a COM object should be invoked.<b>PROPPUTREF</b> specifies a property-setting function that uses a reference instead of a value. Use <b>PutRefDispProperty</b> if a property has both <b>PROPPUT</b> and <b>PROPPUTREF</b> and you need to distinguish which one is called.</td>
</tr>
<tr valign="top">
<td width="35%"><b>SetField</b></td>
<td width="55%"> Specifies that the value of the specified field should be set.</td>
</tr>
<tr valign="top">
<td width="35%"><b>SetProperty</b></td>
<td width="55%"> Specifies that the value of the specified property should be set. For COM properties, specifying this binding flag is equivalent to specifying <b>PutDispProperty</b> and <b>PutRefDispProperty</b>.</td>
</tr>
<tr valign="top">
<td width="35%"><b>Static</b></td>
<td width="55%"> Specifies that static members are to be included in the search.</td>
</tr>
<tr valign="top">
<td width="35%"><b>SuppressChangeType</b></td>
<td width="55%"></td>
</tr>
</table>
</dd>
</dl>
<p><b>Hierarchy:</b><ul class="none">
<li><a href="../../System/types/Object.html">System.Object</a></li>
<ul class="none">
<li><a href="../../System/types/ValueType.html">System.ValueType</a></li>
<ul class="none">
<li><a href="../../System/types/Enum.html">System.Enum</a></li>
<ul class="none">
<li><b>System.Reflection.BindingFlags</b></li>
</ul>
</ul>
</ul>
</ul>
</p>
<hr>
<h3 align="center"><a href="#TopOfPage">
					Top of page
				</a></h3><i><a href="../../documentation_license.txt">
				  Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
				</a></i></body>
</html>
